(self.webpackChunkfood=self.webpackChunkfood||[]).push([[573],{931:module=>{"use strict";eval("/**\n * Based on Kendo UI Core expression code <https://github.com/telerik/kendo-ui-core#license-information>\n */\n\n\nfunction Cache(maxSize) {\n  this._maxSize = maxSize;\n  this.clear();\n}\nCache.prototype.clear = function () {\n  this._size = 0;\n  this._values = Object.create(null);\n};\nCache.prototype.get = function (key) {\n  return this._values[key];\n};\nCache.prototype.set = function (key, value) {\n  this._size >= this._maxSize && this.clear();\n  if (!(key in this._values)) this._size++;\n  return this._values[key] = value;\n};\nvar SPLIT_REGEX = /[^.^\\]^[]+|(?=\\[\\]|\\.\\.)/g,\n  DIGIT_REGEX = /^\\d+$/,\n  LEAD_DIGIT_REGEX = /^\\d/,\n  SPEC_CHAR_REGEX = /[~`!#$%\\^&*+=\\-\\[\\]\\\\';,/{}|\\\\\":<>\\?]/g,\n  CLEAN_QUOTES_REGEX = /^\\s*(['\"]?)(.*?)(\\1)\\s*$/,\n  MAX_CACHE_SIZE = 512;\nvar pathCache = new Cache(MAX_CACHE_SIZE),\n  setCache = new Cache(MAX_CACHE_SIZE),\n  getCache = new Cache(MAX_CACHE_SIZE);\nvar config;\nmodule.exports = {\n  Cache: Cache,\n  split: split,\n  normalizePath: normalizePath,\n  setter: function setter(path) {\n    var parts = normalizePath(path);\n    return setCache.get(path) || setCache.set(path, function setter(obj, value) {\n      var index = 0;\n      var len = parts.length;\n      var data = obj;\n      while (index < len - 1) {\n        var part = parts[index];\n        if (part === '__proto__' || part === 'constructor' || part === 'prototype') {\n          return obj;\n        }\n        data = data[parts[index++]];\n      }\n      data[parts[index]] = value;\n    });\n  },\n  getter: function getter(path, safe) {\n    var parts = normalizePath(path);\n    return getCache.get(path) || getCache.set(path, function getter(data) {\n      var index = 0,\n        len = parts.length;\n      while (index < len) {\n        if (data != null || !safe) data = data[parts[index++]];else return;\n      }\n      return data;\n    });\n  },\n  join: function join(segments) {\n    return segments.reduce(function (path, part) {\n      return path + (isQuoted(part) || DIGIT_REGEX.test(part) ? '[' + part + ']' : (path ? '.' : '') + part);\n    }, '');\n  },\n  forEach: function forEach(path, cb, thisArg) {\n    _forEach(Array.isArray(path) ? path : split(path), cb, thisArg);\n  }\n};\nfunction normalizePath(path) {\n  return pathCache.get(path) || pathCache.set(path, split(path).map(function (part) {\n    return part.replace(CLEAN_QUOTES_REGEX, '$2');\n  }));\n}\nfunction split(path) {\n  return path.match(SPLIT_REGEX) || [''];\n}\nfunction _forEach(parts, iter, thisArg) {\n  var len = parts.length,\n    part,\n    idx,\n    isArray,\n    isBracket;\n  for (idx = 0; idx < len; idx++) {\n    part = parts[idx];\n    if (part) {\n      if (shouldBeQuoted(part)) {\n        part = '\"' + part + '\"';\n      }\n      isBracket = isQuoted(part);\n      isArray = !isBracket && /^\\d+$/.test(part);\n      iter.call(thisArg, part, isBracket, isArray, idx, parts);\n    }\n  }\n}\nfunction isQuoted(str) {\n  return typeof str === 'string' && str && [\"'\", '\"'].indexOf(str.charAt(0)) !== -1;\n}\nfunction hasLeadingNumber(part) {\n  return part.match(LEAD_DIGIT_REGEX) && !part.match(DIGIT_REGEX);\n}\nfunction hasSpecialChars(part) {\n  return SPEC_CHAR_REGEX.test(part);\n}\nfunction shouldBeQuoted(part) {\n  return !isQuoted(part) && (hasLeadingNumber(part) || hasSpecialChars(part));\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QU8sRUFBRUssR0FBRyxFQUFFdkIsS0FBSyxDQUFDO0lBQzFEO0VBQ0Y7QUFDRjtBQUVBLFNBQVNZLFFBQVFBLENBQUNlLEdBQUcsRUFBRTtFQUNyQixPQUNFLE9BQU9BLEdBQUcsS0FBSyxRQUFRLElBQUlBLEdBQUcsSUFBSSxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FBQ0MsT0FBTyxDQUFDRCxHQUFHLENBQUNFLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQztBQUU5RTtBQUVBLFNBQVNDLGdCQUFnQkEsQ0FBQ3hCLElBQUksRUFBRTtFQUM5QixPQUFPQSxJQUFJLENBQUNlLEtBQUssQ0FBQ25DLGdCQUFnQixDQUFDLElBQUksQ0FBQ29CLElBQUksQ0FBQ2UsS0FBSyxDQUFDcEMsV0FBVyxDQUFDO0FBQ2pFO0FBRUEsU0FBUzhDLGVBQWVBLENBQUN6QixJQUFJLEVBQUU7RUFDN0IsT0FBT25CLGVBQWUsQ0FBQzBCLElBQUksQ0FBQ1AsSUFBSSxDQUFDO0FBQ25DO0FBRUEsU0FBU21CLGNBQWNBLENBQUNuQixJQUFJLEVBQUU7RUFDNUIsT0FBTyxDQUFDTSxRQUFRLENBQUNOLElBQUksQ0FBQyxLQUFLd0IsZ0JBQWdCLENBQUN4QixJQUFJLENBQUMsSUFBSXlCLGVBQWUsQ0FBQ3pCLElBQUksQ0FBQyxDQUFDO0FBQzdFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZm9vZC8uL25vZGVfbW9kdWxlcy9wcm9wZXJ0eS1leHByL2luZGV4LmpzPzY4NWIiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBCYXNlZCBvbiBLZW5kbyBVSSBDb3JlIGV4cHJlc3Npb24gY29kZSA8aHR0cHM6Ly9naXRodWIuY29tL3RlbGVyaWsva2VuZG8tdWktY29yZSNsaWNlbnNlLWluZm9ybWF0aW9uPlxuICovXG4ndXNlIHN0cmljdCdcblxuZnVuY3Rpb24gQ2FjaGUobWF4U2l6ZSkge1xuICB0aGlzLl9tYXhTaXplID0gbWF4U2l6ZVxuICB0aGlzLmNsZWFyKClcbn1cbkNhY2hlLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fc2l6ZSA9IDBcbiAgdGhpcy5fdmFsdWVzID0gT2JqZWN0LmNyZWF0ZShudWxsKVxufVxuQ2FjaGUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX3ZhbHVlc1trZXldXG59XG5DYWNoZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgdGhpcy5fc2l6ZSA+PSB0aGlzLl9tYXhTaXplICYmIHRoaXMuY2xlYXIoKVxuICBpZiAoIShrZXkgaW4gdGhpcy5fdmFsdWVzKSkgdGhpcy5fc2l6ZSsrXG5cbiAgcmV0dXJuICh0aGlzLl92YWx1ZXNba2V5XSA9IHZhbHVlKVxufVxuXG52YXIgU1BMSVRfUkVHRVggPSAvW14uXlxcXV5bXSt8KD89XFxbXFxdfFxcLlxcLikvZyxcbiAgRElHSVRfUkVHRVggPSAvXlxcZCskLyxcbiAgTEVBRF9ESUdJVF9SRUdFWCA9IC9eXFxkLyxcbiAgU1BFQ19DSEFSX1JFR0VYID0gL1t+YCEjJCVcXF4mKis9XFwtXFxbXFxdXFxcXCc7LC97fXxcXFxcXCI6PD5cXD9dL2csXG4gIENMRUFOX1FVT1RFU19SRUdFWCA9IC9eXFxzKihbJ1wiXT8pKC4qPykoXFwxKVxccyokLyxcbiAgTUFYX0NBQ0hFX1NJWkUgPSA1MTJcblxudmFyIHBhdGhDYWNoZSA9IG5ldyBDYWNoZShNQVhfQ0FDSEVfU0laRSksXG4gIHNldENhY2hlID0gbmV3IENhY2hlKE1BWF9DQUNIRV9TSVpFKSxcbiAgZ2V0Q2FjaGUgPSBuZXcgQ2FjaGUoTUFYX0NBQ0hFX1NJWkUpXG5cbnZhciBjb25maWdcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIENhY2hlOiBDYWNoZSxcblxuICBzcGxpdDogc3BsaXQsXG5cbiAgbm9ybWFsaXplUGF0aDogbm9ybWFsaXplUGF0aCxcblxuICBzZXR0ZXI6IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgdmFyIHBhcnRzID0gbm9ybWFsaXplUGF0aChwYXRoKVxuXG4gICAgcmV0dXJuIChcbiAgICAgIHNldENhY2hlLmdldChwYXRoKSB8fFxuICAgICAgc2V0Q2FjaGUuc2V0KHBhdGgsIGZ1bmN0aW9uIHNldHRlcihvYmosIHZhbHVlKSB7XG4gICAgICAgIHZhciBpbmRleCA9IDBcbiAgICAgICAgdmFyIGxlbiA9IHBhcnRzLmxlbmd0aFxuICAgICAgICB2YXIgZGF0YSA9IG9ialxuXG4gICAgICAgIHdoaWxlIChpbmRleCA8IGxlbiAtIDEpIHtcbiAgICAgICAgICB2YXIgcGFydCA9IHBhcnRzW2luZGV4XVxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHBhcnQgPT09ICdfX3Byb3RvX18nIHx8XG4gICAgICAgICAgICBwYXJ0ID09PSAnY29uc3RydWN0b3InIHx8XG4gICAgICAgICAgICBwYXJ0ID09PSAncHJvdG90eXBlJ1xuICAgICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIG9ialxuICAgICAgICAgIH1cblxuICAgICAgICAgIGRhdGEgPSBkYXRhW3BhcnRzW2luZGV4KytdXVxuICAgICAgICB9XG4gICAgICAgIGRhdGFbcGFydHNbaW5kZXhdXSA9IHZhbHVlXG4gICAgICB9KVxuICAgIClcbiAgfSxcblxuICBnZXR0ZXI6IGZ1bmN0aW9uIChwYXRoLCBzYWZlKSB7XG4gICAgdmFyIHBhcnRzID0gbm9ybWFsaXplUGF0aChwYXRoKVxuICAgIHJldHVybiAoXG4gICAgICBnZXRDYWNoZS5nZXQocGF0aCkgfHxcbiAgICAgIGdldENhY2hlLnNldChwYXRoLCBmdW5jdGlvbiBnZXR0ZXIoZGF0YSkge1xuICAgICAgICB2YXIgaW5kZXggPSAwLFxuICAgICAgICAgIGxlbiA9IHBhcnRzLmxlbmd0aFxuICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW4pIHtcbiAgICAgICAgICBpZiAoZGF0YSAhPSBudWxsIHx8ICFzYWZlKSBkYXRhID0gZGF0YVtwYXJ0c1tpbmRleCsrXV1cbiAgICAgICAgICBlbHNlIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhXG4gICAgICB9KVxuICAgIClcbiAgfSxcblxuICBqb2luOiBmdW5jdGlvbiAoc2VnbWVudHMpIHtcbiAgICByZXR1cm4gc2VnbWVudHMucmVkdWNlKGZ1bmN0aW9uIChwYXRoLCBwYXJ0KSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBwYXRoICtcbiAgICAgICAgKGlzUXVvdGVkKHBhcnQpIHx8IERJR0lUX1JFR0VYLnRlc3QocGFydClcbiAgICAgICAgICA/ICdbJyArIHBhcnQgKyAnXSdcbiAgICAgICAgICA6IChwYXRoID8gJy4nIDogJycpICsgcGFydClcbiAgICAgIClcbiAgICB9LCAnJylcbiAgfSxcblxuICBmb3JFYWNoOiBmdW5jdGlvbiAocGF0aCwgY2IsIHRoaXNBcmcpIHtcbiAgICBmb3JFYWNoKEFycmF5LmlzQXJyYXkocGF0aCkgPyBwYXRoIDogc3BsaXQocGF0aCksIGNiLCB0aGlzQXJnKVxuICB9LFxufVxuXG5mdW5jdGlvbiBub3JtYWxpemVQYXRoKHBhdGgpIHtcbiAgcmV0dXJuIChcbiAgICBwYXRoQ2FjaGUuZ2V0KHBhdGgpIHx8XG4gICAgcGF0aENhY2hlLnNldChcbiAgICAgIHBhdGgsXG4gICAgICBzcGxpdChwYXRoKS5tYXAoZnVuY3Rpb24gKHBhcnQpIHtcbiAgICAgICAgcmV0dXJuIHBhcnQucmVwbGFjZShDTEVBTl9RVU9URVNfUkVHRVgsICckMicpXG4gICAgICB9KVxuICAgIClcbiAgKVxufVxuXG5mdW5jdGlvbiBzcGxpdChwYXRoKSB7XG4gIHJldHVybiBwYXRoLm1hdGNoKFNQTElUX1JFR0VYKSB8fCBbJyddXG59XG5cbmZ1bmN0aW9uIGZvckVhY2gocGFydHMsIGl0ZXIsIHRoaXNBcmcpIHtcbiAgdmFyIGxlbiA9IHBhcnRzLmxlbmd0aCxcbiAgICBwYXJ0LFxuICAgIGlkeCxcbiAgICBpc0FycmF5LFxuICAgIGlzQnJhY2tldFxuXG4gIGZvciAoaWR4ID0gMDsgaWR4IDwgbGVuOyBpZHgrKykge1xuICAgIHBhcnQgPSBwYXJ0c1tpZHhdXG5cbiAgICBpZiAocGFydCkge1xuICAgICAgaWYgKHNob3VsZEJlUXVvdGVkKHBhcnQpKSB7XG4gICAgICAgIHBhcnQgPSAnXCInICsgcGFydCArICdcIidcbiAgICAgIH1cblxuICAgICAgaXNCcmFja2V0ID0gaXNRdW90ZWQocGFydClcbiAgICAgIGlzQXJyYXkgPSAhaXNCcmFja2V0ICYmIC9eXFxkKyQvLnRlc3QocGFydClcblxuICAgICAgaXRlci5jYWxsKHRoaXNBcmcsIHBhcnQsIGlzQnJhY2tldCwgaXNBcnJheSwgaWR4LCBwYXJ0cylcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNRdW90ZWQoc3RyKSB7XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIHN0ciA9PT0gJ3N0cmluZycgJiYgc3RyICYmIFtcIidcIiwgJ1wiJ10uaW5kZXhPZihzdHIuY2hhckF0KDApKSAhPT0gLTFcbiAgKVxufVxuXG5mdW5jdGlvbiBoYXNMZWFkaW5nTnVtYmVyKHBhcnQpIHtcbiAgcmV0dXJuIHBhcnQubWF0Y2goTEVBRF9ESUdJVF9SRUdFWCkgJiYgIXBhcnQubWF0Y2goRElHSVRfUkVHRVgpXG59XG5cbmZ1bmN0aW9uIGhhc1NwZWNpYWxDaGFycyhwYXJ0KSB7XG4gIHJldHVybiBTUEVDX0NIQVJfUkVHRVgudGVzdChwYXJ0KVxufVxuXG5mdW5jdGlvbiBzaG91bGRCZVF1b3RlZChwYXJ0KSB7XG4gIHJldHVybiAhaXNRdW90ZWQocGFydCkgJiYgKGhhc0xlYWRpbmdOdW1iZXIocGFydCkgfHwgaGFzU3BlY2lhbENoYXJzKHBhcnQpKVxufVxuIl0sIm5hbWVzIjpbIkNhY2hlIiwibWF4U2l6ZSIsIl9tYXhTaXplIiwiY2xlYXIiLCJwcm90b3R5cGUiLCJfc2l6ZSIsIl92YWx1ZXMiLCJPYmplY3QiLCJjcmVhdGUiLCJnZXQiLCJrZXkiLCJzZXQiLCJ2YWx1ZSIsIlNQTElUX1JFR0VYIiwiRElHSVRfUkVHRVgiLCJMRUFEX0RJR0lUX1JFR0VYIiwiU1BFQ19DSEFSX1JFR0VYIiwiQ0xFQU5fUVVPVEVTX1JFR0VYIiwiTUFYX0NBQ0hFX1NJWkUiLCJwYXRoQ2FjaGUiLCJzZXRDYWNoZSIsImdldENhY2hlIiwiY29uZmlnIiwibW9kdWxlIiwiZXhwb3J0cyIsInNwbGl0Iiwibm9ybWFsaXplUGF0aCIsInNldHRlciIsInBhdGgiLCJwYXJ0cyIsIm9iaiIsImluZGV4IiwibGVuIiwibGVuZ3RoIiwiZGF0YSIsInBhcnQiLCJnZXR0ZXIiLCJzYWZlIiwiam9pbiIsInNlZ21lbnRzIiwicmVkdWNlIiwiaXNRdW90ZWQiLCJ0ZXN0IiwiZm9yRWFjaCIsImNiIiwidGhpc0FyZyIsIkFycmF5IiwiaXNBcnJheSIsIm1hcCIsInJlcGxhY2UiLCJtYXRjaCIsIml0ZXIiLCJpZHgiLCJpc0JyYWNrZXQiLCJzaG91bGRCZVF1b3RlZCIsImNhbGwiLCJzdHIiLCJpbmRleE9mIiwiY2hhckF0IiwiaGFzTGVhZGluZ051bWJlciIsImhhc1NwZWNpYWxDaGFycyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///931\n")},3049:module=>{eval("var reWords = /[A-Z\\xc0-\\xd6\\xd8-\\xde]?[a-z\\xdf-\\xf6\\xf8-\\xff]+(?:['’](?:d|ll|m|re|s|t|ve))?(?=[\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000]|[A-Z\\xc0-\\xd6\\xd8-\\xde]|$)|(?:[A-Z\\xc0-\\xd6\\xd8-\\xde]|[^\\ud800-\\udfff\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\d+\\u2700-\\u27bfa-z\\xdf-\\xf6\\xf8-\\xffA-Z\\xc0-\\xd6\\xd8-\\xde])+(?:['’](?:D|LL|M|RE|S|T|VE))?(?=[\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000]|[A-Z\\xc0-\\xd6\\xd8-\\xde](?:[a-z\\xdf-\\xf6\\xf8-\\xff]|[^\\ud800-\\udfff\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\d+\\u2700-\\u27bfa-z\\xdf-\\xf6\\xf8-\\xffA-Z\\xc0-\\xd6\\xd8-\\xde])|$)|[A-Z\\xc0-\\xd6\\xd8-\\xde]?(?:[a-z\\xdf-\\xf6\\xf8-\\xff]|[^\\ud800-\\udfff\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\d+\\u2700-\\u27bfa-z\\xdf-\\xf6\\xf8-\\xffA-Z\\xc0-\\xd6\\xd8-\\xde])+(?:['’](?:d|ll|m|re|s|t|ve))?|[A-Z\\xc0-\\xd6\\xd8-\\xde]+(?:['’](?:D|LL|M|RE|S|T|VE))?|\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])|\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])|\\d+|(?:[\\u2700-\\u27bf]|(?:\\ud83c[\\udde6-\\uddff]){2}|[\\ud800-\\udbff][\\udc00-\\udfff])[\\ufe0e\\ufe0f]?(?:[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]|\\ud83c[\\udffb-\\udfff])?(?:\\u200d(?:[^\\ud800-\\udfff]|(?:\\ud83c[\\udde6-\\uddff]){2}|[\\ud800-\\udbff][\\udc00-\\udfff])[\\ufe0e\\ufe0f]?(?:[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]|\\ud83c[\\udffb-\\udfff])?)*/g;\nvar words = function words(str) {\n  return str.match(reWords) || [];\n};\nvar upperFirst = function upperFirst(str) {\n  return str[0].toUpperCase() + str.slice(1);\n};\nvar join = function join(str, d) {\n  return words(str).join(d).toLowerCase();\n};\nvar camelCase = function camelCase(str) {\n  return words(str).reduce(function (acc, next) {\n    return \"\".concat(acc).concat(!acc ? next.toLowerCase() : next[0].toUpperCase() + next.slice(1).toLowerCase());\n  }, '');\n};\nvar pascalCase = function pascalCase(str) {\n  return upperFirst(camelCase(str));\n};\nvar snakeCase = function snakeCase(str) {\n  return join(str, '_');\n};\nvar kebabCase = function kebabCase(str) {\n  return join(str, '-');\n};\nvar sentenceCase = function sentenceCase(str) {\n  return upperFirst(join(str, ' '));\n};\nvar titleCase = function titleCase(str) {\n  return words(str).map(upperFirst).join(' ');\n};\nmodule.exports = {\n  words: words,\n  upperFirst: upperFirst,\n  camelCase: camelCase,\n  pascalCase: pascalCase,\n  snakeCase: snakeCase,\n  kebabCase: kebabCase,\n  sentenceCase: sentenceCase,\n  titleCase: titleCase\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMzA0OS5qcyIsIm5hbWVzIjpbInJlV29yZHMiLCJ3b3JkcyIsInN0ciIsIm1hdGNoIiwidXBwZXJGaXJzdCIsInRvVXBwZXJDYXNlIiwic2xpY2UiLCJqb2luIiwiZCIsInRvTG93ZXJDYXNlIiwiY2FtZWxDYXNlIiwicmVkdWNlIiwiYWNjIiwibmV4dCIsImNvbmNhdCIsInBhc2NhbENhc2UiLCJzbmFrZUNhc2UiLCJrZWJhYkNhc2UiLCJzZW50ZW5jZUNhc2UiLCJ0aXRsZUNhc2UiLCJtYXAiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mb29kLy4vbm9kZV9tb2R1bGVzL3RpbnktY2FzZS9pbmRleC5qcz85NDZjIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHJlV29yZHMgPSAvW0EtWlxceGMwLVxceGQ2XFx4ZDgtXFx4ZGVdP1thLXpcXHhkZi1cXHhmNlxceGY4LVxceGZmXSsoPzpbJ+KAmV0oPzpkfGxsfG18cmV8c3x0fHZlKSk/KD89W1xceGFjXFx4YjFcXHhkN1xceGY3XFx4MDAtXFx4MmZcXHgzYS1cXHg0MFxceDViLVxceDYwXFx4N2ItXFx4YmZcXHUyMDAwLVxcdTIwNmYgXFx0XFx4MGJcXGZcXHhhMFxcdWZlZmZcXG5cXHJcXHUyMDI4XFx1MjAyOVxcdTE2ODBcXHUxODBlXFx1MjAwMFxcdTIwMDFcXHUyMDAyXFx1MjAwM1xcdTIwMDRcXHUyMDA1XFx1MjAwNlxcdTIwMDdcXHUyMDA4XFx1MjAwOVxcdTIwMGFcXHUyMDJmXFx1MjA1ZlxcdTMwMDBdfFtBLVpcXHhjMC1cXHhkNlxceGQ4LVxceGRlXXwkKXwoPzpbQS1aXFx4YzAtXFx4ZDZcXHhkOC1cXHhkZV18W15cXHVkODAwLVxcdWRmZmZcXHhhY1xceGIxXFx4ZDdcXHhmN1xceDAwLVxceDJmXFx4M2EtXFx4NDBcXHg1Yi1cXHg2MFxceDdiLVxceGJmXFx1MjAwMC1cXHUyMDZmIFxcdFxceDBiXFxmXFx4YTBcXHVmZWZmXFxuXFxyXFx1MjAyOFxcdTIwMjlcXHUxNjgwXFx1MTgwZVxcdTIwMDBcXHUyMDAxXFx1MjAwMlxcdTIwMDNcXHUyMDA0XFx1MjAwNVxcdTIwMDZcXHUyMDA3XFx1MjAwOFxcdTIwMDlcXHUyMDBhXFx1MjAyZlxcdTIwNWZcXHUzMDAwXFxkK1xcdTI3MDAtXFx1MjdiZmEtelxceGRmLVxceGY2XFx4ZjgtXFx4ZmZBLVpcXHhjMC1cXHhkNlxceGQ4LVxceGRlXSkrKD86WyfigJldKD86RHxMTHxNfFJFfFN8VHxWRSkpPyg/PVtcXHhhY1xceGIxXFx4ZDdcXHhmN1xceDAwLVxceDJmXFx4M2EtXFx4NDBcXHg1Yi1cXHg2MFxceDdiLVxceGJmXFx1MjAwMC1cXHUyMDZmIFxcdFxceDBiXFxmXFx4YTBcXHVmZWZmXFxuXFxyXFx1MjAyOFxcdTIwMjlcXHUxNjgwXFx1MTgwZVxcdTIwMDBcXHUyMDAxXFx1MjAwMlxcdTIwMDNcXHUyMDA0XFx1MjAwNVxcdTIwMDZcXHUyMDA3XFx1MjAwOFxcdTIwMDlcXHUyMDBhXFx1MjAyZlxcdTIwNWZcXHUzMDAwXXxbQS1aXFx4YzAtXFx4ZDZcXHhkOC1cXHhkZV0oPzpbYS16XFx4ZGYtXFx4ZjZcXHhmOC1cXHhmZl18W15cXHVkODAwLVxcdWRmZmZcXHhhY1xceGIxXFx4ZDdcXHhmN1xceDAwLVxceDJmXFx4M2EtXFx4NDBcXHg1Yi1cXHg2MFxceDdiLVxceGJmXFx1MjAwMC1cXHUyMDZmIFxcdFxceDBiXFxmXFx4YTBcXHVmZWZmXFxuXFxyXFx1MjAyOFxcdTIwMjlcXHUxNjgwXFx1MTgwZVxcdTIwMDBcXHUyMDAxXFx1MjAwMlxcdTIwMDNcXHUyMDA0XFx1MjAwNVxcdTIwMDZcXHUyMDA3XFx1MjAwOFxcdTIwMDlcXHUyMDBhXFx1MjAyZlxcdTIwNWZcXHUzMDAwXFxkK1xcdTI3MDAtXFx1MjdiZmEtelxceGRmLVxceGY2XFx4ZjgtXFx4ZmZBLVpcXHhjMC1cXHhkNlxceGQ4LVxceGRlXSl8JCl8W0EtWlxceGMwLVxceGQ2XFx4ZDgtXFx4ZGVdPyg/OlthLXpcXHhkZi1cXHhmNlxceGY4LVxceGZmXXxbXlxcdWQ4MDAtXFx1ZGZmZlxceGFjXFx4YjFcXHhkN1xceGY3XFx4MDAtXFx4MmZcXHgzYS1cXHg0MFxceDViLVxceDYwXFx4N2ItXFx4YmZcXHUyMDAwLVxcdTIwNmYgXFx0XFx4MGJcXGZcXHhhMFxcdWZlZmZcXG5cXHJcXHUyMDI4XFx1MjAyOVxcdTE2ODBcXHUxODBlXFx1MjAwMFxcdTIwMDFcXHUyMDAyXFx1MjAwM1xcdTIwMDRcXHUyMDA1XFx1MjAwNlxcdTIwMDdcXHUyMDA4XFx1MjAwOVxcdTIwMGFcXHUyMDJmXFx1MjA1ZlxcdTMwMDBcXGQrXFx1MjcwMC1cXHUyN2JmYS16XFx4ZGYtXFx4ZjZcXHhmOC1cXHhmZkEtWlxceGMwLVxceGQ2XFx4ZDgtXFx4ZGVdKSsoPzpbJ+KAmV0oPzpkfGxsfG18cmV8c3x0fHZlKSk/fFtBLVpcXHhjMC1cXHhkNlxceGQ4LVxceGRlXSsoPzpbJ+KAmV0oPzpEfExMfE18UkV8U3xUfFZFKSk/fFxcZCooPzoxU1R8Mk5EfDNSRHwoPyFbMTIzXSlcXGRUSCkoPz1cXGJ8W2Etel9dKXxcXGQqKD86MXN0fDJuZHwzcmR8KD8hWzEyM10pXFxkdGgpKD89XFxifFtBLVpfXSl8XFxkK3woPzpbXFx1MjcwMC1cXHUyN2JmXXwoPzpcXHVkODNjW1xcdWRkZTYtXFx1ZGRmZl0pezJ9fFtcXHVkODAwLVxcdWRiZmZdW1xcdWRjMDAtXFx1ZGZmZl0pW1xcdWZlMGVcXHVmZTBmXT8oPzpbXFx1MDMwMC1cXHUwMzZmXFx1ZmUyMC1cXHVmZTJmXFx1MjBkMC1cXHUyMGZmXXxcXHVkODNjW1xcdWRmZmItXFx1ZGZmZl0pPyg/OlxcdTIwMGQoPzpbXlxcdWQ4MDAtXFx1ZGZmZl18KD86XFx1ZDgzY1tcXHVkZGU2LVxcdWRkZmZdKXsyfXxbXFx1ZDgwMC1cXHVkYmZmXVtcXHVkYzAwLVxcdWRmZmZdKVtcXHVmZTBlXFx1ZmUwZl0/KD86W1xcdTAzMDAtXFx1MDM2ZlxcdWZlMjAtXFx1ZmUyZlxcdTIwZDAtXFx1MjBmZl18XFx1ZDgzY1tcXHVkZmZiLVxcdWRmZmZdKT8pKi9nXG5cbmNvbnN0IHdvcmRzID0gKHN0cikgPT4gc3RyLm1hdGNoKHJlV29yZHMpIHx8IFtdXG5cbmNvbnN0IHVwcGVyRmlyc3QgPSAoc3RyKSA9PiBzdHJbMF0udG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKVxuXG5jb25zdCBqb2luID0gKHN0ciwgZCkgPT4gd29yZHMoc3RyKS5qb2luKGQpLnRvTG93ZXJDYXNlKClcblxuY29uc3QgY2FtZWxDYXNlID0gKHN0cikgPT5cbiAgd29yZHMoc3RyKS5yZWR1Y2UoXG4gICAgKGFjYywgbmV4dCkgPT5cbiAgICAgIGAke2FjY30ke1xuICAgICAgICAhYWNjXG4gICAgICAgICAgPyBuZXh0LnRvTG93ZXJDYXNlKClcbiAgICAgICAgICA6IG5leHRbMF0udG9VcHBlckNhc2UoKSArIG5leHQuc2xpY2UoMSkudG9Mb3dlckNhc2UoKVxuICAgICAgfWAsXG4gICAgJycsXG4gIClcblxuY29uc3QgcGFzY2FsQ2FzZSA9IChzdHIpID0+IHVwcGVyRmlyc3QoY2FtZWxDYXNlKHN0cikpXG5cbmNvbnN0IHNuYWtlQ2FzZSA9IChzdHIpID0+IGpvaW4oc3RyLCAnXycpXG5cbmNvbnN0IGtlYmFiQ2FzZSA9IChzdHIpID0+IGpvaW4oc3RyLCAnLScpXG5cbmNvbnN0IHNlbnRlbmNlQ2FzZSA9IChzdHIpID0+IHVwcGVyRmlyc3Qoam9pbihzdHIsICcgJykpXG5cbmNvbnN0IHRpdGxlQ2FzZSA9IChzdHIpID0+IHdvcmRzKHN0cikubWFwKHVwcGVyRmlyc3QpLmpvaW4oJyAnKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgd29yZHMsXG4gIHVwcGVyRmlyc3QsXG4gIGNhbWVsQ2FzZSxcbiAgcGFzY2FsQ2FzZSxcbiAgc25ha2VDYXNlLFxuICBrZWJhYkNhc2UsXG4gIHNlbnRlbmNlQ2FzZSxcbiAgdGl0bGVDYXNlLFxufVxuIl0sIm1hcHBpbmdzIjoiQUFBQSxJQUFNQSxPQUFPLEdBQUcsbTlEQUFtOUQ7QUFFbitELElBQU1DLEtBQUssR0FBRyxTQUFSQSxLQUFLQSxDQUFJQyxHQUFHO0VBQUEsT0FBS0EsR0FBRyxDQUFDQyxLQUFLLENBQUNILE9BQU8sQ0FBQyxJQUFJLEVBQUU7QUFBQTtBQUUvQyxJQUFNSSxVQUFVLEdBQUcsU0FBYkEsVUFBVUEsQ0FBSUYsR0FBRztFQUFBLE9BQUtBLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQ0csV0FBVyxDQUFDLENBQUMsR0FBR0gsR0FBRyxDQUFDSSxLQUFLLENBQUMsQ0FBQyxDQUFDO0FBQUE7QUFFL0QsSUFBTUMsSUFBSSxHQUFHLFNBQVBBLElBQUlBLENBQUlMLEdBQUcsRUFBRU0sQ0FBQztFQUFBLE9BQUtQLEtBQUssQ0FBQ0MsR0FBRyxDQUFDLENBQUNLLElBQUksQ0FBQ0MsQ0FBQyxDQUFDLENBQUNDLFdBQVcsQ0FBQyxDQUFDO0FBQUE7QUFFekQsSUFBTUMsU0FBUyxHQUFHLFNBQVpBLFNBQVNBLENBQUlSLEdBQUc7RUFBQSxPQUNwQkQsS0FBSyxDQUFDQyxHQUFHLENBQUMsQ0FBQ1MsTUFBTSxDQUNmLFVBQUNDLEdBQUcsRUFBRUMsSUFBSTtJQUFBLFVBQUFDLE1BQUEsQ0FDTEYsR0FBRyxFQUFBRSxNQUFBLENBQ0osQ0FBQ0YsR0FBRyxHQUNBQyxJQUFJLENBQUNKLFdBQVcsQ0FBQyxDQUFDLEdBQ2xCSSxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUNSLFdBQVcsQ0FBQyxDQUFDLEdBQUdRLElBQUksQ0FBQ1AsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDRyxXQUFXLENBQUMsQ0FBQztFQUFBLENBQ3ZELEVBQ0osRUFDRixDQUFDO0FBQUE7QUFFSCxJQUFNTSxVQUFVLEdBQUcsU0FBYkEsVUFBVUEsQ0FBSWIsR0FBRztFQUFBLE9BQUtFLFVBQVUsQ0FBQ00sU0FBUyxDQUFDUixHQUFHLENBQUMsQ0FBQztBQUFBO0FBRXRELElBQU1jLFNBQVMsR0FBRyxTQUFaQSxTQUFTQSxDQUFJZCxHQUFHO0VBQUEsT0FBS0ssSUFBSSxDQUFDTCxHQUFHLEVBQUUsR0FBRyxDQUFDO0FBQUE7QUFFekMsSUFBTWUsU0FBUyxHQUFHLFNBQVpBLFNBQVNBLENBQUlmLEdBQUc7RUFBQSxPQUFLSyxJQUFJLENBQUNMLEdBQUcsRUFBRSxHQUFHLENBQUM7QUFBQTtBQUV6QyxJQUFNZ0IsWUFBWSxHQUFHLFNBQWZBLFlBQVlBLENBQUloQixHQUFHO0VBQUEsT0FBS0UsVUFBVSxDQUFDRyxJQUFJLENBQUNMLEdBQUcsRUFBRSxHQUFHLENBQUMsQ0FBQztBQUFBO0FBRXhELElBQU1pQixTQUFTLEdBQUcsU0FBWkEsU0FBU0EsQ0FBSWpCLEdBQUc7RUFBQSxPQUFLRCxLQUFLLENBQUNDLEdBQUcsQ0FBQyxDQUFDa0IsR0FBRyxDQUFDaEIsVUFBVSxDQUFDLENBQUNHLElBQUksQ0FBQyxHQUFHLENBQUM7QUFBQTtBQUUvRGMsTUFBTSxDQUFDQyxPQUFPLEdBQUc7RUFDZnJCLEtBQUssRUFBTEEsS0FBSztFQUNMRyxVQUFVLEVBQVZBLFVBQVU7RUFDVk0sU0FBUyxFQUFUQSxTQUFTO0VBQ1RLLFVBQVUsRUFBVkEsVUFBVTtFQUNWQyxTQUFTLEVBQVRBLFNBQVM7RUFDVEMsU0FBUyxFQUFUQSxTQUFTO0VBQ1RDLFlBQVksRUFBWkEsWUFBWTtFQUNaQyxTQUFTLEVBQVRBO0FBQ0YsQ0FBQyIsImlnbm9yZUxpc3QiOltdfQ==\n//# sourceURL=webpack-internal:///3049\n")},5388:module=>{eval("/**\n * Topological sorting function\n *\n * @param {Array} edges\n * @returns {Array}\n */\n\nmodule.exports = function (edges) {\n  return toposort(uniqueNodes(edges), edges);\n};\nmodule.exports.array = toposort;\nfunction toposort(nodes, edges) {\n  var cursor = nodes.length,\n    sorted = new Array(cursor),\n    visited = {},\n    i = cursor\n    // Better data structures make algorithm much faster.\n    ,\n    outgoingEdges = makeOutgoingEdges(edges),\n    nodesHash = makeNodesHash(nodes);\n\n  // check for unknown nodes\n  edges.forEach(function (edge) {\n    if (!nodesHash.has(edge[0]) || !nodesHash.has(edge[1])) {\n      throw new Error('Unknown node. There is an unknown node in the supplied edges.');\n    }\n  });\n  while (i--) {\n    if (!visited[i]) visit(nodes[i], i, new Set());\n  }\n  return sorted;\n  function visit(node, i, predecessors) {\n    if (predecessors.has(node)) {\n      var nodeRep;\n      try {\n        nodeRep = \", node was:\" + JSON.stringify(node);\n      } catch (e) {\n        nodeRep = \"\";\n      }\n      throw new Error('Cyclic dependency' + nodeRep);\n    }\n    if (!nodesHash.has(node)) {\n      throw new Error('Found unknown node. Make sure to provided all involved nodes. Unknown node: ' + JSON.stringify(node));\n    }\n    if (visited[i]) return;\n    visited[i] = true;\n    var outgoing = outgoingEdges.get(node) || new Set();\n    outgoing = Array.from(outgoing);\n    if (i = outgoing.length) {\n      predecessors.add(node);\n      do {\n        var child = outgoing[--i];\n        visit(child, nodesHash.get(child), predecessors);\n      } while (i);\n      predecessors.delete(node);\n    }\n    sorted[--cursor] = node;\n  }\n}\nfunction uniqueNodes(arr) {\n  var res = new Set();\n  for (var i = 0, len = arr.length; i < len; i++) {\n    var edge = arr[i];\n    res.add(edge[0]);\n    res.add(edge[1]);\n  }\n  return Array.from(res);\n}\nfunction makeOutgoingEdges(arr) {\n  var edges = new Map();\n  for (var i = 0, len = arr.length; i < len; i++) {\n    var edge = arr[i];\n    if (!edges.has(edge[0])) edges.set(edge[0], new Set());\n    if (!edges.has(edge[1])) edges.set(edge[1], new Set());\n    edges.get(edge[0]).add(edge[1]);\n  }\n  return edges;\n}\nfunction makeNodesHash(arr) {\n  var res = new Map();\n  for (var i = 0, len = arr.length; i < len; i++) {\n    res.set(arr[i], i);\n  }\n  return res;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFaEIsS0FBSyxDQUFDcUMsR0FBRyxDQUFDckIsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLElBQUlJLEdBQUcsQ0FBQyxDQUFDLENBQUM7SUFDdERwQixLQUFLLENBQUM0QixHQUFHLENBQUNaLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDYyxHQUFHLENBQUNkLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztFQUNqQztFQUNBLE9BQU9oQixLQUFLO0FBQ2Q7QUFFQSxTQUFTYyxhQUFhQSxDQUFDbUIsR0FBRyxFQUFDO0VBQ3pCLElBQUlDLEdBQUcsR0FBRyxJQUFJRSxHQUFHLENBQUMsQ0FBQztFQUNuQixLQUFLLElBQUkxQixDQUFDLEdBQUcsQ0FBQyxFQUFFeUIsR0FBRyxHQUFHRixHQUFHLENBQUMzQixNQUFNLEVBQUVJLENBQUMsR0FBR3lCLEdBQUcsRUFBRXpCLENBQUMsRUFBRSxFQUFFO0lBQzlDd0IsR0FBRyxDQUFDRyxHQUFHLENBQUNKLEdBQUcsQ0FBQ3ZCLENBQUMsQ0FBQyxFQUFFQSxDQUFDLENBQUM7RUFDcEI7RUFDQSxPQUFPd0IsR0FBRztBQUNaIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZm9vZC8uL25vZGVfbW9kdWxlcy90b3Bvc29ydC9pbmRleC5qcz9hZjljIl0sInNvdXJjZXNDb250ZW50IjpbIlxuLyoqXG4gKiBUb3BvbG9naWNhbCBzb3J0aW5nIGZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIHtBcnJheX0gZWRnZXNcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGVkZ2VzKSB7XG4gIHJldHVybiB0b3Bvc29ydCh1bmlxdWVOb2RlcyhlZGdlcyksIGVkZ2VzKVxufVxuXG5tb2R1bGUuZXhwb3J0cy5hcnJheSA9IHRvcG9zb3J0XG5cbmZ1bmN0aW9uIHRvcG9zb3J0KG5vZGVzLCBlZGdlcykge1xuICB2YXIgY3Vyc29yID0gbm9kZXMubGVuZ3RoXG4gICAgLCBzb3J0ZWQgPSBuZXcgQXJyYXkoY3Vyc29yKVxuICAgICwgdmlzaXRlZCA9IHt9XG4gICAgLCBpID0gY3Vyc29yXG4gICAgLy8gQmV0dGVyIGRhdGEgc3RydWN0dXJlcyBtYWtlIGFsZ29yaXRobSBtdWNoIGZhc3Rlci5cbiAgICAsIG91dGdvaW5nRWRnZXMgPSBtYWtlT3V0Z29pbmdFZGdlcyhlZGdlcylcbiAgICAsIG5vZGVzSGFzaCA9IG1ha2VOb2Rlc0hhc2gobm9kZXMpXG5cbiAgLy8gY2hlY2sgZm9yIHVua25vd24gbm9kZXNcbiAgZWRnZXMuZm9yRWFjaChmdW5jdGlvbihlZGdlKSB7XG4gICAgaWYgKCFub2Rlc0hhc2guaGFzKGVkZ2VbMF0pIHx8ICFub2Rlc0hhc2guaGFzKGVkZ2VbMV0pKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gbm9kZS4gVGhlcmUgaXMgYW4gdW5rbm93biBub2RlIGluIHRoZSBzdXBwbGllZCBlZGdlcy4nKVxuICAgIH1cbiAgfSlcblxuICB3aGlsZSAoaS0tKSB7XG4gICAgaWYgKCF2aXNpdGVkW2ldKSB2aXNpdChub2Rlc1tpXSwgaSwgbmV3IFNldCgpKVxuICB9XG5cbiAgcmV0dXJuIHNvcnRlZFxuXG4gIGZ1bmN0aW9uIHZpc2l0KG5vZGUsIGksIHByZWRlY2Vzc29ycykge1xuICAgIGlmKHByZWRlY2Vzc29ycy5oYXMobm9kZSkpIHtcbiAgICAgIHZhciBub2RlUmVwXG4gICAgICB0cnkge1xuICAgICAgICBub2RlUmVwID0gXCIsIG5vZGUgd2FzOlwiICsgSlNPTi5zdHJpbmdpZnkobm9kZSlcbiAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICBub2RlUmVwID0gXCJcIlxuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDeWNsaWMgZGVwZW5kZW5jeScgKyBub2RlUmVwKVxuICAgIH1cblxuICAgIGlmICghbm9kZXNIYXNoLmhhcyhub2RlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGb3VuZCB1bmtub3duIG5vZGUuIE1ha2Ugc3VyZSB0byBwcm92aWRlZCBhbGwgaW52b2x2ZWQgbm9kZXMuIFVua25vd24gbm9kZTogJytKU09OLnN0cmluZ2lmeShub2RlKSlcbiAgICB9XG5cbiAgICBpZiAodmlzaXRlZFtpXSkgcmV0dXJuO1xuICAgIHZpc2l0ZWRbaV0gPSB0cnVlXG5cbiAgICB2YXIgb3V0Z29pbmcgPSBvdXRnb2luZ0VkZ2VzLmdldChub2RlKSB8fCBuZXcgU2V0KClcbiAgICBvdXRnb2luZyA9IEFycmF5LmZyb20ob3V0Z29pbmcpXG5cbiAgICBpZiAoaSA9IG91dGdvaW5nLmxlbmd0aCkge1xuICAgICAgcHJlZGVjZXNzb3JzLmFkZChub2RlKVxuICAgICAgZG8ge1xuICAgICAgICB2YXIgY2hpbGQgPSBvdXRnb2luZ1stLWldXG4gICAgICAgIHZpc2l0KGNoaWxkLCBub2Rlc0hhc2guZ2V0KGNoaWxkKSwgcHJlZGVjZXNzb3JzKVxuICAgICAgfSB3aGlsZSAoaSlcbiAgICAgIHByZWRlY2Vzc29ycy5kZWxldGUobm9kZSlcbiAgICB9XG5cbiAgICBzb3J0ZWRbLS1jdXJzb3JdID0gbm9kZVxuICB9XG59XG5cbmZ1bmN0aW9uIHVuaXF1ZU5vZGVzKGFycil7XG4gIHZhciByZXMgPSBuZXcgU2V0KClcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGFyci5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBlZGdlID0gYXJyW2ldXG4gICAgcmVzLmFkZChlZGdlWzBdKVxuICAgIHJlcy5hZGQoZWRnZVsxXSlcbiAgfVxuICByZXR1cm4gQXJyYXkuZnJvbShyZXMpXG59XG5cbmZ1bmN0aW9uIG1ha2VPdXRnb2luZ0VkZ2VzKGFycil7XG4gIHZhciBlZGdlcyA9IG5ldyBNYXAoKVxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXJyLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIGVkZ2UgPSBhcnJbaV1cbiAgICBpZiAoIWVkZ2VzLmhhcyhlZGdlWzBdKSkgZWRnZXMuc2V0KGVkZ2VbMF0sIG5ldyBTZXQoKSlcbiAgICBpZiAoIWVkZ2VzLmhhcyhlZGdlWzFdKSkgZWRnZXMuc2V0KGVkZ2VbMV0sIG5ldyBTZXQoKSlcbiAgICBlZGdlcy5nZXQoZWRnZVswXSkuYWRkKGVkZ2VbMV0pXG4gIH1cbiAgcmV0dXJuIGVkZ2VzXG59XG5cbmZ1bmN0aW9uIG1ha2VOb2Rlc0hhc2goYXJyKXtcbiAgdmFyIHJlcyA9IG5ldyBNYXAoKVxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXJyLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgcmVzLnNldChhcnJbaV0sIGkpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJlZGdlcyIsInRvcG9zb3J0IiwidW5pcXVlTm9kZXMiLCJhcnJheSIsIm5vZGVzIiwiY3Vyc29yIiwibGVuZ3RoIiwic29ydGVkIiwiQXJyYXkiLCJ2aXNpdGVkIiwiaSIsIm91dGdvaW5nRWRnZXMiLCJtYWtlT3V0Z29pbmdFZGdlcyIsIm5vZGVzSGFzaCIsIm1ha2VOb2Rlc0hhc2giLCJmb3JFYWNoIiwiZWRnZSIsImhhcyIsIkVycm9yIiwidmlzaXQiLCJTZXQiLCJub2RlIiwicHJlZGVjZXNzb3JzIiwibm9kZVJlcCIsIkpTT04iLCJzdHJpbmdpZnkiLCJlIiwib3V0Z29pbmciLCJnZXQiLCJmcm9tIiwiYWRkIiwiY2hpbGQiLCJkZWxldGUiLCJhcnIiLCJyZXMiLCJsZW4iLCJNYXAiLCJzZXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///5388\n")},3135:(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval('/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Ik: () => (/* binding */ create$3),\n/* harmony export */   Yj: () => (/* binding */ create$6)\n/* harmony export */ });\n/* unused harmony exports ArraySchema, BooleanSchema, DateSchema, MixedSchema, NumberSchema, ObjectSchema, Schema, StringSchema, TupleSchema, ValidationError, addMethod, array, bool, boolean, date, defaultLocale, getIn, isSchema, lazy, mixed, number, printValue, reach, ref, setLocale, tuple */\n/* harmony import */ var property_expr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(931);\n/* harmony import */ var property_expr__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(property_expr__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var tiny_case__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(3049);\n/* harmony import */ var tiny_case__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(tiny_case__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var toposort__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5388);\n/* harmony import */ var toposort__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(toposort__WEBPACK_IMPORTED_MODULE_2__);\nfunction _readOnlyError(r) { throw new TypeError(\'"\' + r + \'" is read-only\'); }\nfunction _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }\nfunction _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }\nfunction _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }\nfunction _arrayWithHoles(r) { if (Array.isArray(r)) return r; }\nfunction _createForOfIteratorHelper(r, e) { var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t.return || t.return(); } finally { if (u) throw o; } } }; }\nfunction _callSuper(t, o, e) { return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e)); }\nfunction _possibleConstructorReturn(t, e) { if (e && ("object" == _typeof(e) || "function" == typeof e)) return e; if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined"); return _assertThisInitialized(t); }\nfunction _assertThisInitialized(e) { if (void 0 === e) throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); return e; }\nfunction _superPropGet(t, o, e, r) { var p = _get(_getPrototypeOf(1 & r ? t.prototype : t), o, e); return 2 & r && "function" == typeof p ? function (t) { return p.apply(e, t); } : p; }\nfunction _get() { return _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) { var p = _superPropBase(e, t); if (p) { var n = Object.getOwnPropertyDescriptor(p, t); return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value; } }, _get.apply(null, arguments); }\nfunction _superPropBase(t, o) { for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _getPrototypeOf(t));); return t; }\nfunction _inherits(t, e) { if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function"); t.prototype = Object.create(e && e.prototype, { constructor: { value: t, writable: !0, configurable: !0 } }), Object.defineProperty(t, "prototype", { writable: !1 }), e && _setPrototypeOf(t, e); }\nfunction _wrapNativeSuper(t) { var r = "function" == typeof Map ? new Map() : void 0; return _wrapNativeSuper = function _wrapNativeSuper(t) { if (null === t || !_isNativeFunction(t)) return t; if ("function" != typeof t) throw new TypeError("Super expression must either be null or a function"); if (void 0 !== r) { if (r.has(t)) return r.get(t); r.set(t, Wrapper); } function Wrapper() { return _construct(t, arguments, _getPrototypeOf(this).constructor); } return Wrapper.prototype = Object.create(t.prototype, { constructor: { value: Wrapper, enumerable: !1, writable: !0, configurable: !0 } }), _setPrototypeOf(Wrapper, t); }, _wrapNativeSuper(t); }\nfunction _construct(t, e, r) { if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments); var o = [null]; o.push.apply(o, e); var p = new (t.bind.apply(t, o))(); return r && _setPrototypeOf(p, r.prototype), p; }\nfunction _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }\nfunction _isNativeFunction(t) { try { return -1 !== Function.toString.call(t).indexOf("[native code]"); } catch (n) { return "function" == typeof t; } }\nfunction _setPrototypeOf(t, e) { return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) { return t.__proto__ = e, t; }, _setPrototypeOf(t, e); }\nfunction _getPrototypeOf(t) { return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) { return t.__proto__ || Object.getPrototypeOf(t); }, _getPrototypeOf(t); }\nfunction _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }\nfunction _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }\nfunction _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }\nfunction _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }\n\n\n\nvar toString = Object.prototype.toString;\nvar errorToString = Error.prototype.toString;\nvar regExpToString = RegExp.prototype.toString;\nvar symbolToString = typeof Symbol !== \'undefined\' ? Symbol.prototype.toString : function () {\n  return \'\';\n};\nvar SYMBOL_REGEXP = /^Symbol\\((.*)\\)(.*)$/;\nfunction printNumber(val) {\n  if (val != +val) return \'NaN\';\n  var isNegativeZero = val === 0 && 1 / val < 0;\n  return isNegativeZero ? \'-0\' : \'\' + val;\n}\nfunction printSimpleValue(val) {\n  var quoteStrings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  if (val == null || val === true || val === false) return \'\' + val;\n  var typeOf = _typeof(val);\n  if (typeOf === \'number\') return printNumber(val);\n  if (typeOf === \'string\') return quoteStrings ? "\\"".concat(val, "\\"") : val;\n  if (typeOf === \'function\') return \'[Function \' + (val.name || \'anonymous\') + \']\';\n  if (typeOf === \'symbol\') return symbolToString.call(val).replace(SYMBOL_REGEXP, \'Symbol($1)\');\n  var tag = toString.call(val).slice(8, -1);\n  if (tag === \'Date\') return isNaN(val.getTime()) ? \'\' + val : val.toISOString(val);\n  if (tag === \'Error\' || val instanceof Error) return \'[\' + errorToString.call(val) + \']\';\n  if (tag === \'RegExp\') return regExpToString.call(val);\n  return null;\n}\nfunction printValue(value, quoteStrings) {\n  var result = printSimpleValue(value, quoteStrings);\n  if (result !== null) return result;\n  return JSON.stringify(value, function (key, value) {\n    var result = printSimpleValue(this[key], quoteStrings);\n    if (result !== null) return result;\n    return value;\n  }, 2);\n}\nfunction toArray(value) {\n  return value == null ? [] : [].concat(value);\n}\nvar _Symbol$toStringTag, _Symbol$hasInstance, _Symbol$toStringTag2;\nvar strReg = /\\$\\{\\s*(\\w+)\\s*\\}/g;\n_Symbol$toStringTag = Symbol.toStringTag;\nvar ValidationErrorNoStack = /*#__PURE__*/_createClass(function ValidationErrorNoStack(errorOrErrors, value, field, type) {\n  var _this = this;\n  _classCallCheck(this, ValidationErrorNoStack);\n  this.name = void 0;\n  this.message = void 0;\n  this.value = void 0;\n  this.path = void 0;\n  this.type = void 0;\n  this.params = void 0;\n  this.errors = void 0;\n  this.inner = void 0;\n  this[_Symbol$toStringTag] = \'Error\';\n  this.name = \'ValidationError\';\n  this.value = value;\n  this.path = field;\n  this.type = type;\n  this.errors = [];\n  this.inner = [];\n  toArray(errorOrErrors).forEach(function (err) {\n    if (ValidationError.isError(err)) {\n      var _this$errors, _this$inner;\n      (_this$errors = _this.errors).push.apply(_this$errors, _toConsumableArray(err.errors));\n      var innerErrors = err.inner.length ? err.inner : [err];\n      (_this$inner = _this.inner).push.apply(_this$inner, _toConsumableArray(innerErrors));\n    } else {\n      _this.errors.push(err);\n    }\n  });\n  this.message = this.errors.length > 1 ? "".concat(this.errors.length, " errors occurred") : this.errors[0];\n});\n_Symbol$hasInstance = Symbol.hasInstance;\n_Symbol$toStringTag2 = Symbol.toStringTag;\nvar ValidationError = /*#__PURE__*/function (_Error, _Symbol$hasInstance2) {\n  function ValidationError(errorOrErrors, value, field, type, disableStack) {\n    var _this2;\n    _classCallCheck(this, ValidationError);\n    var errorNoStack = new ValidationErrorNoStack(errorOrErrors, value, field, type);\n    if (disableStack) {\n      return _possibleConstructorReturn(_this2, errorNoStack);\n    }\n    _this2 = _callSuper(this, ValidationError);\n    _this2.value = void 0;\n    _this2.path = void 0;\n    _this2.type = void 0;\n    _this2.params = void 0;\n    _this2.errors = [];\n    _this2.inner = [];\n    _this2[_Symbol$toStringTag2] = \'Error\';\n    _this2.name = errorNoStack.name;\n    _this2.message = errorNoStack.message;\n    _this2.type = errorNoStack.type;\n    _this2.value = errorNoStack.value;\n    _this2.path = errorNoStack.path;\n    _this2.errors = errorNoStack.errors;\n    _this2.inner = errorNoStack.inner;\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(_this2, ValidationError);\n    }\n    return _this2;\n  }\n  _inherits(ValidationError, _Error);\n  return _createClass(ValidationError, null, [{\n    key: "formatError",\n    value: function formatError(message, params) {\n      var path = params.label || params.path || \'this\';\n      if (path !== params.path) params = Object.assign({}, params, {\n        path: path\n      });\n      if (typeof message === \'string\') return message.replace(strReg, function (_, key) {\n        return printValue(params[key]);\n      });\n      if (typeof message === \'function\') return message(params);\n      return message;\n    }\n  }, {\n    key: "isError",\n    value: function isError(err) {\n      return err && err.name === \'ValidationError\';\n    }\n  }, {\n    key: _Symbol$hasInstance2,\n    value: function value(inst) {\n      return ValidationErrorNoStack[Symbol.hasInstance](inst) || _superPropGet(ValidationError, Symbol.hasInstance, this, 2)([inst]);\n    }\n  }]);\n}(/*#__PURE__*/_wrapNativeSuper(Error), _Symbol$hasInstance);\nvar mixed = {\n  default: \'${path} is invalid\',\n  required: \'${path} is a required field\',\n  defined: \'${path} must be defined\',\n  notNull: \'${path} cannot be null\',\n  oneOf: \'${path} must be one of the following values: ${values}\',\n  notOneOf: \'${path} must not be one of the following values: ${values}\',\n  notType: function notType(_ref) {\n    var path = _ref.path,\n      type = _ref.type,\n      value = _ref.value,\n      originalValue = _ref.originalValue;\n    var castMsg = originalValue != null && originalValue !== value ? " (cast from the value `".concat(printValue(originalValue, true), "`).") : \'.\';\n    return type !== \'mixed\' ? "".concat(path, " must be a `").concat(type, "` type, ") + "but the final value was: `".concat(printValue(value, true), "`") + castMsg : "".concat(path, " must match the configured type. ") + "The validated value was: `".concat(printValue(value, true), "`") + castMsg;\n  }\n};\nvar string = {\n  length: \'${path} must be exactly ${length} characters\',\n  min: \'${path} must be at least ${min} characters\',\n  max: \'${path} must be at most ${max} characters\',\n  matches: \'${path} must match the following: "${regex}"\',\n  email: \'${path} must be a valid email\',\n  url: \'${path} must be a valid URL\',\n  uuid: \'${path} must be a valid UUID\',\n  datetime: \'${path} must be a valid ISO date-time\',\n  datetime_precision: \'${path} must be a valid ISO date-time with a sub-second precision of exactly ${precision} digits\',\n  datetime_offset: \'${path} must be a valid ISO date-time with UTC "Z" timezone\',\n  trim: \'${path} must be a trimmed string\',\n  lowercase: \'${path} must be a lowercase string\',\n  uppercase: \'${path} must be a upper case string\'\n};\nvar number = {\n  min: \'${path} must be greater than or equal to ${min}\',\n  max: \'${path} must be less than or equal to ${max}\',\n  lessThan: \'${path} must be less than ${less}\',\n  moreThan: \'${path} must be greater than ${more}\',\n  positive: \'${path} must be a positive number\',\n  negative: \'${path} must be a negative number\',\n  integer: \'${path} must be an integer\'\n};\nvar date = {\n  min: \'${path} field must be later than ${min}\',\n  max: \'${path} field must be at earlier than ${max}\'\n};\nvar boolean = {\n  isValue: \'${path} field must be ${value}\'\n};\nvar object = {\n  noUnknown: \'${path} field has unspecified keys: ${unknown}\'\n};\nvar array = {\n  min: \'${path} field must have at least ${min} items\',\n  max: \'${path} field must have less than or equal to ${max} items\',\n  length: \'${path} must have ${length} items\'\n};\nvar tuple = {\n  notType: function notType(params) {\n    var path = params.path,\n      value = params.value,\n      spec = params.spec;\n    var typeLen = spec.types.length;\n    if (Array.isArray(value)) {\n      if (value.length < typeLen) return "".concat(path, " tuple value has too few items, expected a length of ").concat(typeLen, " but got ").concat(value.length, " for value: `").concat(printValue(value, true), "`");\n      if (value.length > typeLen) return "".concat(path, " tuple value has too many items, expected a length of ").concat(typeLen, " but got ").concat(value.length, " for value: `").concat(printValue(value, true), "`");\n    }\n    return ValidationError.formatError(mixed.notType, params);\n  }\n};\nvar locale = Object.assign(Object.create(null), {\n  mixed: mixed,\n  string: string,\n  number: number,\n  date: date,\n  object: object,\n  array: array,\n  boolean: boolean,\n  tuple: tuple\n});\nvar isSchema = function isSchema(obj) {\n  return obj && obj.__isYupSchema__;\n};\nvar Condition = /*#__PURE__*/function () {\n  function Condition(refs, builder) {\n    _classCallCheck(this, Condition);\n    this.fn = void 0;\n    this.refs = refs;\n    this.refs = refs;\n    this.fn = builder;\n  }\n  return _createClass(Condition, [{\n    key: "resolve",\n    value: function resolve(base, options) {\n      var values = this.refs.map(function (ref) {\n        return (\n          // TODO: ? operator here?\n          ref.getValue(options == null ? void 0 : options.value, options == null ? void 0 : options.parent, options == null ? void 0 : options.context)\n        );\n      });\n      var schema = this.fn(values, base, options);\n      if (schema === undefined ||\n      // @ts-ignore this can be base\n      schema === base) {\n        return base;\n      }\n      if (!isSchema(schema)) throw new TypeError(\'conditions must return a schema object\');\n      return schema.resolve(options);\n    }\n  }], [{\n    key: "fromOptions",\n    value: function fromOptions(refs, config) {\n      if (!config.then && !config.otherwise) throw new TypeError(\'either `then:` or `otherwise:` is required for `when()` conditions\');\n      var is = config.is,\n        then = config.then,\n        otherwise = config.otherwise;\n      var check = typeof is === \'function\' ? is : function () {\n        for (var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++) {\n          values[_key] = arguments[_key];\n        }\n        return values.every(function (value) {\n          return value === is;\n        });\n      };\n      return new Condition(refs, function (values, schema) {\n        var _branch;\n        var branch = check.apply(void 0, _toConsumableArray(values)) ? then : otherwise;\n        return (_branch = branch == null ? void 0 : branch(schema)) != null ? _branch : schema;\n      });\n    }\n  }]);\n}();\nvar prefixes = {\n  context: \'$\',\n  value: \'.\'\n};\nfunction create$9(key, options) {\n  return new Reference(key, options);\n}\nvar Reference = /*#__PURE__*/function () {\n  function Reference(key) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    _classCallCheck(this, Reference);\n    this.key = void 0;\n    this.isContext = void 0;\n    this.isValue = void 0;\n    this.isSibling = void 0;\n    this.path = void 0;\n    this.getter = void 0;\n    this.map = void 0;\n    if (typeof key !== \'string\') throw new TypeError(\'ref must be a string, got: \' + key);\n    this.key = key.trim();\n    if (key === \'\') throw new TypeError(\'ref must be a non-empty string\');\n    this.isContext = this.key[0] === prefixes.context;\n    this.isValue = this.key[0] === prefixes.value;\n    this.isSibling = !this.isContext && !this.isValue;\n    var prefix = this.isContext ? prefixes.context : this.isValue ? prefixes.value : \'\';\n    this.path = this.key.slice(prefix.length);\n    this.getter = this.path && (0,property_expr__WEBPACK_IMPORTED_MODULE_0__.getter)(this.path, true);\n    this.map = options.map;\n  }\n  return _createClass(Reference, [{\n    key: "getValue",\n    value: function getValue(value, parent, context) {\n      var result = this.isContext ? context : this.isValue ? value : parent;\n      if (this.getter) result = this.getter(result || {});\n      if (this.map) result = this.map(result);\n      return result;\n    }\n\n    /**\n     *\n     * @param {*} value\n     * @param {Object} options\n     * @param {Object=} options.context\n     * @param {Object=} options.parent\n     */\n  }, {\n    key: "cast",\n    value: function cast(value, options) {\n      return this.getValue(value, options == null ? void 0 : options.parent, options == null ? void 0 : options.context);\n    }\n  }, {\n    key: "resolve",\n    value: function resolve() {\n      return this;\n    }\n  }, {\n    key: "describe",\n    value: function describe() {\n      return {\n        type: \'ref\',\n        key: this.key\n      };\n    }\n  }, {\n    key: "toString",\n    value: function toString() {\n      return "Ref(".concat(this.key, ")");\n    }\n  }], [{\n    key: "isRef",\n    value: function isRef(value) {\n      return value && value.__isYupRef;\n    }\n  }]);\n}(); // @ts-ignore\nReference.prototype.__isYupRef = true;\nvar isAbsent = function isAbsent(value) {\n  return value == null;\n};\nfunction createValidation(config) {\n  function validate(_ref2, panic, next) {\n    var value = _ref2.value,\n      _ref2$path = _ref2.path,\n      path = _ref2$path === void 0 ? \'\' : _ref2$path,\n      options = _ref2.options,\n      originalValue = _ref2.originalValue,\n      schema = _ref2.schema;\n    var name = config.name,\n      test = config.test,\n      params = config.params,\n      message = config.message,\n      skipAbsent = config.skipAbsent;\n    var parent = options.parent,\n      context = options.context,\n      _options$abortEarly2 = options.abortEarly,\n      abortEarly = _options$abortEarly2 === void 0 ? schema.spec.abortEarly : _options$abortEarly2,\n      _options$disableStack4 = options.disableStackTrace,\n      disableStackTrace = _options$disableStack4 === void 0 ? schema.spec.disableStackTrace : _options$disableStack4;\n    function resolve(item) {\n      return Reference.isRef(item) ? item.getValue(value, parent, context) : item;\n    }\n    function createError() {\n      var overrides = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var nextParams = Object.assign({\n        value: value,\n        originalValue: originalValue,\n        label: schema.spec.label,\n        path: overrides.path || path,\n        spec: schema.spec,\n        disableStackTrace: overrides.disableStackTrace || disableStackTrace\n      }, params, overrides.params);\n      for (var _i = 0, _Object$keys = Object.keys(nextParams); _i < _Object$keys.length; _i++) {\n        var key = _Object$keys[_i];\n        nextParams[key] = resolve(nextParams[key]);\n      }\n      var error = new ValidationError(ValidationError.formatError(overrides.message || message, nextParams), value, nextParams.path, overrides.type || name, nextParams.disableStackTrace);\n      error.params = nextParams;\n      return error;\n    }\n    var invalid = abortEarly ? panic : next;\n    var ctx = {\n      path: path,\n      parent: parent,\n      type: name,\n      from: options.from,\n      createError: createError,\n      resolve: resolve,\n      options: options,\n      originalValue: originalValue,\n      schema: schema\n    };\n    var handleResult = function handleResult(validOrError) {\n      if (ValidationError.isError(validOrError)) invalid(validOrError);else if (!validOrError) invalid(createError());else next(null);\n    };\n    var handleError = function handleError(err) {\n      if (ValidationError.isError(err)) invalid(err);else panic(err);\n    };\n    var shouldSkip = skipAbsent && isAbsent(value);\n    if (shouldSkip) {\n      return handleResult(true);\n    }\n    var result;\n    try {\n      var _result;\n      result = test.call(ctx, value, ctx);\n      if (typeof ((_result = result) == null ? void 0 : _result.then) === \'function\') {\n        if (options.sync) {\n          throw new Error("Validation test of type: \\"".concat(ctx.type, "\\" returned a Promise during a synchronous validate. ") + "This test will finish after the validate call has returned");\n        }\n        return Promise.resolve(result).then(handleResult, handleError);\n      }\n    } catch (err) {\n      handleError(err);\n      return;\n    }\n    handleResult(result);\n  }\n  validate.OPTIONS = config;\n  return validate;\n}\nfunction getIn(schema, path, value) {\n  var context = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : value;\n  var parent, lastPart, lastPartDebug;\n\n  // root path: \'\'\n  if (!path) return {\n    parent: parent,\n    parentPath: path,\n    schema: schema\n  };\n  (0,property_expr__WEBPACK_IMPORTED_MODULE_0__.forEach)(path, function (_part, isBracket, isArray) {\n    var part = isBracket ? _part.slice(1, _part.length - 1) : _part;\n    schema = schema.resolve({\n      context: context,\n      parent: parent,\n      value: value\n    });\n    var isTuple = schema.type === \'tuple\';\n    var idx = isArray ? parseInt(part, 10) : 0;\n    if (schema.innerType || isTuple) {\n      if (isTuple && !isArray) throw new Error("Yup.reach cannot implicitly index into a tuple type. the path part \\"".concat(lastPartDebug, "\\" must contain an index to the tuple element, e.g. \\"").concat(lastPartDebug, "[0]\\""));\n      if (value && idx >= value.length) {\n        throw new Error("Yup.reach cannot resolve an array item at index: ".concat(_part, ", in the path: ").concat(path, ". ") + "because there is no value at that index. ");\n      }\n      parent = value;\n      value = value && value[idx];\n      schema = isTuple ? schema.spec.types[idx] : schema.innerType;\n    }\n\n    // sometimes the array index part of a path doesn\'t exist: "nested.arr.child"\n    // in these cases the current part is the next schema and should be processed\n    // in this iteration. For cases where the index signature is included this\n    // check will fail and we\'ll handle the `child` part on the next iteration like normal\n    if (!isArray) {\n      if (!schema.fields || !schema.fields[part]) throw new Error("The schema does not contain the path: ".concat(path, ". ") + "(failed at: ".concat(lastPartDebug, " which is a type: \\"").concat(schema.type, "\\")"));\n      parent = value;\n      value = value && value[part];\n      schema = schema.fields[part];\n    }\n    lastPart = part;\n    lastPartDebug = isBracket ? \'[\' + _part + \']\' : \'.\' + _part;\n  });\n  return {\n    schema: schema,\n    parent: parent,\n    parentPath: lastPart\n  };\n}\nfunction reach(obj, path, value, context) {\n  return getIn(obj, path, value, context).schema;\n}\nvar ReferenceSet = /*#__PURE__*/function (_Set) {\n  function ReferenceSet() {\n    _classCallCheck(this, ReferenceSet);\n    return _callSuper(this, ReferenceSet, arguments);\n  }\n  _inherits(ReferenceSet, _Set);\n  return _createClass(ReferenceSet, [{\n    key: "describe",\n    value: function describe() {\n      var description = [];\n      var _iterator = _createForOfIteratorHelper(this.values()),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var item = _step.value;\n          description.push(Reference.isRef(item) ? item.describe() : item);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n      return description;\n    }\n  }, {\n    key: "resolveAll",\n    value: function resolveAll(resolve) {\n      var result = [];\n      var _iterator2 = _createForOfIteratorHelper(this.values()),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var item = _step2.value;\n          result.push(resolve(item));\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n      return result;\n    }\n  }, {\n    key: "clone",\n    value: function clone() {\n      return new ReferenceSet(this.values());\n    }\n  }, {\n    key: "merge",\n    value: function merge(newItems, removeItems) {\n      var next = this.clone();\n      newItems.forEach(function (value) {\n        return next.add(value);\n      });\n      removeItems.forEach(function (value) {\n        return next.delete(value);\n      });\n      return next;\n    }\n  }]);\n}(/*#__PURE__*/_wrapNativeSuper(Set)); // tweaked from https://github.com/Kelin2025/nanoclone/blob/0abeb7635bda9b68ef2277093f76dbe3bf3948e1/src/index.js\nfunction _clone(src) {\n  var seen = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Map();\n  if (isSchema(src) || !src || _typeof(src) !== \'object\') return src;\n  if (seen.has(src)) return seen.get(src);\n  var copy;\n  if (src instanceof Date) {\n    // Date\n    copy = new Date(src.getTime());\n    seen.set(src, copy);\n  } else if (src instanceof RegExp) {\n    // RegExp\n    copy = new RegExp(src);\n    seen.set(src, copy);\n  } else if (Array.isArray(src)) {\n    // Array\n    copy = new Array(src.length);\n    seen.set(src, copy);\n    for (var i = 0; i < src.length; i++) copy[i] = _clone(src[i], seen);\n  } else if (src instanceof Map) {\n    // Map\n    copy = new Map();\n    seen.set(src, copy);\n    var _iterator3 = _createForOfIteratorHelper(src.entries()),\n      _step3;\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var _step3$value = _slicedToArray(_step3.value, 2),\n          k = _step3$value[0],\n          v = _step3$value[1];\n        copy.set(k, _clone(v, seen));\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n  } else if (src instanceof Set) {\n    // Set\n    copy = new Set();\n    seen.set(src, copy);\n    var _iterator4 = _createForOfIteratorHelper(src),\n      _step4;\n    try {\n      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n        var _v = _step4.value;\n        copy.add(_clone(_v, seen));\n      }\n    } catch (err) {\n      _iterator4.e(err);\n    } finally {\n      _iterator4.f();\n    }\n  } else if (src instanceof Object) {\n    // Object\n    copy = {};\n    seen.set(src, copy);\n    for (var _i2 = 0, _Object$entries = Object.entries(src); _i2 < _Object$entries.length; _i2++) {\n      var _Object$entries$_i = _slicedToArray(_Object$entries[_i2], 2),\n        _k = _Object$entries$_i[0],\n        _v2 = _Object$entries$_i[1];\n      copy[_k] = _clone(_v2, seen);\n    }\n  } else {\n    throw Error("Unable to clone ".concat(src));\n  }\n  return copy;\n}\n\n// If `CustomSchemaMeta` isn\'t extended with any keys, we\'ll fall back to a\n// loose Record definition allowing free form usage.\nvar Schema = /*#__PURE__*/function () {\n  function Schema(options) {\n    var _this3 = this;\n    _classCallCheck(this, Schema);\n    this.type = void 0;\n    this.deps = [];\n    this.tests = void 0;\n    this.transforms = void 0;\n    this.conditions = [];\n    this._mutate = void 0;\n    this.internalTests = {};\n    this._whitelist = new ReferenceSet();\n    this._blacklist = new ReferenceSet();\n    this.exclusiveTests = Object.create(null);\n    this._typeCheck = void 0;\n    this.spec = void 0;\n    this.tests = [];\n    this.transforms = [];\n    this.withMutation(function () {\n      _this3.typeError(mixed.notType);\n    });\n    this.type = options.type;\n    this._typeCheck = options.check;\n    this.spec = Object.assign({\n      strip: false,\n      strict: false,\n      abortEarly: true,\n      recursive: true,\n      disableStackTrace: false,\n      nullable: false,\n      optional: true,\n      coerce: true\n    }, options == null ? void 0 : options.spec);\n    this.withMutation(function (s) {\n      s.nonNullable();\n    });\n  }\n\n  // TODO: remove\n  return _createClass(Schema, [{\n    key: "_type",\n    get: function get() {\n      return this.type;\n    }\n  }, {\n    key: "clone",\n    value: function clone(spec) {\n      if (this._mutate) {\n        if (spec) Object.assign(this.spec, spec);\n        return this;\n      }\n\n      // if the nested value is a schema we can skip cloning, since\n      // they are already immutable\n      var next = Object.create(Object.getPrototypeOf(this));\n\n      // @ts-expect-error this is readonly\n      next.type = this.type;\n      next._typeCheck = this._typeCheck;\n      next._whitelist = this._whitelist.clone();\n      next._blacklist = this._blacklist.clone();\n      next.internalTests = Object.assign({}, this.internalTests);\n      next.exclusiveTests = Object.assign({}, this.exclusiveTests);\n\n      // @ts-expect-error this is readonly\n      next.deps = _toConsumableArray(this.deps);\n      next.conditions = _toConsumableArray(this.conditions);\n      next.tests = _toConsumableArray(this.tests);\n      next.transforms = _toConsumableArray(this.transforms);\n      next.spec = _clone(Object.assign({}, this.spec, spec));\n      return next;\n    }\n  }, {\n    key: "label",\n    value: function label(_label) {\n      var next = this.clone();\n      next.spec.label = _label;\n      return next;\n    }\n  }, {\n    key: "meta",\n    value: function meta() {\n      if (arguments.length === 0) return this.spec.meta;\n      var next = this.clone();\n      next.spec.meta = Object.assign(next.spec.meta || {}, arguments.length <= 0 ? undefined : arguments[0]);\n      return next;\n    }\n  }, {\n    key: "withMutation",\n    value: function withMutation(fn) {\n      var before = this._mutate;\n      this._mutate = true;\n      var result = fn(this);\n      this._mutate = before;\n      return result;\n    }\n  }, {\n    key: "concat",\n    value: function concat(schema) {\n      if (!schema || schema === this) return this;\n      if (schema.type !== this.type && this.type !== \'mixed\') throw new TypeError("You cannot `concat()` schema\'s of different types: ".concat(this.type, " and ").concat(schema.type));\n      var base = this;\n      var combined = schema.clone();\n      var mergedSpec = Object.assign({}, base.spec, combined.spec);\n      combined.spec = mergedSpec;\n      combined.internalTests = Object.assign({}, base.internalTests, combined.internalTests);\n\n      // manually merge the blacklist/whitelist (the other `schema` takes\n      // precedence in case of conflicts)\n      combined._whitelist = base._whitelist.merge(schema._whitelist, schema._blacklist);\n      combined._blacklist = base._blacklist.merge(schema._blacklist, schema._whitelist);\n\n      // start with the current tests\n      combined.tests = base.tests;\n      combined.exclusiveTests = base.exclusiveTests;\n\n      // manually add the new tests to ensure\n      // the deduping logic is consistent\n      combined.withMutation(function (next) {\n        schema.tests.forEach(function (fn) {\n          next.test(fn.OPTIONS);\n        });\n      });\n      combined.transforms = [].concat(_toConsumableArray(base.transforms), _toConsumableArray(combined.transforms));\n      return combined;\n    }\n  }, {\n    key: "isType",\n    value: function isType(v) {\n      if (v == null) {\n        if (this.spec.nullable && v === null) return true;\n        if (this.spec.optional && v === undefined) return true;\n        return false;\n      }\n      return this._typeCheck(v);\n    }\n  }, {\n    key: "resolve",\n    value: function resolve(options) {\n      var schema = this;\n      if (schema.conditions.length) {\n        var conditions = schema.conditions;\n        schema = schema.clone();\n        schema.conditions = [];\n        schema = conditions.reduce(function (prevSchema, condition) {\n          return condition.resolve(prevSchema, options);\n        }, schema);\n        schema = schema.resolve(options);\n      }\n      return schema;\n    }\n  }, {\n    key: "resolveOptions",\n    value: function resolveOptions(options) {\n      var _options$strict, _options$abortEarly, _options$recursive, _options$disableStack;\n      return Object.assign({}, options, {\n        from: options.from || [],\n        strict: (_options$strict = options.strict) != null ? _options$strict : this.spec.strict,\n        abortEarly: (_options$abortEarly = options.abortEarly) != null ? _options$abortEarly : this.spec.abortEarly,\n        recursive: (_options$recursive = options.recursive) != null ? _options$recursive : this.spec.recursive,\n        disableStackTrace: (_options$disableStack = options.disableStackTrace) != null ? _options$disableStack : this.spec.disableStackTrace\n      });\n    }\n\n    /**\n     * Run the configured transform pipeline over an input value.\n     */\n  }, {\n    key: "cast",\n    value: function cast(value) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var resolvedSchema = this.resolve(Object.assign({\n        value: value\n      }, options));\n      var allowOptionality = options.assert === \'ignore-optionality\';\n      var result = resolvedSchema._cast(value, options);\n      if (options.assert !== false && !resolvedSchema.isType(result)) {\n        if (allowOptionality && isAbsent(result)) {\n          return result;\n        }\n        var formattedValue = printValue(value);\n        var formattedResult = printValue(result);\n        throw new TypeError("The value of ".concat(options.path || \'field\', " could not be cast to a value ") + "that satisfies the schema type: \\"".concat(resolvedSchema.type, "\\". \\n\\n") + "attempted value: ".concat(formattedValue, " \\n") + (formattedResult !== formattedValue ? "result of cast: ".concat(formattedResult) : \'\'));\n      }\n      return result;\n    }\n  }, {\n    key: "_cast",\n    value: function _cast(rawValue, options) {\n      var _this4 = this;\n      var value = rawValue === undefined ? rawValue : this.transforms.reduce(function (prevValue, fn) {\n        return fn.call(_this4, prevValue, rawValue, _this4);\n      }, rawValue);\n      if (value === undefined) {\n        value = this.getDefault(options);\n      }\n      return value;\n    }\n  }, {\n    key: "_validate",\n    value: function _validate(_value) {\n      var _this5 = this;\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var panic = arguments.length > 2 ? arguments[2] : undefined;\n      var next = arguments.length > 3 ? arguments[3] : undefined;\n      var path = options.path,\n        _options$originalValu3 = options.originalValue,\n        originalValue = _options$originalValu3 === void 0 ? _value : _options$originalValu3,\n        _options$strict2 = options.strict,\n        strict = _options$strict2 === void 0 ? this.spec.strict : _options$strict2;\n      var value = _value;\n      if (!strict) {\n        value = this._cast(value, Object.assign({\n          assert: false\n        }, options));\n      }\n      var initialTests = [];\n      for (var _i3 = 0, _Object$values = Object.values(this.internalTests); _i3 < _Object$values.length; _i3++) {\n        var test = _Object$values[_i3];\n        if (test) initialTests.push(test);\n      }\n      this.runTests({\n        path: path,\n        value: value,\n        originalValue: originalValue,\n        options: options,\n        tests: initialTests\n      }, panic, function (initialErrors) {\n        // even if we aren\'t ending early we can\'t proceed further if the types aren\'t correct\n        if (initialErrors.length) {\n          return next(initialErrors, value);\n        }\n        _this5.runTests({\n          path: path,\n          value: value,\n          originalValue: originalValue,\n          options: options,\n          tests: _this5.tests\n        }, panic, next);\n      });\n    }\n\n    /**\n     * Executes a set of validations, either schema, produced Tests or a nested\n     * schema validate result.\n     */\n  }, {\n    key: "runTests",\n    value: function runTests(runOptions, panic, next) {\n      var fired = false;\n      var tests = runOptions.tests,\n        value = runOptions.value,\n        originalValue = runOptions.originalValue,\n        path = runOptions.path,\n        options = runOptions.options;\n      var panicOnce = function panicOnce(arg) {\n        if (fired) return;\n        fired = true;\n        panic(arg, value);\n      };\n      var nextOnce = function nextOnce(arg) {\n        if (fired) return;\n        fired = true;\n        next(arg, value);\n      };\n      var count = tests.length;\n      var nestedErrors = [];\n      if (!count) return nextOnce([]);\n      var args = {\n        value: value,\n        originalValue: originalValue,\n        path: path,\n        options: options,\n        schema: this\n      };\n      for (var i = 0; i < tests.length; i++) {\n        var test = tests[i];\n        test(args, panicOnce, function finishTestRun(err) {\n          if (err) {\n            Array.isArray(err) ? nestedErrors.push.apply(nestedErrors, _toConsumableArray(err)) : nestedErrors.push(err);\n          }\n          if (--count <= 0) {\n            nextOnce(nestedErrors);\n          }\n        });\n      }\n    }\n  }, {\n    key: "asNestedTest",\n    value: function asNestedTest(_ref3) {\n      var _this6 = this;\n      var key = _ref3.key,\n        index = _ref3.index,\n        parent = _ref3.parent,\n        parentPath = _ref3.parentPath,\n        originalParent = _ref3.originalParent,\n        options = _ref3.options;\n      var k = key != null ? key : index;\n      if (k == null) {\n        throw TypeError(\'Must include `key` or `index` for nested validations\');\n      }\n      var isIndex = typeof k === \'number\';\n      var value = parent[k];\n      var testOptions = Object.assign({}, options, _defineProperty(_defineProperty({\n        // Nested validations fields are always strict:\n        //    1. parent isn\'t strict so the casting will also have cast inner values\n        //    2. parent is strict in which case the nested values weren\'t cast either\n        strict: true,\n        parent: parent,\n        value: value,\n        originalValue: originalParent[k],\n        // FIXME: tests depend on `index` being passed around deeply,\n        //   we should not let the options.key/index bleed through\n        key: undefined\n      }, isIndex ? \'index\' : \'key\', k), "path", isIndex || k.includes(\'.\') ? "".concat(parentPath || \'\', "[").concat(isIndex ? k : "\\"".concat(k, "\\""), "]") : (parentPath ? "".concat(parentPath, ".") : \'\') + key));\n      return function (_, panic, next) {\n        return _this6.resolve(testOptions)._validate(value, testOptions, panic, next);\n      };\n    }\n  }, {\n    key: "validate",\n    value: function validate(value, options) {\n      var _options$disableStack2;\n      var schema = this.resolve(Object.assign({}, options, {\n        value: value\n      }));\n      var disableStackTrace = (_options$disableStack2 = options == null ? void 0 : options.disableStackTrace) != null ? _options$disableStack2 : schema.spec.disableStackTrace;\n      return new Promise(function (resolve, reject) {\n        return schema._validate(value, options, function (error, parsed) {\n          if (ValidationError.isError(error)) error.value = parsed;\n          reject(error);\n        }, function (errors, validated) {\n          if (errors.length) reject(new ValidationError(errors, validated, undefined, undefined, disableStackTrace));else resolve(validated);\n        });\n      });\n    }\n  }, {\n    key: "validateSync",\n    value: function validateSync(value, options) {\n      var _options$disableStack3;\n      var schema = this.resolve(Object.assign({}, options, {\n        value: value\n      }));\n      var result;\n      var disableStackTrace = (_options$disableStack3 = options == null ? void 0 : options.disableStackTrace) != null ? _options$disableStack3 : schema.spec.disableStackTrace;\n      schema._validate(value, Object.assign({}, options, {\n        sync: true\n      }), function (error, parsed) {\n        if (ValidationError.isError(error)) error.value = parsed;\n        throw error;\n      }, function (errors, validated) {\n        if (errors.length) throw new ValidationError(errors, value, undefined, undefined, disableStackTrace);\n        result = validated;\n      });\n      return result;\n    }\n  }, {\n    key: "isValid",\n    value: function isValid(value, options) {\n      return this.validate(value, options).then(function () {\n        return true;\n      }, function (err) {\n        if (ValidationError.isError(err)) return false;\n        throw err;\n      });\n    }\n  }, {\n    key: "isValidSync",\n    value: function isValidSync(value, options) {\n      try {\n        this.validateSync(value, options);\n        return true;\n      } catch (err) {\n        if (ValidationError.isError(err)) return false;\n        throw err;\n      }\n    }\n  }, {\n    key: "_getDefault",\n    value: function _getDefault(options) {\n      var defaultValue = this.spec.default;\n      if (defaultValue == null) {\n        return defaultValue;\n      }\n      return typeof defaultValue === \'function\' ? defaultValue.call(this, options) : _clone(defaultValue);\n    }\n  }, {\n    key: "getDefault",\n    value: function getDefault(options\n    // If schema is defaulted we know it\'s at least not undefined\n    ) {\n      var schema = this.resolve(options || {});\n      return schema._getDefault(options);\n    }\n  }, {\n    key: "default",\n    value: function _default(def) {\n      if (arguments.length === 0) {\n        return this._getDefault();\n      }\n      var next = this.clone({\n        default: def\n      });\n      return next;\n    }\n  }, {\n    key: "strict",\n    value: function strict() {\n      var isStrict = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      return this.clone({\n        strict: isStrict\n      });\n    }\n  }, {\n    key: "nullability",\n    value: function nullability(nullable, message) {\n      var next = this.clone({\n        nullable: nullable\n      });\n      next.internalTests.nullable = createValidation({\n        message: message,\n        name: \'nullable\',\n        test: function test(value) {\n          return value === null ? this.schema.spec.nullable : true;\n        }\n      });\n      return next;\n    }\n  }, {\n    key: "optionality",\n    value: function optionality(optional, message) {\n      var next = this.clone({\n        optional: optional\n      });\n      next.internalTests.optionality = createValidation({\n        message: message,\n        name: \'optionality\',\n        test: function test(value) {\n          return value === undefined ? this.schema.spec.optional : true;\n        }\n      });\n      return next;\n    }\n  }, {\n    key: "optional",\n    value: function optional() {\n      return this.optionality(true);\n    }\n  }, {\n    key: "defined",\n    value: function defined() {\n      var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : mixed.defined;\n      return this.optionality(false, message);\n    }\n  }, {\n    key: "nullable",\n    value: function nullable() {\n      return this.nullability(true);\n    }\n  }, {\n    key: "nonNullable",\n    value: function nonNullable() {\n      var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : mixed.notNull;\n      return this.nullability(false, message);\n    }\n  }, {\n    key: "required",\n    value: function required() {\n      var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : mixed.required;\n      return this.clone().withMutation(function (next) {\n        return next.nonNullable(message).defined(message);\n      });\n    }\n  }, {\n    key: "notRequired",\n    value: function notRequired() {\n      return this.clone().withMutation(function (next) {\n        return next.nullable().optional();\n      });\n    }\n  }, {\n    key: "transform",\n    value: function transform(fn) {\n      var next = this.clone();\n      next.transforms.push(fn);\n      return next;\n    }\n\n    /**\n     * Adds a test function to the schema\'s queue of tests.\n     * tests can be exclusive or non-exclusive.\n     *\n     * - exclusive tests, will replace any existing tests of the same name.\n     * - non-exclusive: can be stacked\n     *\n     * If a non-exclusive test is added to a schema with an exclusive test of the same name\n     * the exclusive test is removed and further tests of the same name will be stacked.\n     *\n     * If an exclusive test is added to a schema with non-exclusive tests of the same name\n     * the previous tests are removed and further tests of the same name will replace each other.\n     */\n  }, {\n    key: "test",\n    value: function test() {\n      var opts;\n      if (arguments.length === 1) {\n        if (typeof (arguments.length <= 0 ? undefined : arguments[0]) === \'function\') {\n          opts = {\n            test: arguments.length <= 0 ? undefined : arguments[0]\n          };\n        } else {\n          opts = arguments.length <= 0 ? undefined : arguments[0];\n        }\n      } else if (arguments.length === 2) {\n        opts = {\n          name: arguments.length <= 0 ? undefined : arguments[0],\n          test: arguments.length <= 1 ? undefined : arguments[1]\n        };\n      } else {\n        opts = {\n          name: arguments.length <= 0 ? undefined : arguments[0],\n          message: arguments.length <= 1 ? undefined : arguments[1],\n          test: arguments.length <= 2 ? undefined : arguments[2]\n        };\n      }\n      if (opts.message === undefined) opts.message = mixed.default;\n      if (typeof opts.test !== \'function\') throw new TypeError(\'`test` is a required parameters\');\n      var next = this.clone();\n      var validate = createValidation(opts);\n      var isExclusive = opts.exclusive || opts.name && next.exclusiveTests[opts.name] === true;\n      if (opts.exclusive) {\n        if (!opts.name) throw new TypeError(\'Exclusive tests must provide a unique `name` identifying the test\');\n      }\n      if (opts.name) next.exclusiveTests[opts.name] = !!opts.exclusive;\n      next.tests = next.tests.filter(function (fn) {\n        if (fn.OPTIONS.name === opts.name) {\n          if (isExclusive) return false;\n          if (fn.OPTIONS.test === validate.OPTIONS.test) return false;\n        }\n        return true;\n      });\n      next.tests.push(validate);\n      return next;\n    }\n  }, {\n    key: "when",\n    value: function when(keys, options) {\n      if (!Array.isArray(keys) && typeof keys !== \'string\') {\n        options = keys;\n        keys = \'.\';\n      }\n      var next = this.clone();\n      var deps = toArray(keys).map(function (key) {\n        return new Reference(key);\n      });\n      deps.forEach(function (dep) {\n        // @ts-ignore readonly array\n        if (dep.isSibling) next.deps.push(dep.key);\n      });\n      next.conditions.push(typeof options === \'function\' ? new Condition(deps, options) : Condition.fromOptions(deps, options));\n      return next;\n    }\n  }, {\n    key: "typeError",\n    value: function typeError(message) {\n      var next = this.clone();\n      next.internalTests.typeError = createValidation({\n        message: message,\n        name: \'typeError\',\n        skipAbsent: true,\n        test: function test(value) {\n          if (!this.schema._typeCheck(value)) return this.createError({\n            params: {\n              type: this.schema.type\n            }\n          });\n          return true;\n        }\n      });\n      return next;\n    }\n  }, {\n    key: "oneOf",\n    value: function oneOf(enums) {\n      var message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : mixed.oneOf;\n      var next = this.clone();\n      enums.forEach(function (val) {\n        next._whitelist.add(val);\n        next._blacklist.delete(val);\n      });\n      next.internalTests.whiteList = createValidation({\n        message: message,\n        name: \'oneOf\',\n        skipAbsent: true,\n        test: function test(value) {\n          var valids = this.schema._whitelist;\n          var resolved = valids.resolveAll(this.resolve);\n          return resolved.includes(value) ? true : this.createError({\n            params: {\n              values: Array.from(valids).join(\', \'),\n              resolved: resolved\n            }\n          });\n        }\n      });\n      return next;\n    }\n  }, {\n    key: "notOneOf",\n    value: function notOneOf(enums) {\n      var message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : mixed.notOneOf;\n      var next = this.clone();\n      enums.forEach(function (val) {\n        next._blacklist.add(val);\n        next._whitelist.delete(val);\n      });\n      next.internalTests.blacklist = createValidation({\n        message: message,\n        name: \'notOneOf\',\n        test: function test(value) {\n          var invalids = this.schema._blacklist;\n          var resolved = invalids.resolveAll(this.resolve);\n          if (resolved.includes(value)) return this.createError({\n            params: {\n              values: Array.from(invalids).join(\', \'),\n              resolved: resolved\n            }\n          });\n          return true;\n        }\n      });\n      return next;\n    }\n  }, {\n    key: "strip",\n    value: function strip() {\n      var _strip = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      var next = this.clone();\n      next.spec.strip = _strip;\n      return next;\n    }\n\n    /**\n     * Return a serialized description of the schema including validations, flags, types etc.\n     *\n     * @param options Provide any needed context for resolving runtime schema alterations (lazy, when conditions, etc).\n     */\n  }, {\n    key: "describe",\n    value: function describe(options) {\n      var next = (options ? this.resolve(options) : this).clone();\n      var _next$spec = next.spec,\n        label = _next$spec.label,\n        meta = _next$spec.meta,\n        optional = _next$spec.optional,\n        nullable = _next$spec.nullable;\n      var description = {\n        meta: meta,\n        label: label,\n        optional: optional,\n        nullable: nullable,\n        default: next.getDefault(options),\n        type: next.type,\n        oneOf: next._whitelist.describe(),\n        notOneOf: next._blacklist.describe(),\n        tests: next.tests.map(function (fn) {\n          return {\n            name: fn.OPTIONS.name,\n            params: fn.OPTIONS.params\n          };\n        }).filter(function (n, idx, list) {\n          return list.findIndex(function (c) {\n            return c.name === n.name;\n          }) === idx;\n        })\n      };\n      return description;\n    }\n  }]);\n}(); // @ts-expect-error\nSchema.prototype.__isYupSchema__ = true;\nvar _loop = function _loop() {\n  var method = _arr[_i4];\n  Schema.prototype["".concat(method, "At")] = function (path, value) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var _getIn = getIn(this, path, value, options.context),\n      parent = _getIn.parent,\n      parentPath = _getIn.parentPath,\n      schema = _getIn.schema;\n    return schema[method](parent && parent[parentPath], Object.assign({}, options, {\n      parent: parent,\n      path: path\n    }));\n  };\n};\nfor (var _i4 = 0, _arr = [\'validate\', \'validateSync\']; _i4 < _arr.length; _i4++) {\n  _loop();\n}\nfor (var _i5 = 0, _arr2 = [\'equals\', \'is\']; _i5 < _arr2.length; _i5++) {\n  var alias = _arr2[_i5];\n  Schema.prototype[alias] = Schema.prototype.oneOf;\n}\nfor (var _i6 = 0, _arr3 = [\'not\', \'nope\']; _i6 < _arr3.length; _i6++) {\n  var _alias = _arr3[_i6];\n  Schema.prototype[_alias] = Schema.prototype.notOneOf;\n}\nvar returnsTrue = function returnsTrue() {\n  return true;\n};\nfunction create$8(spec) {\n  return new MixedSchema(spec);\n}\nvar MixedSchema = /*#__PURE__*/function (_Schema) {\n  function MixedSchema(spec) {\n    _classCallCheck(this, MixedSchema);\n    return _callSuper(this, MixedSchema, [typeof spec === \'function\' ? {\n      type: \'mixed\',\n      check: spec\n    } : Object.assign({\n      type: \'mixed\',\n      check: returnsTrue\n    }, spec)]);\n  }\n  _inherits(MixedSchema, _Schema);\n  return _createClass(MixedSchema);\n}(Schema);\ncreate$8.prototype = MixedSchema.prototype;\nfunction create$7() {\n  return new BooleanSchema();\n}\nvar BooleanSchema = /*#__PURE__*/function (_Schema2) {\n  function BooleanSchema() {\n    var _this7;\n    _classCallCheck(this, BooleanSchema);\n    _this7 = _callSuper(this, BooleanSchema, [{\n      type: \'boolean\',\n      check: function check(v) {\n        if (v instanceof Boolean) v = v.valueOf();\n        return typeof v === \'boolean\';\n      }\n    }]);\n    _this7.withMutation(function () {\n      _this7.transform(function (value, _raw, ctx) {\n        if (ctx.spec.coerce && !ctx.isType(value)) {\n          if (/^(true|1)$/i.test(String(value))) return true;\n          if (/^(false|0)$/i.test(String(value))) return false;\n        }\n        return value;\n      });\n    });\n    return _this7;\n  }\n  _inherits(BooleanSchema, _Schema2);\n  return _createClass(BooleanSchema, [{\n    key: "isTrue",\n    value: function isTrue() {\n      var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : boolean.isValue;\n      return this.test({\n        message: message,\n        name: \'is-value\',\n        exclusive: true,\n        params: {\n          value: \'true\'\n        },\n        test: function test(value) {\n          return isAbsent(value) || value === true;\n        }\n      });\n    }\n  }, {\n    key: "isFalse",\n    value: function isFalse() {\n      var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : boolean.isValue;\n      return this.test({\n        message: message,\n        name: \'is-value\',\n        exclusive: true,\n        params: {\n          value: \'false\'\n        },\n        test: function test(value) {\n          return isAbsent(value) || value === false;\n        }\n      });\n    }\n  }, {\n    key: "default",\n    value: function _default(def) {\n      return _superPropGet(BooleanSchema, "default", this, 3)([def]);\n    }\n  }, {\n    key: "defined",\n    value: function defined(msg) {\n      return _superPropGet(BooleanSchema, "defined", this, 3)([msg]);\n    }\n  }, {\n    key: "optional",\n    value: function optional() {\n      return _superPropGet(BooleanSchema, "optional", this, 3)([]);\n    }\n  }, {\n    key: "required",\n    value: function required(msg) {\n      return _superPropGet(BooleanSchema, "required", this, 3)([msg]);\n    }\n  }, {\n    key: "notRequired",\n    value: function notRequired() {\n      return _superPropGet(BooleanSchema, "notRequired", this, 3)([]);\n    }\n  }, {\n    key: "nullable",\n    value: function nullable() {\n      return _superPropGet(BooleanSchema, "nullable", this, 3)([]);\n    }\n  }, {\n    key: "nonNullable",\n    value: function nonNullable(msg) {\n      return _superPropGet(BooleanSchema, "nonNullable", this, 3)([msg]);\n    }\n  }, {\n    key: "strip",\n    value: function strip(v) {\n      return _superPropGet(BooleanSchema, "strip", this, 3)([v]);\n    }\n  }]);\n}(Schema);\ncreate$7.prototype = BooleanSchema.prototype;\n\n/**\n * This file is a modified version of the file from the following repository:\n * Date.parse with progressive enhancement for ISO 8601 <https://github.com/csnover/js-iso8601>\n * NON-CONFORMANT EDITION.\n * © 2011 Colin Snover <http://zetafleet.com>\n * Released under MIT license.\n */\n\n// prettier-ignore\n//                1 YYYY                2 MM        3 DD              4 HH     5 mm        6 ss           7 msec         8 Z 9 ±   10 tzHH    11 tzmm\nvar isoReg = /^(\\d{4}|[+-]\\d{6})(?:-?(\\d{2})(?:-?(\\d{2}))?)?(?:[ T]?(\\d{2}):?(\\d{2})(?::?(\\d{2})(?:[,.](\\d{1,}))?)?(?:(Z)|([+-])(\\d{2})(?::?(\\d{2}))?)?)?$/;\nfunction parseIsoDate(date) {\n  var struct = parseDateStruct(date);\n  if (!struct) return Date.parse ? Date.parse(date) : Number.NaN;\n\n  // timestamps without timezone identifiers should be considered local time\n  if (struct.z === undefined && struct.plusMinus === undefined) {\n    return new Date(struct.year, struct.month, struct.day, struct.hour, struct.minute, struct.second, struct.millisecond).valueOf();\n  }\n  var totalMinutesOffset = 0;\n  if (struct.z !== \'Z\' && struct.plusMinus !== undefined) {\n    totalMinutesOffset = struct.hourOffset * 60 + struct.minuteOffset;\n    if (struct.plusMinus === \'+\') totalMinutesOffset = 0 - totalMinutesOffset;\n  }\n  return Date.UTC(struct.year, struct.month, struct.day, struct.hour, struct.minute + totalMinutesOffset, struct.second, struct.millisecond);\n}\nfunction parseDateStruct(date) {\n  var _regexResult$7$length, _regexResult$;\n  var regexResult = isoReg.exec(date);\n  if (!regexResult) return null;\n\n  // use of toNumber() avoids NaN timestamps caused by “undefined”\n  // values being passed to Date constructor\n  return {\n    year: toNumber(regexResult[1]),\n    month: toNumber(regexResult[2], 1) - 1,\n    day: toNumber(regexResult[3], 1),\n    hour: toNumber(regexResult[4]),\n    minute: toNumber(regexResult[5]),\n    second: toNumber(regexResult[6]),\n    millisecond: regexResult[7] ?\n    // allow arbitrary sub-second precision beyond milliseconds\n    toNumber(regexResult[7].substring(0, 3)) : 0,\n    precision: (_regexResult$7$length = (_regexResult$ = regexResult[7]) == null ? void 0 : _regexResult$.length) != null ? _regexResult$7$length : undefined,\n    z: regexResult[8] || undefined,\n    plusMinus: regexResult[9] || undefined,\n    hourOffset: toNumber(regexResult[10]),\n    minuteOffset: toNumber(regexResult[11])\n  };\n}\nfunction toNumber(str) {\n  var defaultValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  return Number(str) || defaultValue;\n}\n\n// Taken from HTML spec: https://html.spec.whatwg.org/multipage/input.html#valid-e-mail-address\nvar rEmail =\n// eslint-disable-next-line\n/^[a-zA-Z0-9.!#$%&\'*+\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;\nvar rUrl =\n// eslint-disable-next-line\n/^((https?|ftp):)?\\/\\/(((([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&\'\\(\\)\\*\\+,;=]|:)*@)?(((\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5]))|((([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)+(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.?)(:\\d*)?)(\\/((([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&\'\\(\\)\\*\\+,;=]|:|@)+(\\/(([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&\'\\(\\)\\*\\+,;=]|:|@)*)*)?)?(\\?((([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&\'\\(\\)\\*\\+,;=]|:|@)|[\\uE000-\\uF8FF]|\\/|\\?)*)?(\\#((([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&\'\\(\\)\\*\\+,;=]|:|@)|\\/|\\?)*)?$/i;\n\n// eslint-disable-next-line\nvar rUUID = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;\nvar yearMonthDay = \'^\\\\d{4}-\\\\d{2}-\\\\d{2}\';\nvar hourMinuteSecond = \'\\\\d{2}:\\\\d{2}:\\\\d{2}\';\nvar zOrOffset = \'(([+-]\\\\d{2}(:?\\\\d{2})?)|Z)\';\nvar rIsoDateTime = new RegExp("".concat(yearMonthDay, "T").concat(hourMinuteSecond, "(\\\\.\\\\d+)?").concat(zOrOffset, "$"));\nvar isTrimmed = function isTrimmed(value) {\n  return isAbsent(value) || value === value.trim();\n};\nvar objStringTag = {}.toString();\nfunction create$6() {\n  return new StringSchema();\n}\nvar StringSchema = /*#__PURE__*/function (_Schema3) {\n  function StringSchema() {\n    var _this8;\n    _classCallCheck(this, StringSchema);\n    _this8 = _callSuper(this, StringSchema, [{\n      type: \'string\',\n      check: function check(value) {\n        if (value instanceof String) value = value.valueOf();\n        return typeof value === \'string\';\n      }\n    }]);\n    _this8.withMutation(function () {\n      _this8.transform(function (value, _raw, ctx) {\n        if (!ctx.spec.coerce || ctx.isType(value)) return value;\n\n        // don\'t ever convert arrays\n        if (Array.isArray(value)) return value;\n        var strValue = value != null && value.toString ? value.toString() : value;\n\n        // no one wants plain objects converted to [Object object]\n        if (strValue === objStringTag) return value;\n        return strValue;\n      });\n    });\n    return _this8;\n  }\n  _inherits(StringSchema, _Schema3);\n  return _createClass(StringSchema, [{\n    key: "required",\n    value: function required(message) {\n      return _superPropGet(StringSchema, "required", this, 3)([message]).withMutation(function (schema) {\n        return schema.test({\n          message: message || mixed.required,\n          name: \'required\',\n          skipAbsent: true,\n          test: function test(value) {\n            return !!value.length;\n          }\n        });\n      });\n    }\n  }, {\n    key: "notRequired",\n    value: function notRequired() {\n      return _superPropGet(StringSchema, "notRequired", this, 3)([]).withMutation(function (schema) {\n        schema.tests = schema.tests.filter(function (t) {\n          return t.OPTIONS.name !== \'required\';\n        });\n        return schema;\n      });\n    }\n  }, {\n    key: "length",\n    value: function length(_length) {\n      var message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : string.length;\n      return this.test({\n        message: message,\n        name: \'length\',\n        exclusive: true,\n        params: {\n          length: _length\n        },\n        skipAbsent: true,\n        test: function test(value) {\n          return value.length === this.resolve(_length);\n        }\n      });\n    }\n  }, {\n    key: "min",\n    value: function min(_min) {\n      var message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : string.min;\n      return this.test({\n        message: message,\n        name: \'min\',\n        exclusive: true,\n        params: {\n          min: _min\n        },\n        skipAbsent: true,\n        test: function test(value) {\n          return value.length >= this.resolve(_min);\n        }\n      });\n    }\n  }, {\n    key: "max",\n    value: function max(_max) {\n      var message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : string.max;\n      return this.test({\n        name: \'max\',\n        exclusive: true,\n        message: message,\n        params: {\n          max: _max\n        },\n        skipAbsent: true,\n        test: function test(value) {\n          return value.length <= this.resolve(_max);\n        }\n      });\n    }\n  }, {\n    key: "matches",\n    value: function matches(regex, options) {\n      var excludeEmptyString = false;\n      var message;\n      var name;\n      if (options) {\n        if (_typeof(options) === \'object\') {\n          var _options$excludeEmpty = options.excludeEmptyString;\n          excludeEmptyString = _options$excludeEmpty === void 0 ? false : _options$excludeEmpty;\n          message = options.message;\n          name = options.name;\n        } else {\n          message = options;\n        }\n      }\n      return this.test({\n        name: name || \'matches\',\n        message: message || string.matches,\n        params: {\n          regex: regex\n        },\n        skipAbsent: true,\n        test: function test(value) {\n          return value === \'\' && excludeEmptyString || value.search(regex) !== -1;\n        }\n      });\n    }\n  }, {\n    key: "email",\n    value: function email() {\n      var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : string.email;\n      return this.matches(rEmail, {\n        name: \'email\',\n        message: message,\n        excludeEmptyString: true\n      });\n    }\n  }, {\n    key: "url",\n    value: function url() {\n      var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : string.url;\n      return this.matches(rUrl, {\n        name: \'url\',\n        message: message,\n        excludeEmptyString: true\n      });\n    }\n  }, {\n    key: "uuid",\n    value: function uuid() {\n      var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : string.uuid;\n      return this.matches(rUUID, {\n        name: \'uuid\',\n        message: message,\n        excludeEmptyString: false\n      });\n    }\n  }, {\n    key: "datetime",\n    value: function datetime(options) {\n      var message = \'\';\n      var allowOffset;\n      var precision;\n      if (options) {\n        if (_typeof(options) === \'object\') {\n          var _options$message = options.message;\n          message = _options$message === void 0 ? \'\' : _options$message;\n          var _options$allowOffset = options.allowOffset;\n          allowOffset = _options$allowOffset === void 0 ? false : _options$allowOffset;\n          var _options$precision = options.precision;\n          precision = _options$precision === void 0 ? undefined : _options$precision;\n        } else {\n          message = options;\n        }\n      }\n      return this.matches(rIsoDateTime, {\n        name: \'datetime\',\n        message: message || string.datetime,\n        excludeEmptyString: true\n      }).test({\n        name: \'datetime_offset\',\n        message: message || string.datetime_offset,\n        params: {\n          allowOffset: allowOffset\n        },\n        skipAbsent: true,\n        test: function test(value) {\n          if (!value || allowOffset) return true;\n          var struct = parseDateStruct(value);\n          if (!struct) return false;\n          return !!struct.z;\n        }\n      }).test({\n        name: \'datetime_precision\',\n        message: message || string.datetime_precision,\n        params: {\n          precision: precision\n        },\n        skipAbsent: true,\n        test: function test(value) {\n          if (!value || precision == undefined) return true;\n          var struct = parseDateStruct(value);\n          if (!struct) return false;\n          return struct.precision === precision;\n        }\n      });\n    }\n\n    //-- transforms --\n  }, {\n    key: "ensure",\n    value: function ensure() {\n      return this.default(\'\').transform(function (val) {\n        return val === null ? \'\' : val;\n      });\n    }\n  }, {\n    key: "trim",\n    value: function trim() {\n      var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : string.trim;\n      return this.transform(function (val) {\n        return val != null ? val.trim() : val;\n      }).test({\n        message: message,\n        name: \'trim\',\n        test: isTrimmed\n      });\n    }\n  }, {\n    key: "lowercase",\n    value: function lowercase() {\n      var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : string.lowercase;\n      return this.transform(function (value) {\n        return !isAbsent(value) ? value.toLowerCase() : value;\n      }).test({\n        message: message,\n        name: \'string_case\',\n        exclusive: true,\n        skipAbsent: true,\n        test: function test(value) {\n          return isAbsent(value) || value === value.toLowerCase();\n        }\n      });\n    }\n  }, {\n    key: "uppercase",\n    value: function uppercase() {\n      var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : string.uppercase;\n      return this.transform(function (value) {\n        return !isAbsent(value) ? value.toUpperCase() : value;\n      }).test({\n        message: message,\n        name: \'string_case\',\n        exclusive: true,\n        skipAbsent: true,\n        test: function test(value) {\n          return isAbsent(value) || value === value.toUpperCase();\n        }\n      });\n    }\n  }]);\n}(Schema);\ncreate$6.prototype = StringSchema.prototype;\n\n//\n// String Interfaces\n//\n\nvar isNaN$1 = function isNaN$1(value) {\n  return value != +value;\n};\nfunction create$5() {\n  return new NumberSchema();\n}\nvar NumberSchema = /*#__PURE__*/function (_Schema4) {\n  function NumberSchema() {\n    var _this9;\n    _classCallCheck(this, NumberSchema);\n    _this9 = _callSuper(this, NumberSchema, [{\n      type: \'number\',\n      check: function check(value) {\n        if (value instanceof Number) value = value.valueOf();\n        return typeof value === \'number\' && !isNaN$1(value);\n      }\n    }]);\n    _this9.withMutation(function () {\n      _this9.transform(function (value, _raw, ctx) {\n        if (!ctx.spec.coerce) return value;\n        var parsed = value;\n        if (typeof parsed === \'string\') {\n          parsed = parsed.replace(/\\s/g, \'\');\n          if (parsed === \'\') return NaN;\n          // don\'t use parseFloat to avoid positives on alpha-numeric strings\n          parsed = +parsed;\n        }\n\n        // null -> NaN isn\'t useful; treat all nulls as null and let it fail on\n        // nullability check vs TypeErrors\n        if (ctx.isType(parsed) || parsed === null) return parsed;\n        return parseFloat(parsed);\n      });\n    });\n    return _this9;\n  }\n  _inherits(NumberSchema, _Schema4);\n  return _createClass(NumberSchema, [{\n    key: "min",\n    value: function min(_min2) {\n      var message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : number.min;\n      return this.test({\n        message: message,\n        name: \'min\',\n        exclusive: true,\n        params: {\n          min: _min2\n        },\n        skipAbsent: true,\n        test: function test(value) {\n          return value >= this.resolve(_min2);\n        }\n      });\n    }\n  }, {\n    key: "max",\n    value: function max(_max2) {\n      var message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : number.max;\n      return this.test({\n        message: message,\n        name: \'max\',\n        exclusive: true,\n        params: {\n          max: _max2\n        },\n        skipAbsent: true,\n        test: function test(value) {\n          return value <= this.resolve(_max2);\n        }\n      });\n    }\n  }, {\n    key: "lessThan",\n    value: function lessThan(less) {\n      var message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : number.lessThan;\n      return this.test({\n        message: message,\n        name: \'max\',\n        exclusive: true,\n        params: {\n          less: less\n        },\n        skipAbsent: true,\n        test: function test(value) {\n          return value < this.resolve(less);\n        }\n      });\n    }\n  }, {\n    key: "moreThan",\n    value: function moreThan(more) {\n      var message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : number.moreThan;\n      return this.test({\n        message: message,\n        name: \'min\',\n        exclusive: true,\n        params: {\n          more: more\n        },\n        skipAbsent: true,\n        test: function test(value) {\n          return value > this.resolve(more);\n        }\n      });\n    }\n  }, {\n    key: "positive",\n    value: function positive() {\n      var msg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : number.positive;\n      return this.moreThan(0, msg);\n    }\n  }, {\n    key: "negative",\n    value: function negative() {\n      var msg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : number.negative;\n      return this.lessThan(0, msg);\n    }\n  }, {\n    key: "integer",\n    value: function integer() {\n      var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : number.integer;\n      return this.test({\n        name: \'integer\',\n        message: message,\n        skipAbsent: true,\n        test: function test(val) {\n          return Number.isInteger(val);\n        }\n      });\n    }\n  }, {\n    key: "truncate",\n    value: function truncate() {\n      return this.transform(function (value) {\n        return !isAbsent(value) ? value | 0 : value;\n      });\n    }\n  }, {\n    key: "round",\n    value: function round(method) {\n      var _method;\n      var avail = [\'ceil\', \'floor\', \'round\', \'trunc\'];\n      method = ((_method = method) == null ? void 0 : _method.toLowerCase()) || \'round\';\n\n      // this exists for symemtry with the new Math.trunc\n      if (method === \'trunc\') return this.truncate();\n      if (avail.indexOf(method.toLowerCase()) === -1) throw new TypeError(\'Only valid options for round() are: \' + avail.join(\', \'));\n      return this.transform(function (value) {\n        return !isAbsent(value) ? Math[method](value) : value;\n      });\n    }\n  }]);\n}(Schema);\ncreate$5.prototype = NumberSchema.prototype;\n\n//\n// Number Interfaces\n//\n\nvar invalidDate = new Date(\'\');\nvar isDate = function isDate(obj) {\n  return Object.prototype.toString.call(obj) === \'[object Date]\';\n};\nfunction create$4() {\n  return new DateSchema();\n}\nvar DateSchema = /*#__PURE__*/function (_Schema5) {\n  function DateSchema() {\n    var _this10;\n    _classCallCheck(this, DateSchema);\n    _this10 = _callSuper(this, DateSchema, [{\n      type: \'date\',\n      check: function check(v) {\n        return isDate(v) && !isNaN(v.getTime());\n      }\n    }]);\n    _this10.withMutation(function () {\n      _this10.transform(function (value, _raw, ctx) {\n        // null -> InvalidDate isn\'t useful; treat all nulls as null and let it fail on\n        // nullability check vs TypeErrors\n        if (!ctx.spec.coerce || ctx.isType(value) || value === null) return value;\n        value = parseIsoDate(value);\n\n        // 0 is a valid timestamp equivalent to 1970-01-01T00:00:00Z(unix epoch) or before.\n        return !isNaN(value) ? new Date(value) : DateSchema.INVALID_DATE;\n      });\n    });\n    return _this10;\n  }\n  _inherits(DateSchema, _Schema5);\n  return _createClass(DateSchema, [{\n    key: "prepareParam",\n    value: function prepareParam(ref, name) {\n      var param;\n      if (!Reference.isRef(ref)) {\n        var cast = this.cast(ref);\n        if (!this._typeCheck(cast)) throw new TypeError("`".concat(name, "` must be a Date or a value that can be `cast()` to a Date"));\n        param = cast;\n      } else {\n        param = ref;\n      }\n      return param;\n    }\n  }, {\n    key: "min",\n    value: function min(_min3) {\n      var message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : date.min;\n      var limit = this.prepareParam(_min3, \'min\');\n      return this.test({\n        message: message,\n        name: \'min\',\n        exclusive: true,\n        params: {\n          min: _min3\n        },\n        skipAbsent: true,\n        test: function test(value) {\n          return value >= this.resolve(limit);\n        }\n      });\n    }\n  }, {\n    key: "max",\n    value: function max(_max3) {\n      var message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : date.max;\n      var limit = this.prepareParam(_max3, \'max\');\n      return this.test({\n        message: message,\n        name: \'max\',\n        exclusive: true,\n        params: {\n          max: _max3\n        },\n        skipAbsent: true,\n        test: function test(value) {\n          return value <= this.resolve(limit);\n        }\n      });\n    }\n  }]);\n}(Schema);\nDateSchema.INVALID_DATE = invalidDate;\ncreate$4.prototype = DateSchema.prototype;\ncreate$4.INVALID_DATE = invalidDate;\n\n// @ts-expect-error\nfunction sortFields(fields) {\n  var excludedEdges = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var edges = [];\n  var nodes = new Set();\n  var excludes = new Set(excludedEdges.map(function (_ref4) {\n    var _ref5 = _slicedToArray(_ref4, 2),\n      a = _ref5[0],\n      b = _ref5[1];\n    return "".concat(a, "-").concat(b);\n  }));\n  function addNode(depPath, key) {\n    var node = (0,property_expr__WEBPACK_IMPORTED_MODULE_0__.split)(depPath)[0];\n    nodes.add(node);\n    if (!excludes.has("".concat(key, "-").concat(node))) edges.push([key, node]);\n  }\n  var _loop2 = function _loop2() {\n    var key = _Object$keys2[_i7];\n    var value = fields[key];\n    nodes.add(key);\n    if (Reference.isRef(value) && value.isSibling) addNode(value.path, key);else if (isSchema(value) && \'deps\' in value) value.deps.forEach(function (path) {\n      return addNode(path, key);\n    });\n  };\n  for (var _i7 = 0, _Object$keys2 = Object.keys(fields); _i7 < _Object$keys2.length; _i7++) {\n    _loop2();\n  }\n  return toposort__WEBPACK_IMPORTED_MODULE_2___default().array(Array.from(nodes), edges).reverse();\n}\nfunction findIndex(arr, err) {\n  var idx = Infinity;\n  arr.some(function (key, ii) {\n    var _err$path;\n    if ((_err$path = err.path) != null && _err$path.includes(key)) {\n      idx = ii;\n      return true;\n    }\n  });\n  return idx;\n}\nfunction sortByKeyOrder(keys) {\n  return function (a, b) {\n    return findIndex(keys, a) - findIndex(keys, b);\n  };\n}\nvar parseJson = function parseJson(value, _, ctx) {\n  if (typeof value !== \'string\') {\n    return value;\n  }\n  var parsed = value;\n  try {\n    parsed = JSON.parse(value);\n  } catch (err) {\n    /* */\n  }\n  return ctx.isType(parsed) ? parsed : value;\n};\n\n// @ts-ignore\nfunction _deepPartial(schema) {\n  if (\'fields\' in schema) {\n    var partial = {};\n    for (var _i8 = 0, _Object$entries2 = Object.entries(schema.fields); _i8 < _Object$entries2.length; _i8++) {\n      var _Object$entries2$_i = _slicedToArray(_Object$entries2[_i8], 2),\n        key = _Object$entries2$_i[0],\n        fieldSchema = _Object$entries2$_i[1];\n      partial[key] = _deepPartial(fieldSchema);\n    }\n    return schema.setFields(partial);\n  }\n  if (schema.type === \'array\') {\n    var nextArray = schema.optional();\n    if (nextArray.innerType) nextArray.innerType = _deepPartial(nextArray.innerType);\n    return nextArray;\n  }\n  if (schema.type === \'tuple\') {\n    return schema.optional().clone({\n      types: schema.spec.types.map(_deepPartial)\n    });\n  }\n  if (\'optional\' in schema) {\n    return schema.optional();\n  }\n  return schema;\n}\nvar deepHas = function deepHas(obj, p) {\n  var path = _toConsumableArray((0,property_expr__WEBPACK_IMPORTED_MODULE_0__.normalizePath)(p));\n  if (path.length === 1) return path[0] in obj;\n  var last = path.pop();\n  var parent = (0,property_expr__WEBPACK_IMPORTED_MODULE_0__.getter)((0,property_expr__WEBPACK_IMPORTED_MODULE_0__.join)(path), true)(obj);\n  return !!(parent && last in parent);\n};\nvar isObject = function isObject(obj) {\n  return Object.prototype.toString.call(obj) === \'[object Object]\';\n};\nfunction unknown(ctx, value) {\n  var known = Object.keys(ctx.fields);\n  return Object.keys(value).filter(function (key) {\n    return known.indexOf(key) === -1;\n  });\n}\nvar defaultSort = sortByKeyOrder([]);\nfunction create$3(spec) {\n  return new ObjectSchema(spec);\n}\nvar ObjectSchema = /*#__PURE__*/function (_Schema6) {\n  function ObjectSchema(spec) {\n    var _this11;\n    _classCallCheck(this, ObjectSchema);\n    _this11 = _callSuper(this, ObjectSchema, [{\n      type: \'object\',\n      check: function check(value) {\n        return isObject(value) || typeof value === \'function\';\n      }\n    }]);\n    _this11.fields = Object.create(null);\n    _this11._sortErrors = defaultSort;\n    _this11._nodes = [];\n    _this11._excludedEdges = [];\n    _this11.withMutation(function () {\n      if (spec) {\n        _this11.shape(spec);\n      }\n    });\n    return _this11;\n  }\n  _inherits(ObjectSchema, _Schema6);\n  return _createClass(ObjectSchema, [{\n    key: "_cast",\n    value: function _cast(_value) {\n      var _this12 = this;\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var _options$stripUnknown;\n      var value = _superPropGet(ObjectSchema, "_cast", this, 3)([_value, options]);\n\n      //should ignore nulls here\n      if (value === undefined) return this.getDefault(options);\n      if (!this._typeCheck(value)) return value;\n      var fields = this.fields;\n      var strip = (_options$stripUnknown = options.stripUnknown) != null ? _options$stripUnknown : this.spec.noUnknown;\n      var props = [].concat(this._nodes, Object.keys(value).filter(function (v) {\n        return !_this12._nodes.includes(v);\n      }));\n      var intermediateValue = {}; // is filled during the transform below\n      var innerOptions = Object.assign({}, options, {\n        parent: intermediateValue,\n        __validating: options.__validating || false\n      });\n      var isChanged = false;\n      var _iterator5 = _createForOfIteratorHelper(props),\n        _step5;\n      try {\n        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n          var prop = _step5.value;\n          var field = fields[prop];\n          var exists = prop in value;\n          if (field) {\n            var fieldValue = void 0;\n            var inputValue = value[prop];\n\n            // safe to mutate since this is fired in sequence\n            innerOptions.path = (options.path ? "".concat(options.path, ".") : \'\') + prop;\n            field = field.resolve({\n              value: inputValue,\n              context: options.context,\n              parent: intermediateValue\n            });\n            var fieldSpec = field instanceof Schema ? field.spec : undefined;\n            var strict = fieldSpec == null ? void 0 : fieldSpec.strict;\n            if (fieldSpec != null && fieldSpec.strip) {\n              isChanged = isChanged || prop in value;\n              continue;\n            }\n            fieldValue = !options.__validating || !strict ?\n            // TODO: use _cast, this is double resolving\n            field.cast(value[prop], innerOptions) : value[prop];\n            if (fieldValue !== undefined) {\n              intermediateValue[prop] = fieldValue;\n            }\n          } else if (exists && !strip) {\n            intermediateValue[prop] = value[prop];\n          }\n          if (exists !== prop in intermediateValue || intermediateValue[prop] !== value[prop]) {\n            isChanged = true;\n          }\n        }\n      } catch (err) {\n        _iterator5.e(err);\n      } finally {\n        _iterator5.f();\n      }\n      return isChanged ? intermediateValue : value;\n    }\n  }, {\n    key: "_validate",\n    value: function _validate(_value) {\n      var _this13 = this;\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var panic = arguments.length > 2 ? arguments[2] : undefined;\n      var next = arguments.length > 3 ? arguments[3] : undefined;\n      var _options$from = options.from,\n        from = _options$from === void 0 ? [] : _options$from,\n        _options$originalValu4 = options.originalValue,\n        originalValue = _options$originalValu4 === void 0 ? _value : _options$originalValu4,\n        _options$recursive2 = options.recursive,\n        recursive = _options$recursive2 === void 0 ? this.spec.recursive : _options$recursive2;\n      options.from = [{\n        schema: this,\n        value: originalValue\n      }].concat(_toConsumableArray(from));\n      // this flag is needed for handling `strict` correctly in the context of\n      // validation vs just casting. e.g strict() on a field is only used when validating\n      options.__validating = true;\n      options.originalValue = originalValue;\n      _superPropGet(ObjectSchema, "_validate", this, 3)([_value, options, panic, function (objectErrors, value) {\n        if (!recursive || !isObject(value)) {\n          next(objectErrors, value);\n          return;\n        }\n        originalValue = originalValue || value;\n        var tests = [];\n        var _iterator6 = _createForOfIteratorHelper(_this13._nodes),\n          _step6;\n        try {\n          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n            var key = _step6.value;\n            var field = _this13.fields[key];\n            if (!field || Reference.isRef(field)) {\n              continue;\n            }\n            tests.push(field.asNestedTest({\n              options: options,\n              key: key,\n              parent: value,\n              parentPath: options.path,\n              originalParent: originalValue\n            }));\n          }\n        } catch (err) {\n          _iterator6.e(err);\n        } finally {\n          _iterator6.f();\n        }\n        _this13.runTests({\n          tests: tests,\n          value: value,\n          originalValue: originalValue,\n          options: options\n        }, panic, function (fieldErrors) {\n          next(fieldErrors.sort(_this13._sortErrors).concat(objectErrors), value);\n        });\n      }]);\n    }\n  }, {\n    key: "clone",\n    value: function clone(spec) {\n      var next = _superPropGet(ObjectSchema, "clone", this, 3)([spec]);\n      next.fields = Object.assign({}, this.fields);\n      next._nodes = this._nodes;\n      next._excludedEdges = this._excludedEdges;\n      next._sortErrors = this._sortErrors;\n      return next;\n    }\n  }, {\n    key: "concat",\n    value: function concat(schema) {\n      var _this14 = this;\n      var next = _superPropGet(ObjectSchema, "concat", this, 3)([schema]);\n      var nextFields = next.fields;\n      for (var _i9 = 0, _Object$entries3 = Object.entries(this.fields); _i9 < _Object$entries3.length; _i9++) {\n        var _Object$entries3$_i = _slicedToArray(_Object$entries3[_i9], 2),\n          field = _Object$entries3$_i[0],\n          schemaOrRef = _Object$entries3$_i[1];\n        var target = nextFields[field];\n        nextFields[field] = target === undefined ? schemaOrRef : target;\n      }\n      return next.withMutation(function (s) {\n        return (\n          // XXX: excludes here is wrong\n          s.setFields(nextFields, [].concat(_toConsumableArray(_this14._excludedEdges), _toConsumableArray(schema._excludedEdges)))\n        );\n      });\n    }\n  }, {\n    key: "_getDefault",\n    value: function _getDefault(options) {\n      var _this15 = this;\n      if (\'default\' in this.spec) {\n        return _superPropGet(ObjectSchema, "_getDefault", this, 3)([options]);\n      }\n\n      // if there is no default set invent one\n      if (!this._nodes.length) {\n        return undefined;\n      }\n      var dft = {};\n      this._nodes.forEach(function (key) {\n        var _innerOptions;\n        var field = _this15.fields[key];\n        var innerOptions = options;\n        if ((_innerOptions = innerOptions) != null && _innerOptions.value) {\n          innerOptions = Object.assign({}, innerOptions, {\n            parent: innerOptions.value,\n            value: innerOptions.value[key]\n          });\n        }\n        dft[key] = field && \'getDefault\' in field ? field.getDefault(innerOptions) : undefined;\n      });\n      return dft;\n    }\n  }, {\n    key: "setFields",\n    value: function setFields(shape, excludedEdges) {\n      var next = this.clone();\n      next.fields = shape;\n      next._nodes = sortFields(shape, excludedEdges);\n      next._sortErrors = sortByKeyOrder(Object.keys(shape));\n      // XXX: this carries over edges which may not be what you want\n      if (excludedEdges) next._excludedEdges = excludedEdges;\n      return next;\n    }\n  }, {\n    key: "shape",\n    value: function shape(additions) {\n      var excludes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n      return this.clone().withMutation(function (next) {\n        var edges = next._excludedEdges;\n        if (excludes.length) {\n          if (!Array.isArray(excludes[0])) excludes = [excludes];\n          edges = [].concat(_toConsumableArray(next._excludedEdges), _toConsumableArray(excludes));\n        }\n\n        // XXX: excludes here is wrong\n        return next.setFields(Object.assign(next.fields, additions), edges);\n      });\n    }\n  }, {\n    key: "partial",\n    value: function partial() {\n      var partial = {};\n      for (var _i10 = 0, _Object$entries4 = Object.entries(this.fields); _i10 < _Object$entries4.length; _i10++) {\n        var _Object$entries4$_i = _slicedToArray(_Object$entries4[_i10], 2),\n          key = _Object$entries4$_i[0],\n          schema = _Object$entries4$_i[1];\n        partial[key] = \'optional\' in schema && schema.optional instanceof Function ? schema.optional() : schema;\n      }\n      return this.setFields(partial);\n    }\n  }, {\n    key: "deepPartial",\n    value: function deepPartial() {\n      var next = _deepPartial(this);\n      return next;\n    }\n  }, {\n    key: "pick",\n    value: function pick(keys) {\n      var picked = {};\n      var _iterator7 = _createForOfIteratorHelper(keys),\n        _step7;\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var key = _step7.value;\n          if (this.fields[key]) picked[key] = this.fields[key];\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n      return this.setFields(picked, this._excludedEdges.filter(function (_ref6) {\n        var _ref7 = _slicedToArray(_ref6, 2),\n          a = _ref7[0],\n          b = _ref7[1];\n        return keys.includes(a) && keys.includes(b);\n      }));\n    }\n  }, {\n    key: "omit",\n    value: function omit(keys) {\n      var remaining = [];\n      for (var _i11 = 0, _Object$keys3 = Object.keys(this.fields); _i11 < _Object$keys3.length; _i11++) {\n        var key = _Object$keys3[_i11];\n        if (keys.includes(key)) continue;\n        remaining.push(key);\n      }\n      return this.pick(remaining);\n    }\n  }, {\n    key: "from",\n    value: function from(_from, to, alias) {\n      var fromGetter = (0,property_expr__WEBPACK_IMPORTED_MODULE_0__.getter)(_from, true);\n      return this.transform(function (obj) {\n        if (!obj) return obj;\n        var newObj = obj;\n        if (deepHas(obj, _from)) {\n          newObj = Object.assign({}, obj);\n          if (!alias) delete newObj[_from];\n          newObj[to] = fromGetter(obj);\n        }\n        return newObj;\n      });\n    }\n\n    /** Parse an input JSON string to an object */\n  }, {\n    key: "json",\n    value: function json() {\n      return this.transform(parseJson);\n    }\n  }, {\n    key: "noUnknown",\n    value: function noUnknown() {\n      var noAllow = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      var message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : object.noUnknown;\n      if (typeof noAllow !== \'boolean\') {\n        message = noAllow;\n        noAllow = true;\n      }\n      var next = this.test({\n        name: \'noUnknown\',\n        exclusive: true,\n        message: message,\n        test: function test(value) {\n          if (value == null) return true;\n          var unknownKeys = unknown(this.schema, value);\n          return !noAllow || unknownKeys.length === 0 || this.createError({\n            params: {\n              unknown: unknownKeys.join(\', \')\n            }\n          });\n        }\n      });\n      next.spec.noUnknown = noAllow;\n      return next;\n    }\n  }, {\n    key: "unknown",\n    value: function unknown() {\n      var allow = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      var message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : object.noUnknown;\n      return this.noUnknown(!allow, message);\n    }\n  }, {\n    key: "transformKeys",\n    value: function transformKeys(fn) {\n      return this.transform(function (obj) {\n        if (!obj) return obj;\n        var result = {};\n        for (var _i12 = 0, _Object$keys4 = Object.keys(obj); _i12 < _Object$keys4.length; _i12++) {\n          var key = _Object$keys4[_i12];\n          result[fn(key)] = obj[key];\n        }\n        return result;\n      });\n    }\n  }, {\n    key: "camelCase",\n    value: function camelCase() {\n      return this.transformKeys(tiny_case__WEBPACK_IMPORTED_MODULE_1__.camelCase);\n    }\n  }, {\n    key: "snakeCase",\n    value: function snakeCase() {\n      return this.transformKeys(tiny_case__WEBPACK_IMPORTED_MODULE_1__.snakeCase);\n    }\n  }, {\n    key: "constantCase",\n    value: function constantCase() {\n      return this.transformKeys(function (key) {\n        return (0,tiny_case__WEBPACK_IMPORTED_MODULE_1__.snakeCase)(key).toUpperCase();\n      });\n    }\n  }, {\n    key: "describe",\n    value: function describe(options) {\n      var next = (options ? this.resolve(options) : this).clone();\n      var base = _superPropGet(ObjectSchema, "describe", this, 3)([options]);\n      base.fields = {};\n      for (var _i13 = 0, _Object$entries5 = Object.entries(next.fields); _i13 < _Object$entries5.length; _i13++) {\n        var _Object$entries5$_i = _slicedToArray(_Object$entries5[_i13], 2),\n          key = _Object$entries5$_i[0],\n          value = _Object$entries5$_i[1];\n        var _innerOptions2;\n        var innerOptions = options;\n        if ((_innerOptions2 = innerOptions) != null && _innerOptions2.value) {\n          innerOptions = Object.assign({}, innerOptions, {\n            parent: innerOptions.value,\n            value: innerOptions.value[key]\n          });\n        }\n        base.fields[key] = value.describe(innerOptions);\n      }\n      return base;\n    }\n  }]);\n}(Schema);\ncreate$3.prototype = ObjectSchema.prototype;\nfunction create$2(type) {\n  return new ArraySchema(type);\n}\nvar ArraySchema = /*#__PURE__*/function (_Schema7) {\n  function ArraySchema(type) {\n    var _this16;\n    _classCallCheck(this, ArraySchema);\n    _this16 = _callSuper(this, ArraySchema, [{\n      type: \'array\',\n      spec: {\n        types: type\n      },\n      check: function check(v) {\n        return Array.isArray(v);\n      }\n    }]);\n\n    // `undefined` specifically means uninitialized, as opposed to "no subtype"\n    _this16.innerType = void 0;\n    _this16.innerType = type;\n    return _this16;\n  }\n  _inherits(ArraySchema, _Schema7);\n  return _createClass(ArraySchema, [{\n    key: "_cast",\n    value: function _cast(_value, _opts) {\n      var _this17 = this;\n      var value = _superPropGet(ArraySchema, "_cast", this, 3)([_value, _opts]);\n\n      // should ignore nulls here\n      if (!this._typeCheck(value) || !this.innerType) {\n        return value;\n      }\n      var isChanged = false;\n      var castArray = value.map(function (v, idx) {\n        var castElement = _this17.innerType.cast(v, Object.assign({}, _opts, {\n          path: "".concat(_opts.path || \'\', "[").concat(idx, "]")\n        }));\n        if (castElement !== v) {\n          isChanged = true;\n        }\n        return castElement;\n      });\n      return isChanged ? castArray : value;\n    }\n  }, {\n    key: "_validate",\n    value: function _validate(_value) {\n      var _this18 = this;\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var panic = arguments.length > 2 ? arguments[2] : undefined;\n      var next = arguments.length > 3 ? arguments[3] : undefined;\n      var _options$recursive;\n      // let sync = options.sync;\n      // let path = options.path;\n      var innerType = this.innerType;\n      // let endEarly = options.abortEarly ?? this.spec.abortEarly;\n      var recursive = (_options$recursive = options.recursive) != null ? _options$recursive : this.spec.recursive;\n      options.originalValue != null ? options.originalValue : _value;\n      _superPropGet(ArraySchema, "_validate", this, 3)([_value, options, panic, function (arrayErrors, value) {\n        var _options$originalValu2;\n        if (!recursive || !innerType || !_this18._typeCheck(value)) {\n          next(arrayErrors, value);\n          return;\n        }\n\n        // #950 Ensure that sparse array empty slots are validated\n        var tests = new Array(value.length);\n        for (var index = 0; index < value.length; index++) {\n          var _options$originalValu;\n          tests[index] = innerType.asNestedTest({\n            options: options,\n            index: index,\n            parent: value,\n            parentPath: options.path,\n            originalParent: (_options$originalValu = options.originalValue) != null ? _options$originalValu : _value\n          });\n        }\n        _this18.runTests({\n          value: value,\n          tests: tests,\n          originalValue: (_options$originalValu2 = options.originalValue) != null ? _options$originalValu2 : _value,\n          options: options\n        }, panic, function (innerTypeErrors) {\n          return next(innerTypeErrors.concat(arrayErrors), value);\n        });\n      }]);\n    }\n  }, {\n    key: "clone",\n    value: function clone(spec) {\n      var next = _superPropGet(ArraySchema, "clone", this, 3)([spec]);\n      // @ts-expect-error readonly\n      next.innerType = this.innerType;\n      return next;\n    }\n\n    /** Parse an input JSON string to an object */\n  }, {\n    key: "json",\n    value: function json() {\n      return this.transform(parseJson);\n    }\n  }, {\n    key: "concat",\n    value: function concat(schema) {\n      var next = _superPropGet(ArraySchema, "concat", this, 3)([schema]);\n\n      // @ts-expect-error readonly\n      next.innerType = this.innerType;\n      if (schema.innerType)\n        // @ts-expect-error readonly\n        next.innerType = next.innerType ?\n        // @ts-expect-error Lazy doesn\'t have concat and will break\n        next.innerType.concat(schema.innerType) : schema.innerType;\n      return next;\n    }\n  }, {\n    key: "of",\n    value: function of(schema) {\n      // FIXME: this should return a new instance of array without the default to be\n      var next = this.clone();\n      if (!isSchema(schema)) throw new TypeError(\'`array.of()` sub-schema must be a valid yup schema not: \' + printValue(schema));\n\n      // @ts-expect-error readonly\n      next.innerType = schema;\n      next.spec = Object.assign({}, next.spec, {\n        types: schema\n      });\n      return next;\n    }\n  }, {\n    key: "length",\n    value: function length(_length2) {\n      var message = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : array.length;\n      return this.test({\n        message: message,\n        name: \'length\',\n        exclusive: true,\n        params: {\n          length: _length2\n        },\n        skipAbsent: true,\n        test: function test(value) {\n          return value.length === this.resolve(_length2);\n        }\n      });\n    }\n  }, {\n    key: "min",\n    value: function min(_min4, message) {\n      message = message || array.min;\n      return this.test({\n        message: message,\n        name: \'min\',\n        exclusive: true,\n        params: {\n          min: _min4\n        },\n        skipAbsent: true,\n        // FIXME(ts): Array<typeof T>\n        test: function test(value) {\n          return value.length >= this.resolve(_min4);\n        }\n      });\n    }\n  }, {\n    key: "max",\n    value: function max(_max4, message) {\n      message = message || array.max;\n      return this.test({\n        message: message,\n        name: \'max\',\n        exclusive: true,\n        params: {\n          max: _max4\n        },\n        skipAbsent: true,\n        test: function test(value) {\n          return value.length <= this.resolve(_max4);\n        }\n      });\n    }\n  }, {\n    key: "ensure",\n    value: function ensure() {\n      var _this19 = this;\n      return this.default(function () {\n        return [];\n      }).transform(function (val, original) {\n        // We don\'t want to return `null` for nullable schema\n        if (_this19._typeCheck(val)) return val;\n        return original == null ? [] : [].concat(original);\n      });\n    }\n  }, {\n    key: "compact",\n    value: function compact(rejector) {\n      var reject = !rejector ? function (v) {\n        return !!v;\n      } : function (v, i, a) {\n        return !rejector(v, i, a);\n      };\n      return this.transform(function (values) {\n        return values != null ? values.filter(reject) : values;\n      });\n    }\n  }, {\n    key: "describe",\n    value: function describe(options) {\n      var next = (options ? this.resolve(options) : this).clone();\n      var base = _superPropGet(ArraySchema, "describe", this, 3)([options]);\n      if (next.innerType) {\n        var _innerOptions;\n        var innerOptions = options;\n        if ((_innerOptions = innerOptions) != null && _innerOptions.value) {\n          innerOptions = Object.assign({}, innerOptions, {\n            parent: innerOptions.value,\n            value: innerOptions.value[0]\n          });\n        }\n        base.innerType = next.innerType.describe(innerOptions);\n      }\n      return base;\n    }\n  }]);\n}(Schema);\ncreate$2.prototype = ArraySchema.prototype;\n\n// @ts-ignore\nfunction create$1(schemas) {\n  return new TupleSchema(schemas);\n}\nvar TupleSchema = /*#__PURE__*/function (_Schema8) {\n  function TupleSchema(schemas) {\n    var _this20;\n    _classCallCheck(this, TupleSchema);\n    _this20 = _callSuper(this, TupleSchema, [{\n      type: \'tuple\',\n      spec: {\n        types: schemas\n      },\n      check: function check(v) {\n        var types = this.spec.types;\n        return Array.isArray(v) && v.length === types.length;\n      }\n    }]);\n    _this20.withMutation(function () {\n      _this20.typeError(tuple.notType);\n    });\n    return _this20;\n  }\n  _inherits(TupleSchema, _Schema8);\n  return _createClass(TupleSchema, [{\n    key: "_cast",\n    value: function _cast(inputValue, options) {\n      var types = this.spec.types;\n      var value = _superPropGet(TupleSchema, "_cast", this, 3)([inputValue, options]);\n      if (!this._typeCheck(value)) {\n        return value;\n      }\n      var isChanged = false;\n      var castArray = types.map(function (type, idx) {\n        var castElement = type.cast(value[idx], Object.assign({}, options, {\n          path: "".concat(options.path || \'\', "[").concat(idx, "]")\n        }));\n        if (castElement !== value[idx]) isChanged = true;\n        return castElement;\n      });\n      return isChanged ? castArray : value;\n    }\n  }, {\n    key: "_validate",\n    value: function _validate(_value) {\n      var _this21 = this;\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var panic = arguments.length > 2 ? arguments[2] : undefined;\n      var next = arguments.length > 3 ? arguments[3] : undefined;\n      var itemTypes = this.spec.types;\n      _superPropGet(TupleSchema, "_validate", this, 3)([_value, options, panic, function (tupleErrors, value) {\n        var _options$originalValu2;\n        // intentionally not respecting recursive\n        if (!_this21._typeCheck(value)) {\n          next(tupleErrors, value);\n          return;\n        }\n        var tests = [];\n        var _iterator8 = _createForOfIteratorHelper(itemTypes.entries()),\n          _step8;\n        try {\n          for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n            var _step8$value = _slicedToArray(_step8.value, 2),\n              index = _step8$value[0],\n              itemSchema = _step8$value[1];\n            var _options$originalValu;\n            tests[index] = itemSchema.asNestedTest({\n              options: options,\n              index: index,\n              parent: value,\n              parentPath: options.path,\n              originalParent: (_options$originalValu = options.originalValue) != null ? _options$originalValu : _value\n            });\n          }\n        } catch (err) {\n          _iterator8.e(err);\n        } finally {\n          _iterator8.f();\n        }\n        _this21.runTests({\n          value: value,\n          tests: tests,\n          originalValue: (_options$originalValu2 = options.originalValue) != null ? _options$originalValu2 : _value,\n          options: options\n        }, panic, function (innerTypeErrors) {\n          return next(innerTypeErrors.concat(tupleErrors), value);\n        });\n      }]);\n    }\n  }, {\n    key: "describe",\n    value: function describe(options) {\n      var next = (options ? this.resolve(options) : this).clone();\n      var base = _superPropGet(TupleSchema, "describe", this, 3)([options]);\n      base.innerType = next.spec.types.map(function (schema, index) {\n        var _innerOptions;\n        var innerOptions = options;\n        if ((_innerOptions = innerOptions) != null && _innerOptions.value) {\n          innerOptions = Object.assign({}, innerOptions, {\n            parent: innerOptions.value,\n            value: innerOptions.value[index]\n          });\n        }\n        return schema.describe(innerOptions);\n      });\n      return base;\n    }\n  }]);\n}(Schema);\ncreate$1.prototype = TupleSchema.prototype;\nfunction create(builder) {\n  return new Lazy(builder);\n}\nvar Lazy = /*#__PURE__*/(/* unused pure expression or super */ null && (function () {\n  function Lazy(builder) {\n    var _this22 = this;\n    _classCallCheck(this, Lazy);\n    this.type = \'lazy\';\n    this.__isYupSchema__ = true;\n    this.spec = void 0;\n    this._resolve = function (value) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var schema = _this22.builder(value, options);\n      if (!isSchema(schema)) throw new TypeError(\'lazy() functions must return a valid schema\');\n      if (_this22.spec.optional) schema = schema.optional();\n      return schema.resolve(options);\n    };\n    this.builder = builder;\n    this.spec = {\n      meta: undefined,\n      optional: false\n    };\n  }\n  return _createClass(Lazy, [{\n    key: "clone",\n    value: function clone(spec) {\n      var next = new Lazy(this.builder);\n      next.spec = Object.assign({}, this.spec, spec);\n      return next;\n    }\n  }, {\n    key: "optionality",\n    value: function optionality(optional) {\n      var next = this.clone({\n        optional: optional\n      });\n      return next;\n    }\n  }, {\n    key: "optional",\n    value: function optional() {\n      return this.optionality(true);\n    }\n  }, {\n    key: "resolve",\n    value: function resolve(options) {\n      return this._resolve(options.value, options);\n    }\n  }, {\n    key: "cast",\n    value: function cast(value, options) {\n      return this._resolve(value, options).cast(value, options);\n    }\n  }, {\n    key: "asNestedTest",\n    value: function asNestedTest(config) {\n      var key = config.key,\n        index = config.index,\n        parent = config.parent,\n        options = config.options;\n      var value = parent[index != null ? index : key];\n      return this._resolve(value, Object.assign({}, options, {\n        value: value,\n        parent: parent\n      })).asNestedTest(config);\n    }\n  }, {\n    key: "validate",\n    value: function validate(value, options) {\n      return this._resolve(value, options).validate(value, options);\n    }\n  }, {\n    key: "validateSync",\n    value: function validateSync(value, options) {\n      return this._resolve(value, options).validateSync(value, options);\n    }\n  }, {\n    key: "validateAt",\n    value: function validateAt(path, value, options) {\n      return this._resolve(value, options).validateAt(path, value, options);\n    }\n  }, {\n    key: "validateSyncAt",\n    value: function validateSyncAt(path, value, options) {\n      return this._resolve(value, options).validateSyncAt(path, value, options);\n    }\n  }, {\n    key: "isValid",\n    value: function isValid(value, options) {\n      return this._resolve(value, options).isValid(value, options);\n    }\n  }, {\n    key: "isValidSync",\n    value: function isValidSync(value, options) {\n      return this._resolve(value, options).isValidSync(value, options);\n    }\n  }, {\n    key: "describe",\n    value: function describe(options) {\n      return options ? this.resolve(options).describe(options) : {\n        type: \'lazy\',\n        meta: this.spec.meta,\n        label: undefined\n      };\n    }\n  }, {\n    key: "meta",\n    value: function meta() {\n      if (arguments.length === 0) return this.spec.meta;\n      var next = this.clone();\n      next.spec.meta = Object.assign(next.spec.meta || {}, arguments.length <= 0 ? undefined : arguments[0]);\n      return next;\n    }\n  }]);\n}()));\nfunction setLocale(custom) {\n  Object.keys(custom).forEach(function (type) {\n    // @ts-ignore\n    Object.keys(custom[type]).forEach(function (method) {\n      // @ts-ignore\n      locale[type][method] = custom[type][method];\n    });\n  });\n}\nfunction addMethod(schemaType, name, fn) {\n  if (!schemaType || !isSchema(schemaType.prototype)) throw new TypeError(\'You must provide a yup schema constructor function\');\n  if (typeof name !== \'string\') throw new TypeError(\'A Method name must be provided\');\n  if (typeof fn !== \'function\') throw new TypeError(\'Method function must be provided\');\n  schemaType.prototype[name] = fn;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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ZC8uL25vZGVfbW9kdWxlcy95dXAvaW5kZXguZXNtLmpzPzQyZTkiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2V0dGVyLCBmb3JFYWNoLCBzcGxpdCwgbm9ybWFsaXplUGF0aCwgam9pbiB9IGZyb20gJ3Byb3BlcnR5LWV4cHInO1xuaW1wb3J0IHsgY2FtZWxDYXNlLCBzbmFrZUNhc2UgfSBmcm9tICd0aW55LWNhc2UnO1xuaW1wb3J0IHRvcG9zb3J0IGZyb20gJ3RvcG9zb3J0JztcblxuY29uc3QgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuY29uc3QgZXJyb3JUb1N0cmluZyA9IEVycm9yLnByb3RvdHlwZS50b1N0cmluZztcbmNvbnN0IHJlZ0V4cFRvU3RyaW5nID0gUmVnRXhwLnByb3RvdHlwZS50b1N0cmluZztcbmNvbnN0IHN5bWJvbFRvU3RyaW5nID0gdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgPyBTeW1ib2wucHJvdG90eXBlLnRvU3RyaW5nIDogKCkgPT4gJyc7XG5jb25zdCBTWU1CT0xfUkVHRVhQID0gL15TeW1ib2xcXCgoLiopXFwpKC4qKSQvO1xuZnVuY3Rpb24gcHJpbnROdW1iZXIodmFsKSB7XG4gIGlmICh2YWwgIT0gK3ZhbCkgcmV0dXJuICdOYU4nO1xuICBjb25zdCBpc05lZ2F0aXZlWmVybyA9IHZhbCA9PT0gMCAmJiAxIC8gdmFsIDwgMDtcbiAgcmV0dXJuIGlzTmVnYXRpdmVaZXJvID8gJy0wJyA6ICcnICsgdmFsO1xufVxuZnVuY3Rpb24gcHJpbnRTaW1wbGVWYWx1ZSh2YWwsIHF1b3RlU3RyaW5ncyA9IGZhbHNlKSB7XG4gIGlmICh2YWwgPT0gbnVsbCB8fCB2YWwgPT09IHRydWUgfHwgdmFsID09PSBmYWxzZSkgcmV0dXJuICcnICsgdmFsO1xuICBjb25zdCB0eXBlT2YgPSB0eXBlb2YgdmFsO1xuICBpZiAodHlwZU9mID09PSAnbnVtYmVyJykgcmV0dXJuIHByaW50TnVtYmVyKHZhbCk7XG4gIGlmICh0eXBlT2YgPT09ICdzdHJpbmcnKSByZXR1cm4gcXVvdGVTdHJpbmdzID8gYFwiJHt2YWx9XCJgIDogdmFsO1xuICBpZiAodHlwZU9mID09PSAnZnVuY3Rpb24nKSByZXR1cm4gJ1tGdW5jdGlvbiAnICsgKHZhbC5uYW1lIHx8ICdhbm9ueW1vdXMnKSArICddJztcbiAgaWYgKHR5cGVPZiA9PT0gJ3N5bWJvbCcpIHJldHVybiBzeW1ib2xUb1N0cmluZy5jYWxsKHZhbCkucmVwbGFjZShTWU1CT0xfUkVHRVhQLCAnU3ltYm9sKCQxKScpO1xuICBjb25zdCB0YWcgPSB0b1N0cmluZy5jYWxsKHZhbCkuc2xpY2UoOCwgLTEpO1xuICBpZiAodGFnID09PSAnRGF0ZScpIHJldHVybiBpc05hTih2YWwuZ2V0VGltZSgpKSA/ICcnICsgdmFsIDogdmFsLnRvSVNPU3RyaW5nKHZhbCk7XG4gIGlmICh0YWcgPT09ICdFcnJvcicgfHwgdmFsIGluc3RhbmNlb2YgRXJyb3IpIHJldHVybiAnWycgKyBlcnJvclRvU3RyaW5nLmNhbGwodmFsKSArICddJztcbiAgaWYgKHRhZyA9PT0gJ1JlZ0V4cCcpIHJldHVybiByZWdFeHBUb1N0cmluZy5jYWxsKHZhbCk7XG4gIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gcHJpbnRWYWx1ZSh2YWx1ZSwgcXVvdGVTdHJpbmdzKSB7XG4gIGxldCByZXN1bHQgPSBwcmludFNpbXBsZVZhbHVlKHZhbHVlLCBxdW90ZVN0cmluZ3MpO1xuICBpZiAocmVzdWx0ICE9PSBudWxsKSByZXR1cm4gcmVzdWx0O1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUsIGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgbGV0IHJlc3VsdCA9IHByaW50U2ltcGxlVmFsdWUodGhpc1trZXldLCBxdW90ZVN0cmluZ3MpO1xuICAgIGlmIChyZXN1bHQgIT09IG51bGwpIHJldHVybiByZXN1bHQ7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9LCAyKTtcbn1cblxuZnVuY3Rpb24gdG9BcnJheSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/IFtdIDogW10uY29uY2F0KHZhbHVlKTtcbn1cblxubGV0IF9TeW1ib2wkdG9TdHJpbmdUYWcsIF9TeW1ib2wkaGFzSW5zdGFuY2UsIF9TeW1ib2wkdG9TdHJpbmdUYWcyO1xubGV0IHN0clJlZyA9IC9cXCRcXHtcXHMqKFxcdyspXFxzKlxcfS9nO1xuX1N5bWJvbCR0b1N0cmluZ1RhZyA9IFN5bWJvbC50b1N0cmluZ1RhZztcbmNsYXNzIFZhbGlkYXRpb25FcnJvck5vU3RhY2sge1xuICBjb25zdHJ1Y3RvcihlcnJvck9yRXJyb3JzLCB2YWx1ZSwgZmllbGQsIHR5cGUpIHtcbiAgICB0aGlzLm5hbWUgPSB2b2lkIDA7XG4gICAgdGhpcy5tZXNzYWdlID0gdm9pZCAwO1xuICAgIHRoaXMudmFsdWUgPSB2b2lkIDA7XG4gICAgdGhpcy5wYXRoID0gdm9pZCAwO1xuICAgIHRoaXMudHlwZSA9IHZvaWQgMDtcbiAgICB0aGlzLnBhcmFtcyA9IHZvaWQgMDtcbiAgICB0aGlzLmVycm9ycyA9IHZvaWQgMDtcbiAgICB0aGlzLmlubmVyID0gdm9pZCAwO1xuICAgIHRoaXNbX1N5bWJvbCR0b1N0cmluZ1RhZ10gPSAnRXJyb3InO1xuICAgIHRoaXMubmFtZSA9ICdWYWxpZGF0aW9uRXJyb3InO1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLnBhdGggPSBmaWVsZDtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMuZXJyb3JzID0gW107XG4gICAgdGhpcy5pbm5lciA9IFtdO1xuICAgIHRvQXJyYXkoZXJyb3JPckVycm9ycykuZm9yRWFjaChlcnIgPT4ge1xuICAgICAgaWYgKFZhbGlkYXRpb25FcnJvci5pc0Vycm9yKGVycikpIHtcbiAgICAgICAgdGhpcy5lcnJvcnMucHVzaCguLi5lcnIuZXJyb3JzKTtcbiAgICAgICAgY29uc3QgaW5uZXJFcnJvcnMgPSBlcnIuaW5uZXIubGVuZ3RoID8gZXJyLmlubmVyIDogW2Vycl07XG4gICAgICAgIHRoaXMuaW5uZXIucHVzaCguLi5pbm5lckVycm9ycyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmVycm9ycy5wdXNoKGVycik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5tZXNzYWdlID0gdGhpcy5lcnJvcnMubGVuZ3RoID4gMSA/IGAke3RoaXMuZXJyb3JzLmxlbmd0aH0gZXJyb3JzIG9jY3VycmVkYCA6IHRoaXMuZXJyb3JzWzBdO1xuICB9XG59XG5fU3ltYm9sJGhhc0luc3RhbmNlID0gU3ltYm9sLmhhc0luc3RhbmNlO1xuX1N5bWJvbCR0b1N0cmluZ1RhZzIgPSBTeW1ib2wudG9TdHJpbmdUYWc7XG5jbGFzcyBWYWxpZGF0aW9uRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIHN0YXRpYyBmb3JtYXRFcnJvcihtZXNzYWdlLCBwYXJhbXMpIHtcbiAgICBjb25zdCBwYXRoID0gcGFyYW1zLmxhYmVsIHx8IHBhcmFtcy5wYXRoIHx8ICd0aGlzJztcbiAgICBpZiAocGF0aCAhPT0gcGFyYW1zLnBhdGgpIHBhcmFtcyA9IE9iamVjdC5hc3NpZ24oe30sIHBhcmFtcywge1xuICAgICAgcGF0aFxuICAgIH0pO1xuICAgIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycpIHJldHVybiBtZXNzYWdlLnJlcGxhY2Uoc3RyUmVnLCAoXywga2V5KSA9PiBwcmludFZhbHVlKHBhcmFtc1trZXldKSk7XG4gICAgaWYgKHR5cGVvZiBtZXNzYWdlID09PSAnZnVuY3Rpb24nKSByZXR1cm4gbWVzc2FnZShwYXJhbXMpO1xuICAgIHJldHVybiBtZXNzYWdlO1xuICB9XG4gIHN0YXRpYyBpc0Vycm9yKGVycikge1xuICAgIHJldHVybiBlcnIgJiYgZXJyLm5hbWUgPT09ICdWYWxpZGF0aW9uRXJyb3InO1xuICB9XG4gIGNvbnN0cnVjdG9yKGVycm9yT3JFcnJvcnMsIHZhbHVlLCBmaWVsZCwgdHlwZSwgZGlzYWJsZVN0YWNrKSB7XG4gICAgY29uc3QgZXJyb3JOb1N0YWNrID0gbmV3IFZhbGlkYXRpb25FcnJvck5vU3RhY2soZXJyb3JPckVycm9ycywgdmFsdWUsIGZpZWxkLCB0eXBlKTtcbiAgICBpZiAoZGlzYWJsZVN0YWNrKSB7XG4gICAgICByZXR1cm4gZXJyb3JOb1N0YWNrO1xuICAgIH1cbiAgICBzdXBlcigpO1xuICAgIHRoaXMudmFsdWUgPSB2b2lkIDA7XG4gICAgdGhpcy5wYXRoID0gdm9pZCAwO1xuICAgIHRoaXMudHlwZSA9IHZvaWQgMDtcbiAgICB0aGlzLnBhcmFtcyA9IHZvaWQgMDtcbiAgICB0aGlzLmVycm9ycyA9IFtdO1xuICAgIHRoaXMuaW5uZXIgPSBbXTtcbiAgICB0aGlzW19TeW1ib2wkdG9TdHJpbmdUYWcyXSA9ICdFcnJvcic7XG4gICAgdGhpcy5uYW1lID0gZXJyb3JOb1N0YWNrLm5hbWU7XG4gICAgdGhpcy5tZXNzYWdlID0gZXJyb3JOb1N0YWNrLm1lc3NhZ2U7XG4gICAgdGhpcy50eXBlID0gZXJyb3JOb1N0YWNrLnR5cGU7XG4gICAgdGhpcy52YWx1ZSA9IGVycm9yTm9TdGFjay52YWx1ZTtcbiAgICB0aGlzLnBhdGggPSBlcnJvck5vU3RhY2sucGF0aDtcbiAgICB0aGlzLmVycm9ycyA9IGVycm9yTm9TdGFjay5lcnJvcnM7XG4gICAgdGhpcy5pbm5lciA9IGVycm9yTm9TdGFjay5pbm5lcjtcbiAgICBpZiAoRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UpIHtcbiAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKHRoaXMsIFZhbGlkYXRpb25FcnJvcik7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBbX1N5bWJvbCRoYXNJbnN0YW5jZV0oaW5zdCkge1xuICAgIHJldHVybiBWYWxpZGF0aW9uRXJyb3JOb1N0YWNrW1N5bWJvbC5oYXNJbnN0YW5jZV0oaW5zdCkgfHwgc3VwZXJbU3ltYm9sLmhhc0luc3RhbmNlXShpbnN0KTtcbiAgfVxufVxuXG5sZXQgbWl4ZWQgPSB7XG4gIGRlZmF1bHQ6ICcke3BhdGh9IGlzIGludmFsaWQnLFxuICByZXF1aXJlZDogJyR7cGF0aH0gaXMgYSByZXF1aXJlZCBmaWVsZCcsXG4gIGRlZmluZWQ6ICcke3BhdGh9IG11c3QgYmUgZGVmaW5lZCcsXG4gIG5vdE51bGw6ICcke3BhdGh9IGNhbm5vdCBiZSBudWxsJyxcbiAgb25lT2Y6ICcke3BhdGh9IG11c3QgYmUgb25lIG9mIHRoZSBmb2xsb3dpbmcgdmFsdWVzOiAke3ZhbHVlc30nLFxuICBub3RPbmVPZjogJyR7cGF0aH0gbXVzdCBub3QgYmUgb25lIG9mIHRoZSBmb2xsb3dpbmcgdmFsdWVzOiAke3ZhbHVlc30nLFxuICBub3RUeXBlOiAoe1xuICAgIHBhdGgsXG4gICAgdHlwZSxcbiAgICB2YWx1ZSxcbiAgICBvcmlnaW5hbFZhbHVlXG4gIH0pID0+IHtcbiAgICBjb25zdCBjYXN0TXNnID0gb3JpZ2luYWxWYWx1ZSAhPSBudWxsICYmIG9yaWdpbmFsVmFsdWUgIT09IHZhbHVlID8gYCAoY2FzdCBmcm9tIHRoZSB2YWx1ZSBcXGAke3ByaW50VmFsdWUob3JpZ2luYWxWYWx1ZSwgdHJ1ZSl9XFxgKS5gIDogJy4nO1xuICAgIHJldHVybiB0eXBlICE9PSAnbWl4ZWQnID8gYCR7cGF0aH0gbXVzdCBiZSBhIFxcYCR7dHlwZX1cXGAgdHlwZSwgYCArIGBidXQgdGhlIGZpbmFsIHZhbHVlIHdhczogXFxgJHtwcmludFZhbHVlKHZhbHVlLCB0cnVlKX1cXGBgICsgY2FzdE1zZyA6IGAke3BhdGh9IG11c3QgbWF0Y2ggdGhlIGNvbmZpZ3VyZWQgdHlwZS4gYCArIGBUaGUgdmFsaWRhdGVkIHZhbHVlIHdhczogXFxgJHtwcmludFZhbHVlKHZhbHVlLCB0cnVlKX1cXGBgICsgY2FzdE1zZztcbiAgfVxufTtcbmxldCBzdHJpbmcgPSB7XG4gIGxlbmd0aDogJyR7cGF0aH0gbXVzdCBiZSBleGFjdGx5ICR7bGVuZ3RofSBjaGFyYWN0ZXJzJyxcbiAgbWluOiAnJHtwYXRofSBtdXN0IGJlIGF0IGxlYXN0ICR7bWlufSBjaGFyYWN0ZXJzJyxcbiAgbWF4OiAnJHtwYXRofSBtdXN0IGJlIGF0IG1vc3QgJHttYXh9IGNoYXJhY3RlcnMnLFxuICBtYXRjaGVzOiAnJHtwYXRofSBtdXN0IG1hdGNoIHRoZSBmb2xsb3dpbmc6IFwiJHtyZWdleH1cIicsXG4gIGVtYWlsOiAnJHtwYXRofSBtdXN0IGJlIGEgdmFsaWQgZW1haWwnLFxuICB1cmw6ICcke3BhdGh9IG11c3QgYmUgYSB2YWxpZCBVUkwnLFxuICB1dWlkOiAnJHtwYXRofSBtdXN0IGJlIGEgdmFsaWQgVVVJRCcsXG4gIGRhdGV0aW1lOiAnJHtwYXRofSBtdXN0IGJlIGEgdmFsaWQgSVNPIGRhdGUtdGltZScsXG4gIGRhdGV0aW1lX3ByZWNpc2lvbjogJyR7cGF0aH0gbXVzdCBiZSBhIHZhbGlkIElTTyBkYXRlLXRpbWUgd2l0aCBhIHN1Yi1zZWNvbmQgcHJlY2lzaW9uIG9mIGV4YWN0bHkgJHtwcmVjaXNpb259IGRpZ2l0cycsXG4gIGRhdGV0aW1lX29mZnNldDogJyR7cGF0aH0gbXVzdCBiZSBhIHZhbGlkIElTTyBkYXRlLXRpbWUgd2l0aCBVVEMgXCJaXCIgdGltZXpvbmUnLFxuICB0cmltOiAnJHtwYXRofSBtdXN0IGJlIGEgdHJpbW1lZCBzdHJpbmcnLFxuICBsb3dlcmNhc2U6ICcke3BhdGh9IG11c3QgYmUgYSBsb3dlcmNhc2Ugc3RyaW5nJyxcbiAgdXBwZXJjYXNlOiAnJHtwYXRofSBtdXN0IGJlIGEgdXBwZXIgY2FzZSBzdHJpbmcnXG59O1xubGV0IG51bWJlciA9IHtcbiAgbWluOiAnJHtwYXRofSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byAke21pbn0nLFxuICBtYXg6ICcke3BhdGh9IG11c3QgYmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvICR7bWF4fScsXG4gIGxlc3NUaGFuOiAnJHtwYXRofSBtdXN0IGJlIGxlc3MgdGhhbiAke2xlc3N9JyxcbiAgbW9yZVRoYW46ICcke3BhdGh9IG11c3QgYmUgZ3JlYXRlciB0aGFuICR7bW9yZX0nLFxuICBwb3NpdGl2ZTogJyR7cGF0aH0gbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicsXG4gIG5lZ2F0aXZlOiAnJHtwYXRofSBtdXN0IGJlIGEgbmVnYXRpdmUgbnVtYmVyJyxcbiAgaW50ZWdlcjogJyR7cGF0aH0gbXVzdCBiZSBhbiBpbnRlZ2VyJ1xufTtcbmxldCBkYXRlID0ge1xuICBtaW46ICcke3BhdGh9IGZpZWxkIG11c3QgYmUgbGF0ZXIgdGhhbiAke21pbn0nLFxuICBtYXg6ICcke3BhdGh9IGZpZWxkIG11c3QgYmUgYXQgZWFybGllciB0aGFuICR7bWF4fSdcbn07XG5sZXQgYm9vbGVhbiA9IHtcbiAgaXNWYWx1ZTogJyR7cGF0aH0gZmllbGQgbXVzdCBiZSAke3ZhbHVlfSdcbn07XG5sZXQgb2JqZWN0ID0ge1xuICBub1Vua25vd246ICcke3BhdGh9IGZpZWxkIGhhcyB1bnNwZWNpZmllZCBrZXlzOiAke3Vua25vd259J1xufTtcbmxldCBhcnJheSA9IHtcbiAgbWluOiAnJHtwYXRofSBmaWVsZCBtdXN0IGhhdmUgYXQgbGVhc3QgJHttaW59IGl0ZW1zJyxcbiAgbWF4OiAnJHtwYXRofSBmaWVsZCBtdXN0IGhhdmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvICR7bWF4fSBpdGVtcycsXG4gIGxlbmd0aDogJyR7cGF0aH0gbXVzdCBoYXZlICR7bGVuZ3RofSBpdGVtcydcbn07XG5sZXQgdHVwbGUgPSB7XG4gIG5vdFR5cGU6IHBhcmFtcyA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgcGF0aCxcbiAgICAgIHZhbHVlLFxuICAgICAgc3BlY1xuICAgIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgdHlwZUxlbiA9IHNwZWMudHlwZXMubGVuZ3RoO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgaWYgKHZhbHVlLmxlbmd0aCA8IHR5cGVMZW4pIHJldHVybiBgJHtwYXRofSB0dXBsZSB2YWx1ZSBoYXMgdG9vIGZldyBpdGVtcywgZXhwZWN0ZWQgYSBsZW5ndGggb2YgJHt0eXBlTGVufSBidXQgZ290ICR7dmFsdWUubGVuZ3RofSBmb3IgdmFsdWU6IFxcYCR7cHJpbnRWYWx1ZSh2YWx1ZSwgdHJ1ZSl9XFxgYDtcbiAgICAgIGlmICh2YWx1ZS5sZW5ndGggPiB0eXBlTGVuKSByZXR1cm4gYCR7cGF0aH0gdHVwbGUgdmFsdWUgaGFzIHRvbyBtYW55IGl0ZW1zLCBleHBlY3RlZCBhIGxlbmd0aCBvZiAke3R5cGVMZW59IGJ1dCBnb3QgJHt2YWx1ZS5sZW5ndGh9IGZvciB2YWx1ZTogXFxgJHtwcmludFZhbHVlKHZhbHVlLCB0cnVlKX1cXGBgO1xuICAgIH1cbiAgICByZXR1cm4gVmFsaWRhdGlvbkVycm9yLmZvcm1hdEVycm9yKG1peGVkLm5vdFR5cGUsIHBhcmFtcyk7XG4gIH1cbn07XG52YXIgbG9jYWxlID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLCB7XG4gIG1peGVkLFxuICBzdHJpbmcsXG4gIG51bWJlcixcbiAgZGF0ZSxcbiAgb2JqZWN0LFxuICBhcnJheSxcbiAgYm9vbGVhbixcbiAgdHVwbGVcbn0pO1xuXG5jb25zdCBpc1NjaGVtYSA9IG9iaiA9PiBvYmogJiYgb2JqLl9faXNZdXBTY2hlbWFfXztcblxuY2xhc3MgQ29uZGl0aW9uIHtcbiAgc3RhdGljIGZyb21PcHRpb25zKHJlZnMsIGNvbmZpZykge1xuICAgIGlmICghY29uZmlnLnRoZW4gJiYgIWNvbmZpZy5vdGhlcndpc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VpdGhlciBgdGhlbjpgIG9yIGBvdGhlcndpc2U6YCBpcyByZXF1aXJlZCBmb3IgYHdoZW4oKWAgY29uZGl0aW9ucycpO1xuICAgIGxldCB7XG4gICAgICBpcyxcbiAgICAgIHRoZW4sXG4gICAgICBvdGhlcndpc2VcbiAgICB9ID0gY29uZmlnO1xuICAgIGxldCBjaGVjayA9IHR5cGVvZiBpcyA9PT0gJ2Z1bmN0aW9uJyA/IGlzIDogKC4uLnZhbHVlcykgPT4gdmFsdWVzLmV2ZXJ5KHZhbHVlID0+IHZhbHVlID09PSBpcyk7XG4gICAgcmV0dXJuIG5ldyBDb25kaXRpb24ocmVmcywgKHZhbHVlcywgc2NoZW1hKSA9PiB7XG4gICAgICB2YXIgX2JyYW5jaDtcbiAgICAgIGxldCBicmFuY2ggPSBjaGVjayguLi52YWx1ZXMpID8gdGhlbiA6IG90aGVyd2lzZTtcbiAgICAgIHJldHVybiAoX2JyYW5jaCA9IGJyYW5jaCA9PSBudWxsID8gdm9pZCAwIDogYnJhbmNoKHNjaGVtYSkpICE9IG51bGwgPyBfYnJhbmNoIDogc2NoZW1hO1xuICAgIH0pO1xuICB9XG4gIGNvbnN0cnVjdG9yKHJlZnMsIGJ1aWxkZXIpIHtcbiAgICB0aGlzLmZuID0gdm9pZCAwO1xuICAgIHRoaXMucmVmcyA9IHJlZnM7XG4gICAgdGhpcy5yZWZzID0gcmVmcztcbiAgICB0aGlzLmZuID0gYnVpbGRlcjtcbiAgfVxuICByZXNvbHZlKGJhc2UsIG9wdGlvbnMpIHtcbiAgICBsZXQgdmFsdWVzID0gdGhpcy5yZWZzLm1hcChyZWYgPT5cbiAgICAvLyBUT0RPOiA/IG9wZXJhdG9yIGhlcmU/XG4gICAgcmVmLmdldFZhbHVlKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMudmFsdWUsIG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMucGFyZW50LCBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmNvbnRleHQpKTtcbiAgICBsZXQgc2NoZW1hID0gdGhpcy5mbih2YWx1ZXMsIGJhc2UsIG9wdGlvbnMpO1xuICAgIGlmIChzY2hlbWEgPT09IHVuZGVmaW5lZCB8fFxuICAgIC8vIEB0cy1pZ25vcmUgdGhpcyBjYW4gYmUgYmFzZVxuICAgIHNjaGVtYSA9PT0gYmFzZSkge1xuICAgICAgcmV0dXJuIGJhc2U7XG4gICAgfVxuICAgIGlmICghaXNTY2hlbWEoc2NoZW1hKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignY29uZGl0aW9ucyBtdXN0IHJldHVybiBhIHNjaGVtYSBvYmplY3QnKTtcbiAgICByZXR1cm4gc2NoZW1hLnJlc29sdmUob3B0aW9ucyk7XG4gIH1cbn1cblxuY29uc3QgcHJlZml4ZXMgPSB7XG4gIGNvbnRleHQ6ICckJyxcbiAgdmFsdWU6ICcuJ1xufTtcbmZ1bmN0aW9uIGNyZWF0ZSQ5KGtleSwgb3B0aW9ucykge1xuICByZXR1cm4gbmV3IFJlZmVyZW5jZShrZXksIG9wdGlvbnMpO1xufVxuY2xhc3MgUmVmZXJlbmNlIHtcbiAgY29uc3RydWN0b3Ioa2V5LCBvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLmtleSA9IHZvaWQgMDtcbiAgICB0aGlzLmlzQ29udGV4dCA9IHZvaWQgMDtcbiAgICB0aGlzLmlzVmFsdWUgPSB2b2lkIDA7XG4gICAgdGhpcy5pc1NpYmxpbmcgPSB2b2lkIDA7XG4gICAgdGhpcy5wYXRoID0gdm9pZCAwO1xuICAgIHRoaXMuZ2V0dGVyID0gdm9pZCAwO1xuICAgIHRoaXMubWFwID0gdm9pZCAwO1xuICAgIGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJykgdGhyb3cgbmV3IFR5cGVFcnJvcigncmVmIG11c3QgYmUgYSBzdHJpbmcsIGdvdDogJyArIGtleSk7XG4gICAgdGhpcy5rZXkgPSBrZXkudHJpbSgpO1xuICAgIGlmIChrZXkgPT09ICcnKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdyZWYgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcbiAgICB0aGlzLmlzQ29udGV4dCA9IHRoaXMua2V5WzBdID09PSBwcmVmaXhlcy5jb250ZXh0O1xuICAgIHRoaXMuaXNWYWx1ZSA9IHRoaXMua2V5WzBdID09PSBwcmVmaXhlcy52YWx1ZTtcbiAgICB0aGlzLmlzU2libGluZyA9ICF0aGlzLmlzQ29udGV4dCAmJiAhdGhpcy5pc1ZhbHVlO1xuICAgIGxldCBwcmVmaXggPSB0aGlzLmlzQ29udGV4dCA/IHByZWZpeGVzLmNvbnRleHQgOiB0aGlzLmlzVmFsdWUgPyBwcmVmaXhlcy52YWx1ZSA6ICcnO1xuICAgIHRoaXMucGF0aCA9IHRoaXMua2V5LnNsaWNlKHByZWZpeC5sZW5ndGgpO1xuICAgIHRoaXMuZ2V0dGVyID0gdGhpcy5wYXRoICYmIGdldHRlcih0aGlzLnBhdGgsIHRydWUpO1xuICAgIHRoaXMubWFwID0gb3B0aW9ucy5tYXA7XG4gIH1cbiAgZ2V0VmFsdWUodmFsdWUsIHBhcmVudCwgY29udGV4dCkge1xuICAgIGxldCByZXN1bHQgPSB0aGlzLmlzQ29udGV4dCA/IGNvbnRleHQgOiB0aGlzLmlzVmFsdWUgPyB2YWx1ZSA6IHBhcmVudDtcbiAgICBpZiAodGhpcy5nZXR0ZXIpIHJlc3VsdCA9IHRoaXMuZ2V0dGVyKHJlc3VsdCB8fCB7fSk7XG4gICAgaWYgKHRoaXMubWFwKSByZXN1bHQgPSB0aGlzLm1hcChyZXN1bHQpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnMuY29udGV4dFxuICAgKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnMucGFyZW50XG4gICAqL1xuICBjYXN0KHZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0VmFsdWUodmFsdWUsIG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMucGFyZW50LCBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmNvbnRleHQpO1xuICB9XG4gIHJlc29sdmUoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZGVzY3JpYmUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdyZWYnLFxuICAgICAga2V5OiB0aGlzLmtleVxuICAgIH07XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIGBSZWYoJHt0aGlzLmtleX0pYDtcbiAgfVxuICBzdGF0aWMgaXNSZWYodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgJiYgdmFsdWUuX19pc1l1cFJlZjtcbiAgfVxufVxuXG4vLyBAdHMtaWdub3JlXG5SZWZlcmVuY2UucHJvdG90eXBlLl9faXNZdXBSZWYgPSB0cnVlO1xuXG5jb25zdCBpc0Fic2VudCA9IHZhbHVlID0+IHZhbHVlID09IG51bGw7XG5cbmZ1bmN0aW9uIGNyZWF0ZVZhbGlkYXRpb24oY29uZmlnKSB7XG4gIGZ1bmN0aW9uIHZhbGlkYXRlKHtcbiAgICB2YWx1ZSxcbiAgICBwYXRoID0gJycsXG4gICAgb3B0aW9ucyxcbiAgICBvcmlnaW5hbFZhbHVlLFxuICAgIHNjaGVtYVxuICB9LCBwYW5pYywgbmV4dCkge1xuICAgIGNvbnN0IHtcbiAgICAgIG5hbWUsXG4gICAgICB0ZXN0LFxuICAgICAgcGFyYW1zLFxuICAgICAgbWVzc2FnZSxcbiAgICAgIHNraXBBYnNlbnRcbiAgICB9ID0gY29uZmlnO1xuICAgIGxldCB7XG4gICAgICBwYXJlbnQsXG4gICAgICBjb250ZXh0LFxuICAgICAgYWJvcnRFYXJseSA9IHNjaGVtYS5zcGVjLmFib3J0RWFybHksXG4gICAgICBkaXNhYmxlU3RhY2tUcmFjZSA9IHNjaGVtYS5zcGVjLmRpc2FibGVTdGFja1RyYWNlXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgZnVuY3Rpb24gcmVzb2x2ZShpdGVtKSB7XG4gICAgICByZXR1cm4gUmVmZXJlbmNlLmlzUmVmKGl0ZW0pID8gaXRlbS5nZXRWYWx1ZSh2YWx1ZSwgcGFyZW50LCBjb250ZXh0KSA6IGl0ZW07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUVycm9yKG92ZXJyaWRlcyA9IHt9KSB7XG4gICAgICBjb25zdCBuZXh0UGFyYW1zID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIHZhbHVlLFxuICAgICAgICBvcmlnaW5hbFZhbHVlLFxuICAgICAgICBsYWJlbDogc2NoZW1hLnNwZWMubGFiZWwsXG4gICAgICAgIHBhdGg6IG92ZXJyaWRlcy5wYXRoIHx8IHBhdGgsXG4gICAgICAgIHNwZWM6IHNjaGVtYS5zcGVjLFxuICAgICAgICBkaXNhYmxlU3RhY2tUcmFjZTogb3ZlcnJpZGVzLmRpc2FibGVTdGFja1RyYWNlIHx8IGRpc2FibGVTdGFja1RyYWNlXG4gICAgICB9LCBwYXJhbXMsIG92ZXJyaWRlcy5wYXJhbXMpO1xuICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMobmV4dFBhcmFtcykpIG5leHRQYXJhbXNba2V5XSA9IHJlc29sdmUobmV4dFBhcmFtc1trZXldKTtcbiAgICAgIGNvbnN0IGVycm9yID0gbmV3IFZhbGlkYXRpb25FcnJvcihWYWxpZGF0aW9uRXJyb3IuZm9ybWF0RXJyb3Iob3ZlcnJpZGVzLm1lc3NhZ2UgfHwgbWVzc2FnZSwgbmV4dFBhcmFtcyksIHZhbHVlLCBuZXh0UGFyYW1zLnBhdGgsIG92ZXJyaWRlcy50eXBlIHx8IG5hbWUsIG5leHRQYXJhbXMuZGlzYWJsZVN0YWNrVHJhY2UpO1xuICAgICAgZXJyb3IucGFyYW1zID0gbmV4dFBhcmFtcztcbiAgICAgIHJldHVybiBlcnJvcjtcbiAgICB9XG4gICAgY29uc3QgaW52YWxpZCA9IGFib3J0RWFybHkgPyBwYW5pYyA6IG5leHQ7XG4gICAgbGV0IGN0eCA9IHtcbiAgICAgIHBhdGgsXG4gICAgICBwYXJlbnQsXG4gICAgICB0eXBlOiBuYW1lLFxuICAgICAgZnJvbTogb3B0aW9ucy5mcm9tLFxuICAgICAgY3JlYXRlRXJyb3IsXG4gICAgICByZXNvbHZlLFxuICAgICAgb3B0aW9ucyxcbiAgICAgIG9yaWdpbmFsVmFsdWUsXG4gICAgICBzY2hlbWFcbiAgICB9O1xuICAgIGNvbnN0IGhhbmRsZVJlc3VsdCA9IHZhbGlkT3JFcnJvciA9PiB7XG4gICAgICBpZiAoVmFsaWRhdGlvbkVycm9yLmlzRXJyb3IodmFsaWRPckVycm9yKSkgaW52YWxpZCh2YWxpZE9yRXJyb3IpO2Vsc2UgaWYgKCF2YWxpZE9yRXJyb3IpIGludmFsaWQoY3JlYXRlRXJyb3IoKSk7ZWxzZSBuZXh0KG51bGwpO1xuICAgIH07XG4gICAgY29uc3QgaGFuZGxlRXJyb3IgPSBlcnIgPT4ge1xuICAgICAgaWYgKFZhbGlkYXRpb25FcnJvci5pc0Vycm9yKGVycikpIGludmFsaWQoZXJyKTtlbHNlIHBhbmljKGVycik7XG4gICAgfTtcbiAgICBjb25zdCBzaG91bGRTa2lwID0gc2tpcEFic2VudCAmJiBpc0Fic2VudCh2YWx1ZSk7XG4gICAgaWYgKHNob3VsZFNraXApIHtcbiAgICAgIHJldHVybiBoYW5kbGVSZXN1bHQodHJ1ZSk7XG4gICAgfVxuICAgIGxldCByZXN1bHQ7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBfcmVzdWx0O1xuICAgICAgcmVzdWx0ID0gdGVzdC5jYWxsKGN0eCwgdmFsdWUsIGN0eCk7XG4gICAgICBpZiAodHlwZW9mICgoX3Jlc3VsdCA9IHJlc3VsdCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9yZXN1bHQudGhlbikgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuc3luYykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVmFsaWRhdGlvbiB0ZXN0IG9mIHR5cGU6IFwiJHtjdHgudHlwZX1cIiByZXR1cm5lZCBhIFByb21pc2UgZHVyaW5nIGEgc3luY2hyb25vdXMgdmFsaWRhdGUuIGAgKyBgVGhpcyB0ZXN0IHdpbGwgZmluaXNoIGFmdGVyIHRoZSB2YWxpZGF0ZSBjYWxsIGhhcyByZXR1cm5lZGApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KS50aGVuKGhhbmRsZVJlc3VsdCwgaGFuZGxlRXJyb3IpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaGFuZGxlRXJyb3IoZXJyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaGFuZGxlUmVzdWx0KHJlc3VsdCk7XG4gIH1cbiAgdmFsaWRhdGUuT1BUSU9OUyA9IGNvbmZpZztcbiAgcmV0dXJuIHZhbGlkYXRlO1xufVxuXG5mdW5jdGlvbiBnZXRJbihzY2hlbWEsIHBhdGgsIHZhbHVlLCBjb250ZXh0ID0gdmFsdWUpIHtcbiAgbGV0IHBhcmVudCwgbGFzdFBhcnQsIGxhc3RQYXJ0RGVidWc7XG5cbiAgLy8gcm9vdCBwYXRoOiAnJ1xuICBpZiAoIXBhdGgpIHJldHVybiB7XG4gICAgcGFyZW50LFxuICAgIHBhcmVudFBhdGg6IHBhdGgsXG4gICAgc2NoZW1hXG4gIH07XG4gIGZvckVhY2gocGF0aCwgKF9wYXJ0LCBpc0JyYWNrZXQsIGlzQXJyYXkpID0+IHtcbiAgICBsZXQgcGFydCA9IGlzQnJhY2tldCA/IF9wYXJ0LnNsaWNlKDEsIF9wYXJ0Lmxlbmd0aCAtIDEpIDogX3BhcnQ7XG4gICAgc2NoZW1hID0gc2NoZW1hLnJlc29sdmUoe1xuICAgICAgY29udGV4dCxcbiAgICAgIHBhcmVudCxcbiAgICAgIHZhbHVlXG4gICAgfSk7XG4gICAgbGV0IGlzVHVwbGUgPSBzY2hlbWEudHlwZSA9PT0gJ3R1cGxlJztcbiAgICBsZXQgaWR4ID0gaXNBcnJheSA/IHBhcnNlSW50KHBhcnQsIDEwKSA6IDA7XG4gICAgaWYgKHNjaGVtYS5pbm5lclR5cGUgfHwgaXNUdXBsZSkge1xuICAgICAgaWYgKGlzVHVwbGUgJiYgIWlzQXJyYXkpIHRocm93IG5ldyBFcnJvcihgWXVwLnJlYWNoIGNhbm5vdCBpbXBsaWNpdGx5IGluZGV4IGludG8gYSB0dXBsZSB0eXBlLiB0aGUgcGF0aCBwYXJ0IFwiJHtsYXN0UGFydERlYnVnfVwiIG11c3QgY29udGFpbiBhbiBpbmRleCB0byB0aGUgdHVwbGUgZWxlbWVudCwgZS5nLiBcIiR7bGFzdFBhcnREZWJ1Z31bMF1cImApO1xuICAgICAgaWYgKHZhbHVlICYmIGlkeCA+PSB2YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBZdXAucmVhY2ggY2Fubm90IHJlc29sdmUgYW4gYXJyYXkgaXRlbSBhdCBpbmRleDogJHtfcGFydH0sIGluIHRoZSBwYXRoOiAke3BhdGh9LiBgICsgYGJlY2F1c2UgdGhlcmUgaXMgbm8gdmFsdWUgYXQgdGhhdCBpbmRleC4gYCk7XG4gICAgICB9XG4gICAgICBwYXJlbnQgPSB2YWx1ZTtcbiAgICAgIHZhbHVlID0gdmFsdWUgJiYgdmFsdWVbaWR4XTtcbiAgICAgIHNjaGVtYSA9IGlzVHVwbGUgPyBzY2hlbWEuc3BlYy50eXBlc1tpZHhdIDogc2NoZW1hLmlubmVyVHlwZTtcbiAgICB9XG5cbiAgICAvLyBzb21ldGltZXMgdGhlIGFycmF5IGluZGV4IHBhcnQgb2YgYSBwYXRoIGRvZXNuJ3QgZXhpc3Q6IFwibmVzdGVkLmFyci5jaGlsZFwiXG4gICAgLy8gaW4gdGhlc2UgY2FzZXMgdGhlIGN1cnJlbnQgcGFydCBpcyB0aGUgbmV4dCBzY2hlbWEgYW5kIHNob3VsZCBiZSBwcm9jZXNzZWRcbiAgICAvLyBpbiB0aGlzIGl0ZXJhdGlvbi4gRm9yIGNhc2VzIHdoZXJlIHRoZSBpbmRleCBzaWduYXR1cmUgaXMgaW5jbHVkZWQgdGhpc1xuICAgIC8vIGNoZWNrIHdpbGwgZmFpbCBhbmQgd2UnbGwgaGFuZGxlIHRoZSBgY2hpbGRgIHBhcnQgb24gdGhlIG5leHQgaXRlcmF0aW9uIGxpa2Ugbm9ybWFsXG4gICAgaWYgKCFpc0FycmF5KSB7XG4gICAgICBpZiAoIXNjaGVtYS5maWVsZHMgfHwgIXNjaGVtYS5maWVsZHNbcGFydF0pIHRocm93IG5ldyBFcnJvcihgVGhlIHNjaGVtYSBkb2VzIG5vdCBjb250YWluIHRoZSBwYXRoOiAke3BhdGh9LiBgICsgYChmYWlsZWQgYXQ6ICR7bGFzdFBhcnREZWJ1Z30gd2hpY2ggaXMgYSB0eXBlOiBcIiR7c2NoZW1hLnR5cGV9XCIpYCk7XG4gICAgICBwYXJlbnQgPSB2YWx1ZTtcbiAgICAgIHZhbHVlID0gdmFsdWUgJiYgdmFsdWVbcGFydF07XG4gICAgICBzY2hlbWEgPSBzY2hlbWEuZmllbGRzW3BhcnRdO1xuICAgIH1cbiAgICBsYXN0UGFydCA9IHBhcnQ7XG4gICAgbGFzdFBhcnREZWJ1ZyA9IGlzQnJhY2tldCA/ICdbJyArIF9wYXJ0ICsgJ10nIDogJy4nICsgX3BhcnQ7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHNjaGVtYSxcbiAgICBwYXJlbnQsXG4gICAgcGFyZW50UGF0aDogbGFzdFBhcnRcbiAgfTtcbn1cbmZ1bmN0aW9uIHJlYWNoKG9iaiwgcGF0aCwgdmFsdWUsIGNvbnRleHQpIHtcbiAgcmV0dXJuIGdldEluKG9iaiwgcGF0aCwgdmFsdWUsIGNvbnRleHQpLnNjaGVtYTtcbn1cblxuY2xhc3MgUmVmZXJlbmNlU2V0IGV4dGVuZHMgU2V0IHtcbiAgZGVzY3JpYmUoKSB7XG4gICAgY29uc3QgZGVzY3JpcHRpb24gPSBbXTtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy52YWx1ZXMoKSkge1xuICAgICAgZGVzY3JpcHRpb24ucHVzaChSZWZlcmVuY2UuaXNSZWYoaXRlbSkgPyBpdGVtLmRlc2NyaWJlKCkgOiBpdGVtKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlc2NyaXB0aW9uO1xuICB9XG4gIHJlc29sdmVBbGwocmVzb2x2ZSkge1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy52YWx1ZXMoKSkge1xuICAgICAgcmVzdWx0LnB1c2gocmVzb2x2ZShpdGVtKSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBSZWZlcmVuY2VTZXQodGhpcy52YWx1ZXMoKSk7XG4gIH1cbiAgbWVyZ2UobmV3SXRlbXMsIHJlbW92ZUl0ZW1zKSB7XG4gICAgY29uc3QgbmV4dCA9IHRoaXMuY2xvbmUoKTtcbiAgICBuZXdJdGVtcy5mb3JFYWNoKHZhbHVlID0+IG5leHQuYWRkKHZhbHVlKSk7XG4gICAgcmVtb3ZlSXRlbXMuZm9yRWFjaCh2YWx1ZSA9PiBuZXh0LmRlbGV0ZSh2YWx1ZSkpO1xuICAgIHJldHVybiBuZXh0O1xuICB9XG59XG5cbi8vIHR3ZWFrZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vS2VsaW4yMDI1L25hbm9jbG9uZS9ibG9iLzBhYmViNzYzNWJkYTliNjhlZjIyNzcwOTNmNzZkYmUzYmYzOTQ4ZTEvc3JjL2luZGV4LmpzXG5mdW5jdGlvbiBjbG9uZShzcmMsIHNlZW4gPSBuZXcgTWFwKCkpIHtcbiAgaWYgKGlzU2NoZW1hKHNyYykgfHwgIXNyYyB8fCB0eXBlb2Ygc3JjICE9PSAnb2JqZWN0JykgcmV0dXJuIHNyYztcbiAgaWYgKHNlZW4uaGFzKHNyYykpIHJldHVybiBzZWVuLmdldChzcmMpO1xuICBsZXQgY29weTtcbiAgaWYgKHNyYyBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAvLyBEYXRlXG4gICAgY29weSA9IG5ldyBEYXRlKHNyYy5nZXRUaW1lKCkpO1xuICAgIHNlZW4uc2V0KHNyYywgY29weSk7XG4gIH0gZWxzZSBpZiAoc3JjIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgLy8gUmVnRXhwXG4gICAgY29weSA9IG5ldyBSZWdFeHAoc3JjKTtcbiAgICBzZWVuLnNldChzcmMsIGNvcHkpO1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoc3JjKSkge1xuICAgIC8vIEFycmF5XG4gICAgY29weSA9IG5ldyBBcnJheShzcmMubGVuZ3RoKTtcbiAgICBzZWVuLnNldChzcmMsIGNvcHkpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3JjLmxlbmd0aDsgaSsrKSBjb3B5W2ldID0gY2xvbmUoc3JjW2ldLCBzZWVuKTtcbiAgfSBlbHNlIGlmIChzcmMgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAvLyBNYXBcbiAgICBjb3B5ID0gbmV3IE1hcCgpO1xuICAgIHNlZW4uc2V0KHNyYywgY29weSk7XG4gICAgZm9yIChjb25zdCBbaywgdl0gb2Ygc3JjLmVudHJpZXMoKSkgY29weS5zZXQoaywgY2xvbmUodiwgc2VlbikpO1xuICB9IGVsc2UgaWYgKHNyYyBpbnN0YW5jZW9mIFNldCkge1xuICAgIC8vIFNldFxuICAgIGNvcHkgPSBuZXcgU2V0KCk7XG4gICAgc2Vlbi5zZXQoc3JjLCBjb3B5KTtcbiAgICBmb3IgKGNvbnN0IHYgb2Ygc3JjKSBjb3B5LmFkZChjbG9uZSh2LCBzZWVuKSk7XG4gIH0gZWxzZSBpZiAoc3JjIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgLy8gT2JqZWN0XG4gICAgY29weSA9IHt9O1xuICAgIHNlZW4uc2V0KHNyYywgY29weSk7XG4gICAgZm9yIChjb25zdCBbaywgdl0gb2YgT2JqZWN0LmVudHJpZXMoc3JjKSkgY29weVtrXSA9IGNsb25lKHYsIHNlZW4pO1xuICB9IGVsc2Uge1xuICAgIHRocm93IEVycm9yKGBVbmFibGUgdG8gY2xvbmUgJHtzcmN9YCk7XG4gIH1cbiAgcmV0dXJuIGNvcHk7XG59XG5cbi8vIElmIGBDdXN0b21TY2hlbWFNZXRhYCBpc24ndCBleHRlbmRlZCB3aXRoIGFueSBrZXlzLCB3ZSdsbCBmYWxsIGJhY2sgdG8gYVxuLy8gbG9vc2UgUmVjb3JkIGRlZmluaXRpb24gYWxsb3dpbmcgZnJlZSBmb3JtIHVzYWdlLlxuY2xhc3MgU2NoZW1hIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHRoaXMudHlwZSA9IHZvaWQgMDtcbiAgICB0aGlzLmRlcHMgPSBbXTtcbiAgICB0aGlzLnRlc3RzID0gdm9pZCAwO1xuICAgIHRoaXMudHJhbnNmb3JtcyA9IHZvaWQgMDtcbiAgICB0aGlzLmNvbmRpdGlvbnMgPSBbXTtcbiAgICB0aGlzLl9tdXRhdGUgPSB2b2lkIDA7XG4gICAgdGhpcy5pbnRlcm5hbFRlc3RzID0ge307XG4gICAgdGhpcy5fd2hpdGVsaXN0ID0gbmV3IFJlZmVyZW5jZVNldCgpO1xuICAgIHRoaXMuX2JsYWNrbGlzdCA9IG5ldyBSZWZlcmVuY2VTZXQoKTtcbiAgICB0aGlzLmV4Y2x1c2l2ZVRlc3RzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLl90eXBlQ2hlY2sgPSB2b2lkIDA7XG4gICAgdGhpcy5zcGVjID0gdm9pZCAwO1xuICAgIHRoaXMudGVzdHMgPSBbXTtcbiAgICB0aGlzLnRyYW5zZm9ybXMgPSBbXTtcbiAgICB0aGlzLndpdGhNdXRhdGlvbigoKSA9PiB7XG4gICAgICB0aGlzLnR5cGVFcnJvcihtaXhlZC5ub3RUeXBlKTtcbiAgICB9KTtcbiAgICB0aGlzLnR5cGUgPSBvcHRpb25zLnR5cGU7XG4gICAgdGhpcy5fdHlwZUNoZWNrID0gb3B0aW9ucy5jaGVjaztcbiAgICB0aGlzLnNwZWMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgIHN0cmlwOiBmYWxzZSxcbiAgICAgIHN0cmljdDogZmFsc2UsXG4gICAgICBhYm9ydEVhcmx5OiB0cnVlLFxuICAgICAgcmVjdXJzaXZlOiB0cnVlLFxuICAgICAgZGlzYWJsZVN0YWNrVHJhY2U6IGZhbHNlLFxuICAgICAgbnVsbGFibGU6IGZhbHNlLFxuICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICBjb2VyY2U6IHRydWVcbiAgICB9LCBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLnNwZWMpO1xuICAgIHRoaXMud2l0aE11dGF0aW9uKHMgPT4ge1xuICAgICAgcy5ub25OdWxsYWJsZSgpO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gVE9ETzogcmVtb3ZlXG4gIGdldCBfdHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy50eXBlO1xuICB9XG4gIGNsb25lKHNwZWMpIHtcbiAgICBpZiAodGhpcy5fbXV0YXRlKSB7XG4gICAgICBpZiAoc3BlYykgT2JqZWN0LmFzc2lnbih0aGlzLnNwZWMsIHNwZWMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gaWYgdGhlIG5lc3RlZCB2YWx1ZSBpcyBhIHNjaGVtYSB3ZSBjYW4gc2tpcCBjbG9uaW5nLCBzaW5jZVxuICAgIC8vIHRoZXkgYXJlIGFscmVhZHkgaW1tdXRhYmxlXG4gICAgY29uc3QgbmV4dCA9IE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpKTtcblxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgdGhpcyBpcyByZWFkb25seVxuICAgIG5leHQudHlwZSA9IHRoaXMudHlwZTtcbiAgICBuZXh0Ll90eXBlQ2hlY2sgPSB0aGlzLl90eXBlQ2hlY2s7XG4gICAgbmV4dC5fd2hpdGVsaXN0ID0gdGhpcy5fd2hpdGVsaXN0LmNsb25lKCk7XG4gICAgbmV4dC5fYmxhY2tsaXN0ID0gdGhpcy5fYmxhY2tsaXN0LmNsb25lKCk7XG4gICAgbmV4dC5pbnRlcm5hbFRlc3RzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5pbnRlcm5hbFRlc3RzKTtcbiAgICBuZXh0LmV4Y2x1c2l2ZVRlc3RzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5leGNsdXNpdmVUZXN0cyk7XG5cbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIHRoaXMgaXMgcmVhZG9ubHlcbiAgICBuZXh0LmRlcHMgPSBbLi4udGhpcy5kZXBzXTtcbiAgICBuZXh0LmNvbmRpdGlvbnMgPSBbLi4udGhpcy5jb25kaXRpb25zXTtcbiAgICBuZXh0LnRlc3RzID0gWy4uLnRoaXMudGVzdHNdO1xuICAgIG5leHQudHJhbnNmb3JtcyA9IFsuLi50aGlzLnRyYW5zZm9ybXNdO1xuICAgIG5leHQuc3BlYyA9IGNsb25lKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuc3BlYywgc3BlYykpO1xuICAgIHJldHVybiBuZXh0O1xuICB9XG4gIGxhYmVsKGxhYmVsKSB7XG4gICAgbGV0IG5leHQgPSB0aGlzLmNsb25lKCk7XG4gICAgbmV4dC5zcGVjLmxhYmVsID0gbGFiZWw7XG4gICAgcmV0dXJuIG5leHQ7XG4gIH1cbiAgbWV0YSguLi5hcmdzKSB7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5zcGVjLm1ldGE7XG4gICAgbGV0IG5leHQgPSB0aGlzLmNsb25lKCk7XG4gICAgbmV4dC5zcGVjLm1ldGEgPSBPYmplY3QuYXNzaWduKG5leHQuc3BlYy5tZXRhIHx8IHt9LCBhcmdzWzBdKTtcbiAgICByZXR1cm4gbmV4dDtcbiAgfVxuICB3aXRoTXV0YXRpb24oZm4pIHtcbiAgICBsZXQgYmVmb3JlID0gdGhpcy5fbXV0YXRlO1xuICAgIHRoaXMuX211dGF0ZSA9IHRydWU7XG4gICAgbGV0IHJlc3VsdCA9IGZuKHRoaXMpO1xuICAgIHRoaXMuX211dGF0ZSA9IGJlZm9yZTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGNvbmNhdChzY2hlbWEpIHtcbiAgICBpZiAoIXNjaGVtYSB8fCBzY2hlbWEgPT09IHRoaXMpIHJldHVybiB0aGlzO1xuICAgIGlmIChzY2hlbWEudHlwZSAhPT0gdGhpcy50eXBlICYmIHRoaXMudHlwZSAhPT0gJ21peGVkJykgdGhyb3cgbmV3IFR5cGVFcnJvcihgWW91IGNhbm5vdCBcXGBjb25jYXQoKVxcYCBzY2hlbWEncyBvZiBkaWZmZXJlbnQgdHlwZXM6ICR7dGhpcy50eXBlfSBhbmQgJHtzY2hlbWEudHlwZX1gKTtcbiAgICBsZXQgYmFzZSA9IHRoaXM7XG4gICAgbGV0IGNvbWJpbmVkID0gc2NoZW1hLmNsb25lKCk7XG4gICAgY29uc3QgbWVyZ2VkU3BlYyA9IE9iamVjdC5hc3NpZ24oe30sIGJhc2Uuc3BlYywgY29tYmluZWQuc3BlYyk7XG4gICAgY29tYmluZWQuc3BlYyA9IG1lcmdlZFNwZWM7XG4gICAgY29tYmluZWQuaW50ZXJuYWxUZXN0cyA9IE9iamVjdC5hc3NpZ24oe30sIGJhc2UuaW50ZXJuYWxUZXN0cywgY29tYmluZWQuaW50ZXJuYWxUZXN0cyk7XG5cbiAgICAvLyBtYW51YWxseSBtZXJnZSB0aGUgYmxhY2tsaXN0L3doaXRlbGlzdCAodGhlIG90aGVyIGBzY2hlbWFgIHRha2VzXG4gICAgLy8gcHJlY2VkZW5jZSBpbiBjYXNlIG9mIGNvbmZsaWN0cylcbiAgICBjb21iaW5lZC5fd2hpdGVsaXN0ID0gYmFzZS5fd2hpdGVsaXN0Lm1lcmdlKHNjaGVtYS5fd2hpdGVsaXN0LCBzY2hlbWEuX2JsYWNrbGlzdCk7XG4gICAgY29tYmluZWQuX2JsYWNrbGlzdCA9IGJhc2UuX2JsYWNrbGlzdC5tZXJnZShzY2hlbWEuX2JsYWNrbGlzdCwgc2NoZW1hLl93aGl0ZWxpc3QpO1xuXG4gICAgLy8gc3RhcnQgd2l0aCB0aGUgY3VycmVudCB0ZXN0c1xuICAgIGNvbWJpbmVkLnRlc3RzID0gYmFzZS50ZXN0cztcbiAgICBjb21iaW5lZC5leGNsdXNpdmVUZXN0cyA9IGJhc2UuZXhjbHVzaXZlVGVzdHM7XG5cbiAgICAvLyBtYW51YWxseSBhZGQgdGhlIG5ldyB0ZXN0cyB0byBlbnN1cmVcbiAgICAvLyB0aGUgZGVkdXBpbmcgbG9naWMgaXMgY29uc2lzdGVudFxuICAgIGNvbWJpbmVkLndpdGhNdXRhdGlvbihuZXh0ID0+IHtcbiAgICAgIHNjaGVtYS50ZXN0cy5mb3JFYWNoKGZuID0+IHtcbiAgICAgICAgbmV4dC50ZXN0KGZuLk9QVElPTlMpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgY29tYmluZWQudHJhbnNmb3JtcyA9IFsuLi5iYXNlLnRyYW5zZm9ybXMsIC4uLmNvbWJpbmVkLnRyYW5zZm9ybXNdO1xuICAgIHJldHVybiBjb21iaW5lZDtcbiAgfVxuICBpc1R5cGUodikge1xuICAgIGlmICh2ID09IG51bGwpIHtcbiAgICAgIGlmICh0aGlzLnNwZWMubnVsbGFibGUgJiYgdiA9PT0gbnVsbCkgcmV0dXJuIHRydWU7XG4gICAgICBpZiAodGhpcy5zcGVjLm9wdGlvbmFsICYmIHYgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHRydWU7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl90eXBlQ2hlY2sodik7XG4gIH1cbiAgcmVzb2x2ZShvcHRpb25zKSB7XG4gICAgbGV0IHNjaGVtYSA9IHRoaXM7XG4gICAgaWYgKHNjaGVtYS5jb25kaXRpb25zLmxlbmd0aCkge1xuICAgICAgbGV0IGNvbmRpdGlvbnMgPSBzY2hlbWEuY29uZGl0aW9ucztcbiAgICAgIHNjaGVtYSA9IHNjaGVtYS5jbG9uZSgpO1xuICAgICAgc2NoZW1hLmNvbmRpdGlvbnMgPSBbXTtcbiAgICAgIHNjaGVtYSA9IGNvbmRpdGlvbnMucmVkdWNlKChwcmV2U2NoZW1hLCBjb25kaXRpb24pID0+IGNvbmRpdGlvbi5yZXNvbHZlKHByZXZTY2hlbWEsIG9wdGlvbnMpLCBzY2hlbWEpO1xuICAgICAgc2NoZW1hID0gc2NoZW1hLnJlc29sdmUob3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiBzY2hlbWE7XG4gIH1cbiAgcmVzb2x2ZU9wdGlvbnMob3B0aW9ucykge1xuICAgIHZhciBfb3B0aW9ucyRzdHJpY3QsIF9vcHRpb25zJGFib3J0RWFybHksIF9vcHRpb25zJHJlY3Vyc2l2ZSwgX29wdGlvbnMkZGlzYWJsZVN0YWNrO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7XG4gICAgICBmcm9tOiBvcHRpb25zLmZyb20gfHwgW10sXG4gICAgICBzdHJpY3Q6IChfb3B0aW9ucyRzdHJpY3QgPSBvcHRpb25zLnN0cmljdCkgIT0gbnVsbCA/IF9vcHRpb25zJHN0cmljdCA6IHRoaXMuc3BlYy5zdHJpY3QsXG4gICAgICBhYm9ydEVhcmx5OiAoX29wdGlvbnMkYWJvcnRFYXJseSA9IG9wdGlvbnMuYWJvcnRFYXJseSkgIT0gbnVsbCA/IF9vcHRpb25zJGFib3J0RWFybHkgOiB0aGlzLnNwZWMuYWJvcnRFYXJseSxcbiAgICAgIHJlY3Vyc2l2ZTogKF9vcHRpb25zJHJlY3Vyc2l2ZSA9IG9wdGlvbnMucmVjdXJzaXZlKSAhPSBudWxsID8gX29wdGlvbnMkcmVjdXJzaXZlIDogdGhpcy5zcGVjLnJlY3Vyc2l2ZSxcbiAgICAgIGRpc2FibGVTdGFja1RyYWNlOiAoX29wdGlvbnMkZGlzYWJsZVN0YWNrID0gb3B0aW9ucy5kaXNhYmxlU3RhY2tUcmFjZSkgIT0gbnVsbCA/IF9vcHRpb25zJGRpc2FibGVTdGFjayA6IHRoaXMuc3BlYy5kaXNhYmxlU3RhY2tUcmFjZVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJ1biB0aGUgY29uZmlndXJlZCB0cmFuc2Zvcm0gcGlwZWxpbmUgb3ZlciBhbiBpbnB1dCB2YWx1ZS5cbiAgICovXG5cbiAgY2FzdCh2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgbGV0IHJlc29sdmVkU2NoZW1hID0gdGhpcy5yZXNvbHZlKE9iamVjdC5hc3NpZ24oe1xuICAgICAgdmFsdWVcbiAgICB9LCBvcHRpb25zKSk7XG4gICAgbGV0IGFsbG93T3B0aW9uYWxpdHkgPSBvcHRpb25zLmFzc2VydCA9PT0gJ2lnbm9yZS1vcHRpb25hbGl0eSc7XG4gICAgbGV0IHJlc3VsdCA9IHJlc29sdmVkU2NoZW1hLl9jYXN0KHZhbHVlLCBvcHRpb25zKTtcbiAgICBpZiAob3B0aW9ucy5hc3NlcnQgIT09IGZhbHNlICYmICFyZXNvbHZlZFNjaGVtYS5pc1R5cGUocmVzdWx0KSkge1xuICAgICAgaWYgKGFsbG93T3B0aW9uYWxpdHkgJiYgaXNBYnNlbnQocmVzdWx0KSkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgbGV0IGZvcm1hdHRlZFZhbHVlID0gcHJpbnRWYWx1ZSh2YWx1ZSk7XG4gICAgICBsZXQgZm9ybWF0dGVkUmVzdWx0ID0gcHJpbnRWYWx1ZShyZXN1bHQpO1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIHZhbHVlIG9mICR7b3B0aW9ucy5wYXRoIHx8ICdmaWVsZCd9IGNvdWxkIG5vdCBiZSBjYXN0IHRvIGEgdmFsdWUgYCArIGB0aGF0IHNhdGlzZmllcyB0aGUgc2NoZW1hIHR5cGU6IFwiJHtyZXNvbHZlZFNjaGVtYS50eXBlfVwiLiBcXG5cXG5gICsgYGF0dGVtcHRlZCB2YWx1ZTogJHtmb3JtYXR0ZWRWYWx1ZX0gXFxuYCArIChmb3JtYXR0ZWRSZXN1bHQgIT09IGZvcm1hdHRlZFZhbHVlID8gYHJlc3VsdCBvZiBjYXN0OiAke2Zvcm1hdHRlZFJlc3VsdH1gIDogJycpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBfY2FzdChyYXdWYWx1ZSwgb3B0aW9ucykge1xuICAgIGxldCB2YWx1ZSA9IHJhd1ZhbHVlID09PSB1bmRlZmluZWQgPyByYXdWYWx1ZSA6IHRoaXMudHJhbnNmb3Jtcy5yZWR1Y2UoKHByZXZWYWx1ZSwgZm4pID0+IGZuLmNhbGwodGhpcywgcHJldlZhbHVlLCByYXdWYWx1ZSwgdGhpcyksIHJhd1ZhbHVlKTtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFsdWUgPSB0aGlzLmdldERlZmF1bHQob3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBfdmFsaWRhdGUoX3ZhbHVlLCBvcHRpb25zID0ge30sIHBhbmljLCBuZXh0KSB7XG4gICAgbGV0IHtcbiAgICAgIHBhdGgsXG4gICAgICBvcmlnaW5hbFZhbHVlID0gX3ZhbHVlLFxuICAgICAgc3RyaWN0ID0gdGhpcy5zcGVjLnN0cmljdFxuICAgIH0gPSBvcHRpb25zO1xuICAgIGxldCB2YWx1ZSA9IF92YWx1ZTtcbiAgICBpZiAoIXN0cmljdCkge1xuICAgICAgdmFsdWUgPSB0aGlzLl9jYXN0KHZhbHVlLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgYXNzZXJ0OiBmYWxzZVxuICAgICAgfSwgb3B0aW9ucykpO1xuICAgIH1cbiAgICBsZXQgaW5pdGlhbFRlc3RzID0gW107XG4gICAgZm9yIChsZXQgdGVzdCBvZiBPYmplY3QudmFsdWVzKHRoaXMuaW50ZXJuYWxUZXN0cykpIHtcbiAgICAgIGlmICh0ZXN0KSBpbml0aWFsVGVzdHMucHVzaCh0ZXN0KTtcbiAgICB9XG4gICAgdGhpcy5ydW5UZXN0cyh7XG4gICAgICBwYXRoLFxuICAgICAgdmFsdWUsXG4gICAgICBvcmlnaW5hbFZhbHVlLFxuICAgICAgb3B0aW9ucyxcbiAgICAgIHRlc3RzOiBpbml0aWFsVGVzdHNcbiAgICB9LCBwYW5pYywgaW5pdGlhbEVycm9ycyA9PiB7XG4gICAgICAvLyBldmVuIGlmIHdlIGFyZW4ndCBlbmRpbmcgZWFybHkgd2UgY2FuJ3QgcHJvY2VlZCBmdXJ0aGVyIGlmIHRoZSB0eXBlcyBhcmVuJ3QgY29ycmVjdFxuICAgICAgaWYgKGluaXRpYWxFcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBuZXh0KGluaXRpYWxFcnJvcnMsIHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucnVuVGVzdHMoe1xuICAgICAgICBwYXRoLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgb3JpZ2luYWxWYWx1ZSxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgdGVzdHM6IHRoaXMudGVzdHNcbiAgICAgIH0sIHBhbmljLCBuZXh0KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeGVjdXRlcyBhIHNldCBvZiB2YWxpZGF0aW9ucywgZWl0aGVyIHNjaGVtYSwgcHJvZHVjZWQgVGVzdHMgb3IgYSBuZXN0ZWRcbiAgICogc2NoZW1hIHZhbGlkYXRlIHJlc3VsdC5cbiAgICovXG4gIHJ1blRlc3RzKHJ1bk9wdGlvbnMsIHBhbmljLCBuZXh0KSB7XG4gICAgbGV0IGZpcmVkID0gZmFsc2U7XG4gICAgbGV0IHtcbiAgICAgIHRlc3RzLFxuICAgICAgdmFsdWUsXG4gICAgICBvcmlnaW5hbFZhbHVlLFxuICAgICAgcGF0aCxcbiAgICAgIG9wdGlvbnNcbiAgICB9ID0gcnVuT3B0aW9ucztcbiAgICBsZXQgcGFuaWNPbmNlID0gYXJnID0+IHtcbiAgICAgIGlmIChmaXJlZCkgcmV0dXJuO1xuICAgICAgZmlyZWQgPSB0cnVlO1xuICAgICAgcGFuaWMoYXJnLCB2YWx1ZSk7XG4gICAgfTtcbiAgICBsZXQgbmV4dE9uY2UgPSBhcmcgPT4ge1xuICAgICAgaWYgKGZpcmVkKSByZXR1cm47XG4gICAgICBmaXJlZCA9IHRydWU7XG4gICAgICBuZXh0KGFyZywgdmFsdWUpO1xuICAgIH07XG4gICAgbGV0IGNvdW50ID0gdGVzdHMubGVuZ3RoO1xuICAgIGxldCBuZXN0ZWRFcnJvcnMgPSBbXTtcbiAgICBpZiAoIWNvdW50KSByZXR1cm4gbmV4dE9uY2UoW10pO1xuICAgIGxldCBhcmdzID0ge1xuICAgICAgdmFsdWUsXG4gICAgICBvcmlnaW5hbFZhbHVlLFxuICAgICAgcGF0aCxcbiAgICAgIG9wdGlvbnMsXG4gICAgICBzY2hlbWE6IHRoaXNcbiAgICB9O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGVzdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHRlc3QgPSB0ZXN0c1tpXTtcbiAgICAgIHRlc3QoYXJncywgcGFuaWNPbmNlLCBmdW5jdGlvbiBmaW5pc2hUZXN0UnVuKGVycikge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgQXJyYXkuaXNBcnJheShlcnIpID8gbmVzdGVkRXJyb3JzLnB1c2goLi4uZXJyKSA6IG5lc3RlZEVycm9ycy5wdXNoKGVycik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKC0tY291bnQgPD0gMCkge1xuICAgICAgICAgIG5leHRPbmNlKG5lc3RlZEVycm9ycyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBhc05lc3RlZFRlc3Qoe1xuICAgIGtleSxcbiAgICBpbmRleCxcbiAgICBwYXJlbnQsXG4gICAgcGFyZW50UGF0aCxcbiAgICBvcmlnaW5hbFBhcmVudCxcbiAgICBvcHRpb25zXG4gIH0pIHtcbiAgICBjb25zdCBrID0ga2V5ICE9IG51bGwgPyBrZXkgOiBpbmRleDtcbiAgICBpZiAoayA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ011c3QgaW5jbHVkZSBga2V5YCBvciBgaW5kZXhgIGZvciBuZXN0ZWQgdmFsaWRhdGlvbnMnKTtcbiAgICB9XG4gICAgY29uc3QgaXNJbmRleCA9IHR5cGVvZiBrID09PSAnbnVtYmVyJztcbiAgICBsZXQgdmFsdWUgPSBwYXJlbnRba107XG4gICAgY29uc3QgdGVzdE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7XG4gICAgICAvLyBOZXN0ZWQgdmFsaWRhdGlvbnMgZmllbGRzIGFyZSBhbHdheXMgc3RyaWN0OlxuICAgICAgLy8gICAgMS4gcGFyZW50IGlzbid0IHN0cmljdCBzbyB0aGUgY2FzdGluZyB3aWxsIGFsc28gaGF2ZSBjYXN0IGlubmVyIHZhbHVlc1xuICAgICAgLy8gICAgMi4gcGFyZW50IGlzIHN0cmljdCBpbiB3aGljaCBjYXNlIHRoZSBuZXN0ZWQgdmFsdWVzIHdlcmVuJ3QgY2FzdCBlaXRoZXJcbiAgICAgIHN0cmljdDogdHJ1ZSxcbiAgICAgIHBhcmVudCxcbiAgICAgIHZhbHVlLFxuICAgICAgb3JpZ2luYWxWYWx1ZTogb3JpZ2luYWxQYXJlbnRba10sXG4gICAgICAvLyBGSVhNRTogdGVzdHMgZGVwZW5kIG9uIGBpbmRleGAgYmVpbmcgcGFzc2VkIGFyb3VuZCBkZWVwbHksXG4gICAgICAvLyAgIHdlIHNob3VsZCBub3QgbGV0IHRoZSBvcHRpb25zLmtleS9pbmRleCBibGVlZCB0aHJvdWdoXG4gICAgICBrZXk6IHVuZGVmaW5lZCxcbiAgICAgIC8vIGluZGV4OiB1bmRlZmluZWQsXG4gICAgICBbaXNJbmRleCA/ICdpbmRleCcgOiAna2V5J106IGssXG4gICAgICBwYXRoOiBpc0luZGV4IHx8IGsuaW5jbHVkZXMoJy4nKSA/IGAke3BhcmVudFBhdGggfHwgJyd9WyR7aXNJbmRleCA/IGsgOiBgXCIke2t9XCJgfV1gIDogKHBhcmVudFBhdGggPyBgJHtwYXJlbnRQYXRofS5gIDogJycpICsga2V5XG4gICAgfSk7XG4gICAgcmV0dXJuIChfLCBwYW5pYywgbmV4dCkgPT4gdGhpcy5yZXNvbHZlKHRlc3RPcHRpb25zKS5fdmFsaWRhdGUodmFsdWUsIHRlc3RPcHRpb25zLCBwYW5pYywgbmV4dCk7XG4gIH1cbiAgdmFsaWRhdGUodmFsdWUsIG9wdGlvbnMpIHtcbiAgICB2YXIgX29wdGlvbnMkZGlzYWJsZVN0YWNrMjtcbiAgICBsZXQgc2NoZW1hID0gdGhpcy5yZXNvbHZlKE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHtcbiAgICAgIHZhbHVlXG4gICAgfSkpO1xuICAgIGxldCBkaXNhYmxlU3RhY2tUcmFjZSA9IChfb3B0aW9ucyRkaXNhYmxlU3RhY2syID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5kaXNhYmxlU3RhY2tUcmFjZSkgIT0gbnVsbCA/IF9vcHRpb25zJGRpc2FibGVTdGFjazIgOiBzY2hlbWEuc3BlYy5kaXNhYmxlU3RhY2tUcmFjZTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4gc2NoZW1hLl92YWxpZGF0ZSh2YWx1ZSwgb3B0aW9ucywgKGVycm9yLCBwYXJzZWQpID0+IHtcbiAgICAgIGlmIChWYWxpZGF0aW9uRXJyb3IuaXNFcnJvcihlcnJvcikpIGVycm9yLnZhbHVlID0gcGFyc2VkO1xuICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICB9LCAoZXJyb3JzLCB2YWxpZGF0ZWQpID0+IHtcbiAgICAgIGlmIChlcnJvcnMubGVuZ3RoKSByZWplY3QobmV3IFZhbGlkYXRpb25FcnJvcihlcnJvcnMsIHZhbGlkYXRlZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGRpc2FibGVTdGFja1RyYWNlKSk7ZWxzZSByZXNvbHZlKHZhbGlkYXRlZCk7XG4gICAgfSkpO1xuICB9XG4gIHZhbGlkYXRlU3luYyh2YWx1ZSwgb3B0aW9ucykge1xuICAgIHZhciBfb3B0aW9ucyRkaXNhYmxlU3RhY2szO1xuICAgIGxldCBzY2hlbWEgPSB0aGlzLnJlc29sdmUoT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywge1xuICAgICAgdmFsdWVcbiAgICB9KSk7XG4gICAgbGV0IHJlc3VsdDtcbiAgICBsZXQgZGlzYWJsZVN0YWNrVHJhY2UgPSAoX29wdGlvbnMkZGlzYWJsZVN0YWNrMyA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuZGlzYWJsZVN0YWNrVHJhY2UpICE9IG51bGwgPyBfb3B0aW9ucyRkaXNhYmxlU3RhY2szIDogc2NoZW1hLnNwZWMuZGlzYWJsZVN0YWNrVHJhY2U7XG4gICAgc2NoZW1hLl92YWxpZGF0ZSh2YWx1ZSwgT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywge1xuICAgICAgc3luYzogdHJ1ZVxuICAgIH0pLCAoZXJyb3IsIHBhcnNlZCkgPT4ge1xuICAgICAgaWYgKFZhbGlkYXRpb25FcnJvci5pc0Vycm9yKGVycm9yKSkgZXJyb3IudmFsdWUgPSBwYXJzZWQ7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9LCAoZXJyb3JzLCB2YWxpZGF0ZWQpID0+IHtcbiAgICAgIGlmIChlcnJvcnMubGVuZ3RoKSB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKGVycm9ycywgdmFsdWUsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBkaXNhYmxlU3RhY2tUcmFjZSk7XG4gICAgICByZXN1bHQgPSB2YWxpZGF0ZWQ7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBpc1ZhbGlkKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsaWRhdGUodmFsdWUsIG9wdGlvbnMpLnRoZW4oKCkgPT4gdHJ1ZSwgZXJyID0+IHtcbiAgICAgIGlmIChWYWxpZGF0aW9uRXJyb3IuaXNFcnJvcihlcnIpKSByZXR1cm4gZmFsc2U7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfSk7XG4gIH1cbiAgaXNWYWxpZFN5bmModmFsdWUsIG9wdGlvbnMpIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy52YWxpZGF0ZVN5bmModmFsdWUsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoVmFsaWRhdGlvbkVycm9yLmlzRXJyb3IoZXJyKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgfVxuICBfZ2V0RGVmYXVsdChvcHRpb25zKSB7XG4gICAgbGV0IGRlZmF1bHRWYWx1ZSA9IHRoaXMuc3BlYy5kZWZhdWx0O1xuICAgIGlmIChkZWZhdWx0VmFsdWUgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGVvZiBkZWZhdWx0VmFsdWUgPT09ICdmdW5jdGlvbicgPyBkZWZhdWx0VmFsdWUuY2FsbCh0aGlzLCBvcHRpb25zKSA6IGNsb25lKGRlZmF1bHRWYWx1ZSk7XG4gIH1cbiAgZ2V0RGVmYXVsdChvcHRpb25zXG4gIC8vIElmIHNjaGVtYSBpcyBkZWZhdWx0ZWQgd2Uga25vdyBpdCdzIGF0IGxlYXN0IG5vdCB1bmRlZmluZWRcbiAgKSB7XG4gICAgbGV0IHNjaGVtYSA9IHRoaXMucmVzb2x2ZShvcHRpb25zIHx8IHt9KTtcbiAgICByZXR1cm4gc2NoZW1hLl9nZXREZWZhdWx0KG9wdGlvbnMpO1xuICB9XG4gIGRlZmF1bHQoZGVmKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzLl9nZXREZWZhdWx0KCk7XG4gICAgfVxuICAgIGxldCBuZXh0ID0gdGhpcy5jbG9uZSh7XG4gICAgICBkZWZhdWx0OiBkZWZcbiAgICB9KTtcbiAgICByZXR1cm4gbmV4dDtcbiAgfVxuICBzdHJpY3QoaXNTdHJpY3QgPSB0cnVlKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoe1xuICAgICAgc3RyaWN0OiBpc1N0cmljdFxuICAgIH0pO1xuICB9XG4gIG51bGxhYmlsaXR5KG51bGxhYmxlLCBtZXNzYWdlKSB7XG4gICAgY29uc3QgbmV4dCA9IHRoaXMuY2xvbmUoe1xuICAgICAgbnVsbGFibGVcbiAgICB9KTtcbiAgICBuZXh0LmludGVybmFsVGVzdHMubnVsbGFibGUgPSBjcmVhdGVWYWxpZGF0aW9uKHtcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBuYW1lOiAnbnVsbGFibGUnLFxuICAgICAgdGVzdCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgPyB0aGlzLnNjaGVtYS5zcGVjLm51bGxhYmxlIDogdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbmV4dDtcbiAgfVxuICBvcHRpb25hbGl0eShvcHRpb25hbCwgbWVzc2FnZSkge1xuICAgIGNvbnN0IG5leHQgPSB0aGlzLmNsb25lKHtcbiAgICAgIG9wdGlvbmFsXG4gICAgfSk7XG4gICAgbmV4dC5pbnRlcm5hbFRlc3RzLm9wdGlvbmFsaXR5ID0gY3JlYXRlVmFsaWRhdGlvbih7XG4gICAgICBtZXNzYWdlLFxuICAgICAgbmFtZTogJ29wdGlvbmFsaXR5JyxcbiAgICAgIHRlc3QodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyB0aGlzLnNjaGVtYS5zcGVjLm9wdGlvbmFsIDogdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbmV4dDtcbiAgfVxuICBvcHRpb25hbCgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25hbGl0eSh0cnVlKTtcbiAgfVxuICBkZWZpbmVkKG1lc3NhZ2UgPSBtaXhlZC5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9uYWxpdHkoZmFsc2UsIG1lc3NhZ2UpO1xuICB9XG4gIG51bGxhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLm51bGxhYmlsaXR5KHRydWUpO1xuICB9XG4gIG5vbk51bGxhYmxlKG1lc3NhZ2UgPSBtaXhlZC5ub3ROdWxsKSB7XG4gICAgcmV0dXJuIHRoaXMubnVsbGFiaWxpdHkoZmFsc2UsIG1lc3NhZ2UpO1xuICB9XG4gIHJlcXVpcmVkKG1lc3NhZ2UgPSBtaXhlZC5yZXF1aXJlZCkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkud2l0aE11dGF0aW9uKG5leHQgPT4gbmV4dC5ub25OdWxsYWJsZShtZXNzYWdlKS5kZWZpbmVkKG1lc3NhZ2UpKTtcbiAgfVxuICBub3RSZXF1aXJlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLndpdGhNdXRhdGlvbihuZXh0ID0+IG5leHQubnVsbGFibGUoKS5vcHRpb25hbCgpKTtcbiAgfVxuICB0cmFuc2Zvcm0oZm4pIHtcbiAgICBsZXQgbmV4dCA9IHRoaXMuY2xvbmUoKTtcbiAgICBuZXh0LnRyYW5zZm9ybXMucHVzaChmbik7XG4gICAgcmV0dXJuIG5leHQ7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIHRlc3QgZnVuY3Rpb24gdG8gdGhlIHNjaGVtYSdzIHF1ZXVlIG9mIHRlc3RzLlxuICAgKiB0ZXN0cyBjYW4gYmUgZXhjbHVzaXZlIG9yIG5vbi1leGNsdXNpdmUuXG4gICAqXG4gICAqIC0gZXhjbHVzaXZlIHRlc3RzLCB3aWxsIHJlcGxhY2UgYW55IGV4aXN0aW5nIHRlc3RzIG9mIHRoZSBzYW1lIG5hbWUuXG4gICAqIC0gbm9uLWV4Y2x1c2l2ZTogY2FuIGJlIHN0YWNrZWRcbiAgICpcbiAgICogSWYgYSBub24tZXhjbHVzaXZlIHRlc3QgaXMgYWRkZWQgdG8gYSBzY2hlbWEgd2l0aCBhbiBleGNsdXNpdmUgdGVzdCBvZiB0aGUgc2FtZSBuYW1lXG4gICAqIHRoZSBleGNsdXNpdmUgdGVzdCBpcyByZW1vdmVkIGFuZCBmdXJ0aGVyIHRlc3RzIG9mIHRoZSBzYW1lIG5hbWUgd2lsbCBiZSBzdGFja2VkLlxuICAgKlxuICAgKiBJZiBhbiBleGNsdXNpdmUgdGVzdCBpcyBhZGRlZCB0byBhIHNjaGVtYSB3aXRoIG5vbi1leGNsdXNpdmUgdGVzdHMgb2YgdGhlIHNhbWUgbmFtZVxuICAgKiB0aGUgcHJldmlvdXMgdGVzdHMgYXJlIHJlbW92ZWQgYW5kIGZ1cnRoZXIgdGVzdHMgb2YgdGhlIHNhbWUgbmFtZSB3aWxsIHJlcGxhY2UgZWFjaCBvdGhlci5cbiAgICovXG5cbiAgdGVzdCguLi5hcmdzKSB7XG4gICAgbGV0IG9wdHM7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAxKSB7XG4gICAgICBpZiAodHlwZW9mIGFyZ3NbMF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgb3B0cyA9IHtcbiAgICAgICAgICB0ZXN0OiBhcmdzWzBdXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcHRzID0gYXJnc1swXTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGFyZ3MubGVuZ3RoID09PSAyKSB7XG4gICAgICBvcHRzID0ge1xuICAgICAgICBuYW1lOiBhcmdzWzBdLFxuICAgICAgICB0ZXN0OiBhcmdzWzFdXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBvcHRzID0ge1xuICAgICAgICBuYW1lOiBhcmdzWzBdLFxuICAgICAgICBtZXNzYWdlOiBhcmdzWzFdLFxuICAgICAgICB0ZXN0OiBhcmdzWzJdXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAob3B0cy5tZXNzYWdlID09PSB1bmRlZmluZWQpIG9wdHMubWVzc2FnZSA9IG1peGVkLmRlZmF1bHQ7XG4gICAgaWYgKHR5cGVvZiBvcHRzLnRlc3QgIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2B0ZXN0YCBpcyBhIHJlcXVpcmVkIHBhcmFtZXRlcnMnKTtcbiAgICBsZXQgbmV4dCA9IHRoaXMuY2xvbmUoKTtcbiAgICBsZXQgdmFsaWRhdGUgPSBjcmVhdGVWYWxpZGF0aW9uKG9wdHMpO1xuICAgIGxldCBpc0V4Y2x1c2l2ZSA9IG9wdHMuZXhjbHVzaXZlIHx8IG9wdHMubmFtZSAmJiBuZXh0LmV4Y2x1c2l2ZVRlc3RzW29wdHMubmFtZV0gPT09IHRydWU7XG4gICAgaWYgKG9wdHMuZXhjbHVzaXZlKSB7XG4gICAgICBpZiAoIW9wdHMubmFtZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhjbHVzaXZlIHRlc3RzIG11c3QgcHJvdmlkZSBhIHVuaXF1ZSBgbmFtZWAgaWRlbnRpZnlpbmcgdGhlIHRlc3QnKTtcbiAgICB9XG4gICAgaWYgKG9wdHMubmFtZSkgbmV4dC5leGNsdXNpdmVUZXN0c1tvcHRzLm5hbWVdID0gISFvcHRzLmV4Y2x1c2l2ZTtcbiAgICBuZXh0LnRlc3RzID0gbmV4dC50ZXN0cy5maWx0ZXIoZm4gPT4ge1xuICAgICAgaWYgKGZuLk9QVElPTlMubmFtZSA9PT0gb3B0cy5uYW1lKSB7XG4gICAgICAgIGlmIChpc0V4Y2x1c2l2ZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoZm4uT1BUSU9OUy50ZXN0ID09PSB2YWxpZGF0ZS5PUFRJT05TLnRlc3QpIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICAgIG5leHQudGVzdHMucHVzaCh2YWxpZGF0ZSk7XG4gICAgcmV0dXJuIG5leHQ7XG4gIH1cbiAgd2hlbihrZXlzLCBvcHRpb25zKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGtleXMpICYmIHR5cGVvZiBrZXlzICE9PSAnc3RyaW5nJykge1xuICAgICAgb3B0aW9ucyA9IGtleXM7XG4gICAgICBrZXlzID0gJy4nO1xuICAgIH1cbiAgICBsZXQgbmV4dCA9IHRoaXMuY2xvbmUoKTtcbiAgICBsZXQgZGVwcyA9IHRvQXJyYXkoa2V5cykubWFwKGtleSA9PiBuZXcgUmVmZXJlbmNlKGtleSkpO1xuICAgIGRlcHMuZm9yRWFjaChkZXAgPT4ge1xuICAgICAgLy8gQHRzLWlnbm9yZSByZWFkb25seSBhcnJheVxuICAgICAgaWYgKGRlcC5pc1NpYmxpbmcpIG5leHQuZGVwcy5wdXNoKGRlcC5rZXkpO1xuICAgIH0pO1xuICAgIG5leHQuY29uZGl0aW9ucy5wdXNoKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nID8gbmV3IENvbmRpdGlvbihkZXBzLCBvcHRpb25zKSA6IENvbmRpdGlvbi5mcm9tT3B0aW9ucyhkZXBzLCBvcHRpb25zKSk7XG4gICAgcmV0dXJuIG5leHQ7XG4gIH1cbiAgdHlwZUVycm9yKG1lc3NhZ2UpIHtcbiAgICBsZXQgbmV4dCA9IHRoaXMuY2xvbmUoKTtcbiAgICBuZXh0LmludGVybmFsVGVzdHMudHlwZUVycm9yID0gY3JlYXRlVmFsaWRhdGlvbih7XG4gICAgICBtZXNzYWdlLFxuICAgICAgbmFtZTogJ3R5cGVFcnJvcicsXG4gICAgICBza2lwQWJzZW50OiB0cnVlLFxuICAgICAgdGVzdCh2YWx1ZSkge1xuICAgICAgICBpZiAoIXRoaXMuc2NoZW1hLl90eXBlQ2hlY2sodmFsdWUpKSByZXR1cm4gdGhpcy5jcmVhdGVFcnJvcih7XG4gICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICB0eXBlOiB0aGlzLnNjaGVtYS50eXBlXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG5leHQ7XG4gIH1cbiAgb25lT2YoZW51bXMsIG1lc3NhZ2UgPSBtaXhlZC5vbmVPZikge1xuICAgIGxldCBuZXh0ID0gdGhpcy5jbG9uZSgpO1xuICAgIGVudW1zLmZvckVhY2godmFsID0+IHtcbiAgICAgIG5leHQuX3doaXRlbGlzdC5hZGQodmFsKTtcbiAgICAgIG5leHQuX2JsYWNrbGlzdC5kZWxldGUodmFsKTtcbiAgICB9KTtcbiAgICBuZXh0LmludGVybmFsVGVzdHMud2hpdGVMaXN0ID0gY3JlYXRlVmFsaWRhdGlvbih7XG4gICAgICBtZXNzYWdlLFxuICAgICAgbmFtZTogJ29uZU9mJyxcbiAgICAgIHNraXBBYnNlbnQ6IHRydWUsXG4gICAgICB0ZXN0KHZhbHVlKSB7XG4gICAgICAgIGxldCB2YWxpZHMgPSB0aGlzLnNjaGVtYS5fd2hpdGVsaXN0O1xuICAgICAgICBsZXQgcmVzb2x2ZWQgPSB2YWxpZHMucmVzb2x2ZUFsbCh0aGlzLnJlc29sdmUpO1xuICAgICAgICByZXR1cm4gcmVzb2x2ZWQuaW5jbHVkZXModmFsdWUpID8gdHJ1ZSA6IHRoaXMuY3JlYXRlRXJyb3Ioe1xuICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgdmFsdWVzOiBBcnJheS5mcm9tKHZhbGlkcykuam9pbignLCAnKSxcbiAgICAgICAgICAgIHJlc29sdmVkXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbmV4dDtcbiAgfVxuICBub3RPbmVPZihlbnVtcywgbWVzc2FnZSA9IG1peGVkLm5vdE9uZU9mKSB7XG4gICAgbGV0IG5leHQgPSB0aGlzLmNsb25lKCk7XG4gICAgZW51bXMuZm9yRWFjaCh2YWwgPT4ge1xuICAgICAgbmV4dC5fYmxhY2tsaXN0LmFkZCh2YWwpO1xuICAgICAgbmV4dC5fd2hpdGVsaXN0LmRlbGV0ZSh2YWwpO1xuICAgIH0pO1xuICAgIG5leHQuaW50ZXJuYWxUZXN0cy5ibGFja2xpc3QgPSBjcmVhdGVWYWxpZGF0aW9uKHtcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBuYW1lOiAnbm90T25lT2YnLFxuICAgICAgdGVzdCh2YWx1ZSkge1xuICAgICAgICBsZXQgaW52YWxpZHMgPSB0aGlzLnNjaGVtYS5fYmxhY2tsaXN0O1xuICAgICAgICBsZXQgcmVzb2x2ZWQgPSBpbnZhbGlkcy5yZXNvbHZlQWxsKHRoaXMucmVzb2x2ZSk7XG4gICAgICAgIGlmIChyZXNvbHZlZC5pbmNsdWRlcyh2YWx1ZSkpIHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKHtcbiAgICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgIHZhbHVlczogQXJyYXkuZnJvbShpbnZhbGlkcykuam9pbignLCAnKSxcbiAgICAgICAgICAgIHJlc29sdmVkXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG5leHQ7XG4gIH1cbiAgc3RyaXAoc3RyaXAgPSB0cnVlKSB7XG4gICAgbGV0IG5leHQgPSB0aGlzLmNsb25lKCk7XG4gICAgbmV4dC5zcGVjLnN0cmlwID0gc3RyaXA7XG4gICAgcmV0dXJuIG5leHQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGEgc2VyaWFsaXplZCBkZXNjcmlwdGlvbiBvZiB0aGUgc2NoZW1hIGluY2x1ZGluZyB2YWxpZGF0aW9ucywgZmxhZ3MsIHR5cGVzIGV0Yy5cbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMgUHJvdmlkZSBhbnkgbmVlZGVkIGNvbnRleHQgZm9yIHJlc29sdmluZyBydW50aW1lIHNjaGVtYSBhbHRlcmF0aW9ucyAobGF6eSwgd2hlbiBjb25kaXRpb25zLCBldGMpLlxuICAgKi9cbiAgZGVzY3JpYmUob3B0aW9ucykge1xuICAgIGNvbnN0IG5leHQgPSAob3B0aW9ucyA/IHRoaXMucmVzb2x2ZShvcHRpb25zKSA6IHRoaXMpLmNsb25lKCk7XG4gICAgY29uc3Qge1xuICAgICAgbGFiZWwsXG4gICAgICBtZXRhLFxuICAgICAgb3B0aW9uYWwsXG4gICAgICBudWxsYWJsZVxuICAgIH0gPSBuZXh0LnNwZWM7XG4gICAgY29uc3QgZGVzY3JpcHRpb24gPSB7XG4gICAgICBtZXRhLFxuICAgICAgbGFiZWwsXG4gICAgICBvcHRpb25hbCxcbiAgICAgIG51bGxhYmxlLFxuICAgICAgZGVmYXVsdDogbmV4dC5nZXREZWZhdWx0KG9wdGlvbnMpLFxuICAgICAgdHlwZTogbmV4dC50eXBlLFxuICAgICAgb25lT2Y6IG5leHQuX3doaXRlbGlzdC5kZXNjcmliZSgpLFxuICAgICAgbm90T25lT2Y6IG5leHQuX2JsYWNrbGlzdC5kZXNjcmliZSgpLFxuICAgICAgdGVzdHM6IG5leHQudGVzdHMubWFwKGZuID0+ICh7XG4gICAgICAgIG5hbWU6IGZuLk9QVElPTlMubmFtZSxcbiAgICAgICAgcGFyYW1zOiBmbi5PUFRJT05TLnBhcmFtc1xuICAgICAgfSkpLmZpbHRlcigobiwgaWR4LCBsaXN0KSA9PiBsaXN0LmZpbmRJbmRleChjID0+IGMubmFtZSA9PT0gbi5uYW1lKSA9PT0gaWR4KVxuICAgIH07XG4gICAgcmV0dXJuIGRlc2NyaXB0aW9uO1xuICB9XG59XG4vLyBAdHMtZXhwZWN0LWVycm9yXG5TY2hlbWEucHJvdG90eXBlLl9faXNZdXBTY2hlbWFfXyA9IHRydWU7XG5mb3IgKGNvbnN0IG1ldGhvZCBvZiBbJ3ZhbGlkYXRlJywgJ3ZhbGlkYXRlU3luYyddKSBTY2hlbWEucHJvdG90eXBlW2Ake21ldGhvZH1BdGBdID0gZnVuY3Rpb24gKHBhdGgsIHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIHBhcmVudCxcbiAgICBwYXJlbnRQYXRoLFxuICAgIHNjaGVtYVxuICB9ID0gZ2V0SW4odGhpcywgcGF0aCwgdmFsdWUsIG9wdGlvbnMuY29udGV4dCk7XG4gIHJldHVybiBzY2hlbWFbbWV0aG9kXShwYXJlbnQgJiYgcGFyZW50W3BhcmVudFBhdGhdLCBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7XG4gICAgcGFyZW50LFxuICAgIHBhdGhcbiAgfSkpO1xufTtcbmZvciAoY29uc3QgYWxpYXMgb2YgWydlcXVhbHMnLCAnaXMnXSkgU2NoZW1hLnByb3RvdHlwZVthbGlhc10gPSBTY2hlbWEucHJvdG90eXBlLm9uZU9mO1xuZm9yIChjb25zdCBhbGlhcyBvZiBbJ25vdCcsICdub3BlJ10pIFNjaGVtYS5wcm90b3R5cGVbYWxpYXNdID0gU2NoZW1hLnByb3RvdHlwZS5ub3RPbmVPZjtcblxuY29uc3QgcmV0dXJuc1RydWUgPSAoKSA9PiB0cnVlO1xuZnVuY3Rpb24gY3JlYXRlJDgoc3BlYykge1xuICByZXR1cm4gbmV3IE1peGVkU2NoZW1hKHNwZWMpO1xufVxuY2xhc3MgTWl4ZWRTY2hlbWEgZXh0ZW5kcyBTY2hlbWEge1xuICBjb25zdHJ1Y3RvcihzcGVjKSB7XG4gICAgc3VwZXIodHlwZW9mIHNwZWMgPT09ICdmdW5jdGlvbicgPyB7XG4gICAgICB0eXBlOiAnbWl4ZWQnLFxuICAgICAgY2hlY2s6IHNwZWNcbiAgICB9IDogT2JqZWN0LmFzc2lnbih7XG4gICAgICB0eXBlOiAnbWl4ZWQnLFxuICAgICAgY2hlY2s6IHJldHVybnNUcnVlXG4gICAgfSwgc3BlYykpO1xuICB9XG59XG5jcmVhdGUkOC5wcm90b3R5cGUgPSBNaXhlZFNjaGVtYS5wcm90b3R5cGU7XG5cbmZ1bmN0aW9uIGNyZWF0ZSQ3KCkge1xuICByZXR1cm4gbmV3IEJvb2xlYW5TY2hlbWEoKTtcbn1cbmNsYXNzIEJvb2xlYW5TY2hlbWEgZXh0ZW5kcyBTY2hlbWEge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcih7XG4gICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICBjaGVjayh2KSB7XG4gICAgICAgIGlmICh2IGluc3RhbmNlb2YgQm9vbGVhbikgdiA9IHYudmFsdWVPZigpO1xuICAgICAgICByZXR1cm4gdHlwZW9mIHYgPT09ICdib29sZWFuJztcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLndpdGhNdXRhdGlvbigoKSA9PiB7XG4gICAgICB0aGlzLnRyYW5zZm9ybSgodmFsdWUsIF9yYXcsIGN0eCkgPT4ge1xuICAgICAgICBpZiAoY3R4LnNwZWMuY29lcmNlICYmICFjdHguaXNUeXBlKHZhbHVlKSkge1xuICAgICAgICAgIGlmICgvXih0cnVlfDEpJC9pLnRlc3QoU3RyaW5nKHZhbHVlKSkpIHJldHVybiB0cnVlO1xuICAgICAgICAgIGlmICgvXihmYWxzZXwwKSQvaS50ZXN0KFN0cmluZyh2YWx1ZSkpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgaXNUcnVlKG1lc3NhZ2UgPSBib29sZWFuLmlzVmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy50ZXN0KHtcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBuYW1lOiAnaXMtdmFsdWUnLFxuICAgICAgZXhjbHVzaXZlOiB0cnVlLFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIHZhbHVlOiAndHJ1ZSdcbiAgICAgIH0sXG4gICAgICB0ZXN0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBpc0Fic2VudCh2YWx1ZSkgfHwgdmFsdWUgPT09IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgaXNGYWxzZShtZXNzYWdlID0gYm9vbGVhbi5pc1ZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMudGVzdCh7XG4gICAgICBtZXNzYWdlLFxuICAgICAgbmFtZTogJ2lzLXZhbHVlJyxcbiAgICAgIGV4Y2x1c2l2ZTogdHJ1ZSxcbiAgICAgIHBhcmFtczoge1xuICAgICAgICB2YWx1ZTogJ2ZhbHNlJ1xuICAgICAgfSxcbiAgICAgIHRlc3QodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGlzQWJzZW50KHZhbHVlKSB8fCB2YWx1ZSA9PT0gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZGVmYXVsdChkZWYpIHtcbiAgICByZXR1cm4gc3VwZXIuZGVmYXVsdChkZWYpO1xuICB9XG4gIGRlZmluZWQobXNnKSB7XG4gICAgcmV0dXJuIHN1cGVyLmRlZmluZWQobXNnKTtcbiAgfVxuICBvcHRpb25hbCgpIHtcbiAgICByZXR1cm4gc3VwZXIub3B0aW9uYWwoKTtcbiAgfVxuICByZXF1aXJlZChtc2cpIHtcbiAgICByZXR1cm4gc3VwZXIucmVxdWlyZWQobXNnKTtcbiAgfVxuICBub3RSZXF1aXJlZCgpIHtcbiAgICByZXR1cm4gc3VwZXIubm90UmVxdWlyZWQoKTtcbiAgfVxuICBudWxsYWJsZSgpIHtcbiAgICByZXR1cm4gc3VwZXIubnVsbGFibGUoKTtcbiAgfVxuICBub25OdWxsYWJsZShtc2cpIHtcbiAgICByZXR1cm4gc3VwZXIubm9uTnVsbGFibGUobXNnKTtcbiAgfVxuICBzdHJpcCh2KSB7XG4gICAgcmV0dXJuIHN1cGVyLnN0cmlwKHYpO1xuICB9XG59XG5jcmVhdGUkNy5wcm90b3R5cGUgPSBCb29sZWFuU2NoZW1hLnByb3RvdHlwZTtcblxuLyoqXG4gKiBUaGlzIGZpbGUgaXMgYSBtb2RpZmllZCB2ZXJzaW9uIG9mIHRoZSBmaWxlIGZyb20gdGhlIGZvbGxvd2luZyByZXBvc2l0b3J5OlxuICogRGF0ZS5wYXJzZSB3aXRoIHByb2dyZXNzaXZlIGVuaGFuY2VtZW50IGZvciBJU08gODYwMSA8aHR0cHM6Ly9naXRodWIuY29tL2Nzbm92ZXIvanMtaXNvODYwMT5cbiAqIE5PTi1DT05GT1JNQU5UIEVESVRJT04uXG4gKiDCqSAyMDExIENvbGluIFNub3ZlciA8aHR0cDovL3pldGFmbGVldC5jb20+XG4gKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqL1xuXG4vLyBwcmV0dGllci1pZ25vcmVcbi8vICAgICAgICAgICAgICAgIDEgWVlZWSAgICAgICAgICAgICAgICAyIE1NICAgICAgICAzIEREICAgICAgICAgICAgICA0IEhIICAgICA1IG1tICAgICAgICA2IHNzICAgICAgICAgICA3IG1zZWMgICAgICAgICA4IFogOSDCsSAgIDEwIHR6SEggICAgMTEgdHptbVxuY29uc3QgaXNvUmVnID0gL14oXFxkezR9fFsrLV1cXGR7Nn0pKD86LT8oXFxkezJ9KSg/Oi0/KFxcZHsyfSkpPyk/KD86WyBUXT8oXFxkezJ9KTo/KFxcZHsyfSkoPzo6PyhcXGR7Mn0pKD86WywuXShcXGR7MSx9KSk/KT8oPzooWil8KFsrLV0pKFxcZHsyfSkoPzo6PyhcXGR7Mn0pKT8pPyk/JC87XG5mdW5jdGlvbiBwYXJzZUlzb0RhdGUoZGF0ZSkge1xuICBjb25zdCBzdHJ1Y3QgPSBwYXJzZURhdGVTdHJ1Y3QoZGF0ZSk7XG4gIGlmICghc3RydWN0KSByZXR1cm4gRGF0ZS5wYXJzZSA/IERhdGUucGFyc2UoZGF0ZSkgOiBOdW1iZXIuTmFOO1xuXG4gIC8vIHRpbWVzdGFtcHMgd2l0aG91dCB0aW1lem9uZSBpZGVudGlmaWVycyBzaG91bGQgYmUgY29uc2lkZXJlZCBsb2NhbCB0aW1lXG4gIGlmIChzdHJ1Y3QueiA9PT0gdW5kZWZpbmVkICYmIHN0cnVjdC5wbHVzTWludXMgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBuZXcgRGF0ZShzdHJ1Y3QueWVhciwgc3RydWN0Lm1vbnRoLCBzdHJ1Y3QuZGF5LCBzdHJ1Y3QuaG91ciwgc3RydWN0Lm1pbnV0ZSwgc3RydWN0LnNlY29uZCwgc3RydWN0Lm1pbGxpc2Vjb25kKS52YWx1ZU9mKCk7XG4gIH1cbiAgbGV0IHRvdGFsTWludXRlc09mZnNldCA9IDA7XG4gIGlmIChzdHJ1Y3QueiAhPT0gJ1onICYmIHN0cnVjdC5wbHVzTWludXMgIT09IHVuZGVmaW5lZCkge1xuICAgIHRvdGFsTWludXRlc09mZnNldCA9IHN0cnVjdC5ob3VyT2Zmc2V0ICogNjAgKyBzdHJ1Y3QubWludXRlT2Zmc2V0O1xuICAgIGlmIChzdHJ1Y3QucGx1c01pbnVzID09PSAnKycpIHRvdGFsTWludXRlc09mZnNldCA9IDAgLSB0b3RhbE1pbnV0ZXNPZmZzZXQ7XG4gIH1cbiAgcmV0dXJuIERhdGUuVVRDKHN0cnVjdC55ZWFyLCBzdHJ1Y3QubW9udGgsIHN0cnVjdC5kYXksIHN0cnVjdC5ob3VyLCBzdHJ1Y3QubWludXRlICsgdG90YWxNaW51dGVzT2Zmc2V0LCBzdHJ1Y3Quc2Vjb25kLCBzdHJ1Y3QubWlsbGlzZWNvbmQpO1xufVxuZnVuY3Rpb24gcGFyc2VEYXRlU3RydWN0KGRhdGUpIHtcbiAgdmFyIF9yZWdleFJlc3VsdCQ3JGxlbmd0aCwgX3JlZ2V4UmVzdWx0JDtcbiAgY29uc3QgcmVnZXhSZXN1bHQgPSBpc29SZWcuZXhlYyhkYXRlKTtcbiAgaWYgKCFyZWdleFJlc3VsdCkgcmV0dXJuIG51bGw7XG5cbiAgLy8gdXNlIG9mIHRvTnVtYmVyKCkgYXZvaWRzIE5hTiB0aW1lc3RhbXBzIGNhdXNlZCBieSDigJx1bmRlZmluZWTigJ1cbiAgLy8gdmFsdWVzIGJlaW5nIHBhc3NlZCB0byBEYXRlIGNvbnN0cnVjdG9yXG4gIHJldHVybiB7XG4gICAgeWVhcjogdG9OdW1iZXIocmVnZXhSZXN1bHRbMV0pLFxuICAgIG1vbnRoOiB0b051bWJlcihyZWdleFJlc3VsdFsyXSwgMSkgLSAxLFxuICAgIGRheTogdG9OdW1iZXIocmVnZXhSZXN1bHRbM10sIDEpLFxuICAgIGhvdXI6IHRvTnVtYmVyKHJlZ2V4UmVzdWx0WzRdKSxcbiAgICBtaW51dGU6IHRvTnVtYmVyKHJlZ2V4UmVzdWx0WzVdKSxcbiAgICBzZWNvbmQ6IHRvTnVtYmVyKHJlZ2V4UmVzdWx0WzZdKSxcbiAgICBtaWxsaXNlY29uZDogcmVnZXhSZXN1bHRbN10gP1xuICAgIC8vIGFsbG93IGFyYml0cmFyeSBzdWItc2Vjb25kIHByZWNpc2lvbiBiZXlvbmQgbWlsbGlzZWNvbmRzXG4gICAgdG9OdW1iZXIocmVnZXhSZXN1bHRbN10uc3Vic3RyaW5nKDAsIDMpKSA6IDAsXG4gICAgcHJlY2lzaW9uOiAoX3JlZ2V4UmVzdWx0JDckbGVuZ3RoID0gKF9yZWdleFJlc3VsdCQgPSByZWdleFJlc3VsdFs3XSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9yZWdleFJlc3VsdCQubGVuZ3RoKSAhPSBudWxsID8gX3JlZ2V4UmVzdWx0JDckbGVuZ3RoIDogdW5kZWZpbmVkLFxuICAgIHo6IHJlZ2V4UmVzdWx0WzhdIHx8IHVuZGVmaW5lZCxcbiAgICBwbHVzTWludXM6IHJlZ2V4UmVzdWx0WzldIHx8IHVuZGVmaW5lZCxcbiAgICBob3VyT2Zmc2V0OiB0b051bWJlcihyZWdleFJlc3VsdFsxMF0pLFxuICAgIG1pbnV0ZU9mZnNldDogdG9OdW1iZXIocmVnZXhSZXN1bHRbMTFdKVxuICB9O1xufVxuZnVuY3Rpb24gdG9OdW1iZXIoc3RyLCBkZWZhdWx0VmFsdWUgPSAwKSB7XG4gIHJldHVybiBOdW1iZXIoc3RyKSB8fCBkZWZhdWx0VmFsdWU7XG59XG5cbi8vIFRha2VuIGZyb20gSFRNTCBzcGVjOiBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9pbnB1dC5odG1sI3ZhbGlkLWUtbWFpbC1hZGRyZXNzXG5sZXQgckVtYWlsID1cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuL15bYS16QS1aMC05LiEjJCUmJyorXFwvPT9eX2B7fH1+LV0rQFthLXpBLVowLTldKD86W2EtekEtWjAtOS1dezAsNjF9W2EtekEtWjAtOV0pPyg/OlxcLlthLXpBLVowLTldKD86W2EtekEtWjAtOS1dezAsNjF9W2EtekEtWjAtOV0pPykqJC87XG5sZXQgclVybCA9XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbi9eKChodHRwcz98ZnRwKTopP1xcL1xcLygoKChbYS16XXxcXGR8LXxcXC58X3x+fFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKXwoJVtcXGRhLWZdezJ9KXxbIVxcJCYnXFwoXFwpXFwqXFwrLDs9XXw6KSpAKT8oKChcXGR8WzEtOV1cXGR8MVxcZFxcZHwyWzAtNF1cXGR8MjVbMC01XSlcXC4oXFxkfFsxLTldXFxkfDFcXGRcXGR8MlswLTRdXFxkfDI1WzAtNV0pXFwuKFxcZHxbMS05XVxcZHwxXFxkXFxkfDJbMC00XVxcZHwyNVswLTVdKVxcLihcXGR8WzEtOV1cXGR8MVxcZFxcZHwyWzAtNF1cXGR8MjVbMC01XSkpfCgoKFthLXpdfFxcZHxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSl8KChbYS16XXxcXGR8W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKFthLXpdfFxcZHwtfFxcLnxffH58W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKihbYS16XXxcXGR8W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKSlcXC4pKygoW2Etel18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pfCgoW2Etel18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKFthLXpdfFxcZHwtfFxcLnxffH58W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKihbYS16XXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkpKVxcLj8pKDpcXGQqKT8pKFxcLygoKFthLXpdfFxcZHwtfFxcLnxffH58W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pfCglW1xcZGEtZl17Mn0pfFshXFwkJidcXChcXClcXCpcXCssOz1dfDp8QCkrKFxcLygoW2Etel18XFxkfC18XFwufF98fnxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSl8KCVbXFxkYS1mXXsyfSl8WyFcXCQmJ1xcKFxcKVxcKlxcKyw7PV18OnxAKSopKik/KT8oXFw/KCgoW2Etel18XFxkfC18XFwufF98fnxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSl8KCVbXFxkYS1mXXsyfSl8WyFcXCQmJ1xcKFxcKVxcKlxcKyw7PV18OnxAKXxbXFx1RTAwMC1cXHVGOEZGXXxcXC98XFw/KSopPyhcXCMoKChbYS16XXxcXGR8LXxcXC58X3x+fFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKXwoJVtcXGRhLWZdezJ9KXxbIVxcJCYnXFwoXFwpXFwqXFwrLDs9XXw6fEApfFxcL3xcXD8pKik/JC9pO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbmxldCByVVVJRCA9IC9eKD86WzAtOWEtZl17OH0tWzAtOWEtZl17NH0tWzEtNV1bMC05YS1mXXszfS1bODlhYl1bMC05YS1mXXszfS1bMC05YS1mXXsxMn18MDAwMDAwMDAtMDAwMC0wMDAwLTAwMDAtMDAwMDAwMDAwMDAwKSQvaTtcbmxldCB5ZWFyTW9udGhEYXkgPSAnXlxcXFxkezR9LVxcXFxkezJ9LVxcXFxkezJ9JztcbmxldCBob3VyTWludXRlU2Vjb25kID0gJ1xcXFxkezJ9OlxcXFxkezJ9OlxcXFxkezJ9JztcbmxldCB6T3JPZmZzZXQgPSAnKChbKy1dXFxcXGR7Mn0oOj9cXFxcZHsyfSk/KXxaKSc7XG5sZXQgcklzb0RhdGVUaW1lID0gbmV3IFJlZ0V4cChgJHt5ZWFyTW9udGhEYXl9VCR7aG91ck1pbnV0ZVNlY29uZH0oXFxcXC5cXFxcZCspPyR7ek9yT2Zmc2V0fSRgKTtcbmxldCBpc1RyaW1tZWQgPSB2YWx1ZSA9PiBpc0Fic2VudCh2YWx1ZSkgfHwgdmFsdWUgPT09IHZhbHVlLnRyaW0oKTtcbmxldCBvYmpTdHJpbmdUYWcgPSB7fS50b1N0cmluZygpO1xuZnVuY3Rpb24gY3JlYXRlJDYoKSB7XG4gIHJldHVybiBuZXcgU3RyaW5nU2NoZW1hKCk7XG59XG5jbGFzcyBTdHJpbmdTY2hlbWEgZXh0ZW5kcyBTY2hlbWEge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcih7XG4gICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgIGNoZWNrKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFN0cmluZykgdmFsdWUgPSB2YWx1ZS52YWx1ZU9mKCk7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMud2l0aE11dGF0aW9uKCgpID0+IHtcbiAgICAgIHRoaXMudHJhbnNmb3JtKCh2YWx1ZSwgX3JhdywgY3R4KSA9PiB7XG4gICAgICAgIGlmICghY3R4LnNwZWMuY29lcmNlIHx8IGN0eC5pc1R5cGUodmFsdWUpKSByZXR1cm4gdmFsdWU7XG5cbiAgICAgICAgLy8gZG9uJ3QgZXZlciBjb252ZXJ0IGFycmF5c1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHJldHVybiB2YWx1ZTtcbiAgICAgICAgY29uc3Qgc3RyVmFsdWUgPSB2YWx1ZSAhPSBudWxsICYmIHZhbHVlLnRvU3RyaW5nID8gdmFsdWUudG9TdHJpbmcoKSA6IHZhbHVlO1xuXG4gICAgICAgIC8vIG5vIG9uZSB3YW50cyBwbGFpbiBvYmplY3RzIGNvbnZlcnRlZCB0byBbT2JqZWN0IG9iamVjdF1cbiAgICAgICAgaWYgKHN0clZhbHVlID09PSBvYmpTdHJpbmdUYWcpIHJldHVybiB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHN0clZhbHVlO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgcmVxdWlyZWQobWVzc2FnZSkge1xuICAgIHJldHVybiBzdXBlci5yZXF1aXJlZChtZXNzYWdlKS53aXRoTXV0YXRpb24oc2NoZW1hID0+IHNjaGVtYS50ZXN0KHtcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UgfHwgbWl4ZWQucmVxdWlyZWQsXG4gICAgICBuYW1lOiAncmVxdWlyZWQnLFxuICAgICAgc2tpcEFic2VudDogdHJ1ZSxcbiAgICAgIHRlc3Q6IHZhbHVlID0+ICEhdmFsdWUubGVuZ3RoXG4gICAgfSkpO1xuICB9XG4gIG5vdFJlcXVpcmVkKCkge1xuICAgIHJldHVybiBzdXBlci5ub3RSZXF1aXJlZCgpLndpdGhNdXRhdGlvbihzY2hlbWEgPT4ge1xuICAgICAgc2NoZW1hLnRlc3RzID0gc2NoZW1hLnRlc3RzLmZpbHRlcih0ID0+IHQuT1BUSU9OUy5uYW1lICE9PSAncmVxdWlyZWQnKTtcbiAgICAgIHJldHVybiBzY2hlbWE7XG4gICAgfSk7XG4gIH1cbiAgbGVuZ3RoKGxlbmd0aCwgbWVzc2FnZSA9IHN0cmluZy5sZW5ndGgpIHtcbiAgICByZXR1cm4gdGhpcy50ZXN0KHtcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBuYW1lOiAnbGVuZ3RoJyxcbiAgICAgIGV4Y2x1c2l2ZTogdHJ1ZSxcbiAgICAgIHBhcmFtczoge1xuICAgICAgICBsZW5ndGhcbiAgICAgIH0sXG4gICAgICBza2lwQWJzZW50OiB0cnVlLFxuICAgICAgdGVzdCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUubGVuZ3RoID09PSB0aGlzLnJlc29sdmUobGVuZ3RoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBtaW4obWluLCBtZXNzYWdlID0gc3RyaW5nLm1pbikge1xuICAgIHJldHVybiB0aGlzLnRlc3Qoe1xuICAgICAgbWVzc2FnZSxcbiAgICAgIG5hbWU6ICdtaW4nLFxuICAgICAgZXhjbHVzaXZlOiB0cnVlLFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIG1pblxuICAgICAgfSxcbiAgICAgIHNraXBBYnNlbnQ6IHRydWUsXG4gICAgICB0ZXN0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5sZW5ndGggPj0gdGhpcy5yZXNvbHZlKG1pbik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgbWF4KG1heCwgbWVzc2FnZSA9IHN0cmluZy5tYXgpIHtcbiAgICByZXR1cm4gdGhpcy50ZXN0KHtcbiAgICAgIG5hbWU6ICdtYXgnLFxuICAgICAgZXhjbHVzaXZlOiB0cnVlLFxuICAgICAgbWVzc2FnZSxcbiAgICAgIHBhcmFtczoge1xuICAgICAgICBtYXhcbiAgICAgIH0sXG4gICAgICBza2lwQWJzZW50OiB0cnVlLFxuICAgICAgdGVzdCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUubGVuZ3RoIDw9IHRoaXMucmVzb2x2ZShtYXgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIG1hdGNoZXMocmVnZXgsIG9wdGlvbnMpIHtcbiAgICBsZXQgZXhjbHVkZUVtcHR5U3RyaW5nID0gZmFsc2U7XG4gICAgbGV0IG1lc3NhZ2U7XG4gICAgbGV0IG5hbWU7XG4gICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgKHtcbiAgICAgICAgICBleGNsdWRlRW1wdHlTdHJpbmcgPSBmYWxzZSxcbiAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgIG5hbWVcbiAgICAgICAgfSA9IG9wdGlvbnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWVzc2FnZSA9IG9wdGlvbnM7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRlc3Qoe1xuICAgICAgbmFtZTogbmFtZSB8fCAnbWF0Y2hlcycsXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlIHx8IHN0cmluZy5tYXRjaGVzLFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIHJlZ2V4XG4gICAgICB9LFxuICAgICAgc2tpcEFic2VudDogdHJ1ZSxcbiAgICAgIHRlc3Q6IHZhbHVlID0+IHZhbHVlID09PSAnJyAmJiBleGNsdWRlRW1wdHlTdHJpbmcgfHwgdmFsdWUuc2VhcmNoKHJlZ2V4KSAhPT0gLTFcbiAgICB9KTtcbiAgfVxuICBlbWFpbChtZXNzYWdlID0gc3RyaW5nLmVtYWlsKSB7XG4gICAgcmV0dXJuIHRoaXMubWF0Y2hlcyhyRW1haWwsIHtcbiAgICAgIG5hbWU6ICdlbWFpbCcsXG4gICAgICBtZXNzYWdlLFxuICAgICAgZXhjbHVkZUVtcHR5U3RyaW5nOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgdXJsKG1lc3NhZ2UgPSBzdHJpbmcudXJsKSB7XG4gICAgcmV0dXJuIHRoaXMubWF0Y2hlcyhyVXJsLCB7XG4gICAgICBuYW1lOiAndXJsJyxcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBleGNsdWRlRW1wdHlTdHJpbmc6IHRydWVcbiAgICB9KTtcbiAgfVxuICB1dWlkKG1lc3NhZ2UgPSBzdHJpbmcudXVpZCkge1xuICAgIHJldHVybiB0aGlzLm1hdGNoZXMoclVVSUQsIHtcbiAgICAgIG5hbWU6ICd1dWlkJyxcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBleGNsdWRlRW1wdHlTdHJpbmc6IGZhbHNlXG4gICAgfSk7XG4gIH1cbiAgZGF0ZXRpbWUob3B0aW9ucykge1xuICAgIGxldCBtZXNzYWdlID0gJyc7XG4gICAgbGV0IGFsbG93T2Zmc2V0O1xuICAgIGxldCBwcmVjaXNpb247XG4gICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgKHtcbiAgICAgICAgICBtZXNzYWdlID0gJycsXG4gICAgICAgICAgYWxsb3dPZmZzZXQgPSBmYWxzZSxcbiAgICAgICAgICBwcmVjaXNpb24gPSB1bmRlZmluZWRcbiAgICAgICAgfSA9IG9wdGlvbnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWVzc2FnZSA9IG9wdGlvbnM7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm1hdGNoZXMocklzb0RhdGVUaW1lLCB7XG4gICAgICBuYW1lOiAnZGF0ZXRpbWUnLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZSB8fCBzdHJpbmcuZGF0ZXRpbWUsXG4gICAgICBleGNsdWRlRW1wdHlTdHJpbmc6IHRydWVcbiAgICB9KS50ZXN0KHtcbiAgICAgIG5hbWU6ICdkYXRldGltZV9vZmZzZXQnLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZSB8fCBzdHJpbmcuZGF0ZXRpbWVfb2Zmc2V0LFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIGFsbG93T2Zmc2V0XG4gICAgICB9LFxuICAgICAgc2tpcEFic2VudDogdHJ1ZSxcbiAgICAgIHRlc3Q6IHZhbHVlID0+IHtcbiAgICAgICAgaWYgKCF2YWx1ZSB8fCBhbGxvd09mZnNldCkgcmV0dXJuIHRydWU7XG4gICAgICAgIGNvbnN0IHN0cnVjdCA9IHBhcnNlRGF0ZVN0cnVjdCh2YWx1ZSk7XG4gICAgICAgIGlmICghc3RydWN0KSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiAhIXN0cnVjdC56O1xuICAgICAgfVxuICAgIH0pLnRlc3Qoe1xuICAgICAgbmFtZTogJ2RhdGV0aW1lX3ByZWNpc2lvbicsXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlIHx8IHN0cmluZy5kYXRldGltZV9wcmVjaXNpb24sXG4gICAgICBwYXJhbXM6IHtcbiAgICAgICAgcHJlY2lzaW9uXG4gICAgICB9LFxuICAgICAgc2tpcEFic2VudDogdHJ1ZSxcbiAgICAgIHRlc3Q6IHZhbHVlID0+IHtcbiAgICAgICAgaWYgKCF2YWx1ZSB8fCBwcmVjaXNpb24gPT0gdW5kZWZpbmVkKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgY29uc3Qgc3RydWN0ID0gcGFyc2VEYXRlU3RydWN0KHZhbHVlKTtcbiAgICAgICAgaWYgKCFzdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHN0cnVjdC5wcmVjaXNpb24gPT09IHByZWNpc2lvbjtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8vLS0gdHJhbnNmb3JtcyAtLVxuICBlbnN1cmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVmYXVsdCgnJykudHJhbnNmb3JtKHZhbCA9PiB2YWwgPT09IG51bGwgPyAnJyA6IHZhbCk7XG4gIH1cbiAgdHJpbShtZXNzYWdlID0gc3RyaW5nLnRyaW0pIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0odmFsID0+IHZhbCAhPSBudWxsID8gdmFsLnRyaW0oKSA6IHZhbCkudGVzdCh7XG4gICAgICBtZXNzYWdlLFxuICAgICAgbmFtZTogJ3RyaW0nLFxuICAgICAgdGVzdDogaXNUcmltbWVkXG4gICAgfSk7XG4gIH1cbiAgbG93ZXJjYXNlKG1lc3NhZ2UgPSBzdHJpbmcubG93ZXJjYXNlKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKHZhbHVlID0+ICFpc0Fic2VudCh2YWx1ZSkgPyB2YWx1ZS50b0xvd2VyQ2FzZSgpIDogdmFsdWUpLnRlc3Qoe1xuICAgICAgbWVzc2FnZSxcbiAgICAgIG5hbWU6ICdzdHJpbmdfY2FzZScsXG4gICAgICBleGNsdXNpdmU6IHRydWUsXG4gICAgICBza2lwQWJzZW50OiB0cnVlLFxuICAgICAgdGVzdDogdmFsdWUgPT4gaXNBYnNlbnQodmFsdWUpIHx8IHZhbHVlID09PSB2YWx1ZS50b0xvd2VyQ2FzZSgpXG4gICAgfSk7XG4gIH1cbiAgdXBwZXJjYXNlKG1lc3NhZ2UgPSBzdHJpbmcudXBwZXJjYXNlKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKHZhbHVlID0+ICFpc0Fic2VudCh2YWx1ZSkgPyB2YWx1ZS50b1VwcGVyQ2FzZSgpIDogdmFsdWUpLnRlc3Qoe1xuICAgICAgbWVzc2FnZSxcbiAgICAgIG5hbWU6ICdzdHJpbmdfY2FzZScsXG4gICAgICBleGNsdXNpdmU6IHRydWUsXG4gICAgICBza2lwQWJzZW50OiB0cnVlLFxuICAgICAgdGVzdDogdmFsdWUgPT4gaXNBYnNlbnQodmFsdWUpIHx8IHZhbHVlID09PSB2YWx1ZS50b1VwcGVyQ2FzZSgpXG4gICAgfSk7XG4gIH1cbn1cbmNyZWF0ZSQ2LnByb3RvdHlwZSA9IFN0cmluZ1NjaGVtYS5wcm90b3R5cGU7XG5cbi8vXG4vLyBTdHJpbmcgSW50ZXJmYWNlc1xuLy9cblxubGV0IGlzTmFOJDEgPSB2YWx1ZSA9PiB2YWx1ZSAhPSArdmFsdWU7XG5mdW5jdGlvbiBjcmVhdGUkNSgpIHtcbiAgcmV0dXJuIG5ldyBOdW1iZXJTY2hlbWEoKTtcbn1cbmNsYXNzIE51bWJlclNjaGVtYSBleHRlbmRzIFNjaGVtYSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKHtcbiAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgY2hlY2sodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTnVtYmVyKSB2YWx1ZSA9IHZhbHVlLnZhbHVlT2YoKTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgIWlzTmFOJDEodmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMud2l0aE11dGF0aW9uKCgpID0+IHtcbiAgICAgIHRoaXMudHJhbnNmb3JtKCh2YWx1ZSwgX3JhdywgY3R4KSA9PiB7XG4gICAgICAgIGlmICghY3R4LnNwZWMuY29lcmNlKSByZXR1cm4gdmFsdWU7XG4gICAgICAgIGxldCBwYXJzZWQgPSB2YWx1ZTtcbiAgICAgICAgaWYgKHR5cGVvZiBwYXJzZWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcGFyc2VkID0gcGFyc2VkLnJlcGxhY2UoL1xccy9nLCAnJyk7XG4gICAgICAgICAgaWYgKHBhcnNlZCA9PT0gJycpIHJldHVybiBOYU47XG4gICAgICAgICAgLy8gZG9uJ3QgdXNlIHBhcnNlRmxvYXQgdG8gYXZvaWQgcG9zaXRpdmVzIG9uIGFscGhhLW51bWVyaWMgc3RyaW5nc1xuICAgICAgICAgIHBhcnNlZCA9ICtwYXJzZWQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBudWxsIC0+IE5hTiBpc24ndCB1c2VmdWw7IHRyZWF0IGFsbCBudWxscyBhcyBudWxsIGFuZCBsZXQgaXQgZmFpbCBvblxuICAgICAgICAvLyBudWxsYWJpbGl0eSBjaGVjayB2cyBUeXBlRXJyb3JzXG4gICAgICAgIGlmIChjdHguaXNUeXBlKHBhcnNlZCkgfHwgcGFyc2VkID09PSBudWxsKSByZXR1cm4gcGFyc2VkO1xuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChwYXJzZWQpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgbWluKG1pbiwgbWVzc2FnZSA9IG51bWJlci5taW4pIHtcbiAgICByZXR1cm4gdGhpcy50ZXN0KHtcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBuYW1lOiAnbWluJyxcbiAgICAgIGV4Y2x1c2l2ZTogdHJ1ZSxcbiAgICAgIHBhcmFtczoge1xuICAgICAgICBtaW5cbiAgICAgIH0sXG4gICAgICBza2lwQWJzZW50OiB0cnVlLFxuICAgICAgdGVzdCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPj0gdGhpcy5yZXNvbHZlKG1pbik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgbWF4KG1heCwgbWVzc2FnZSA9IG51bWJlci5tYXgpIHtcbiAgICByZXR1cm4gdGhpcy50ZXN0KHtcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBuYW1lOiAnbWF4JyxcbiAgICAgIGV4Y2x1c2l2ZTogdHJ1ZSxcbiAgICAgIHBhcmFtczoge1xuICAgICAgICBtYXhcbiAgICAgIH0sXG4gICAgICBza2lwQWJzZW50OiB0cnVlLFxuICAgICAgdGVzdCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPD0gdGhpcy5yZXNvbHZlKG1heCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgbGVzc1RoYW4obGVzcywgbWVzc2FnZSA9IG51bWJlci5sZXNzVGhhbikge1xuICAgIHJldHVybiB0aGlzLnRlc3Qoe1xuICAgICAgbWVzc2FnZSxcbiAgICAgIG5hbWU6ICdtYXgnLFxuICAgICAgZXhjbHVzaXZlOiB0cnVlLFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIGxlc3NcbiAgICAgIH0sXG4gICAgICBza2lwQWJzZW50OiB0cnVlLFxuICAgICAgdGVzdCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPCB0aGlzLnJlc29sdmUobGVzcyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgbW9yZVRoYW4obW9yZSwgbWVzc2FnZSA9IG51bWJlci5tb3JlVGhhbikge1xuICAgIHJldHVybiB0aGlzLnRlc3Qoe1xuICAgICAgbWVzc2FnZSxcbiAgICAgIG5hbWU6ICdtaW4nLFxuICAgICAgZXhjbHVzaXZlOiB0cnVlLFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIG1vcmVcbiAgICAgIH0sXG4gICAgICBza2lwQWJzZW50OiB0cnVlLFxuICAgICAgdGVzdCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPiB0aGlzLnJlc29sdmUobW9yZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcG9zaXRpdmUobXNnID0gbnVtYmVyLnBvc2l0aXZlKSB7XG4gICAgcmV0dXJuIHRoaXMubW9yZVRoYW4oMCwgbXNnKTtcbiAgfVxuICBuZWdhdGl2ZShtc2cgPSBudW1iZXIubmVnYXRpdmUpIHtcbiAgICByZXR1cm4gdGhpcy5sZXNzVGhhbigwLCBtc2cpO1xuICB9XG4gIGludGVnZXIobWVzc2FnZSA9IG51bWJlci5pbnRlZ2VyKSB7XG4gICAgcmV0dXJuIHRoaXMudGVzdCh7XG4gICAgICBuYW1lOiAnaW50ZWdlcicsXG4gICAgICBtZXNzYWdlLFxuICAgICAgc2tpcEFic2VudDogdHJ1ZSxcbiAgICAgIHRlc3Q6IHZhbCA9PiBOdW1iZXIuaXNJbnRlZ2VyKHZhbClcbiAgICB9KTtcbiAgfVxuICB0cnVuY2F0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0odmFsdWUgPT4gIWlzQWJzZW50KHZhbHVlKSA/IHZhbHVlIHwgMCA6IHZhbHVlKTtcbiAgfVxuICByb3VuZChtZXRob2QpIHtcbiAgICB2YXIgX21ldGhvZDtcbiAgICBsZXQgYXZhaWwgPSBbJ2NlaWwnLCAnZmxvb3InLCAncm91bmQnLCAndHJ1bmMnXTtcbiAgICBtZXRob2QgPSAoKF9tZXRob2QgPSBtZXRob2QpID09IG51bGwgPyB2b2lkIDAgOiBfbWV0aG9kLnRvTG93ZXJDYXNlKCkpIHx8ICdyb3VuZCc7XG5cbiAgICAvLyB0aGlzIGV4aXN0cyBmb3Igc3ltZW10cnkgd2l0aCB0aGUgbmV3IE1hdGgudHJ1bmNcbiAgICBpZiAobWV0aG9kID09PSAndHJ1bmMnKSByZXR1cm4gdGhpcy50cnVuY2F0ZSgpO1xuICAgIGlmIChhdmFpbC5pbmRleE9mKG1ldGhvZC50b0xvd2VyQ2FzZSgpKSA9PT0gLTEpIHRocm93IG5ldyBUeXBlRXJyb3IoJ09ubHkgdmFsaWQgb3B0aW9ucyBmb3Igcm91bmQoKSBhcmU6ICcgKyBhdmFpbC5qb2luKCcsICcpKTtcbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0odmFsdWUgPT4gIWlzQWJzZW50KHZhbHVlKSA/IE1hdGhbbWV0aG9kXSh2YWx1ZSkgOiB2YWx1ZSk7XG4gIH1cbn1cbmNyZWF0ZSQ1LnByb3RvdHlwZSA9IE51bWJlclNjaGVtYS5wcm90b3R5cGU7XG5cbi8vXG4vLyBOdW1iZXIgSW50ZXJmYWNlc1xuLy9cblxubGV0IGludmFsaWREYXRlID0gbmV3IERhdGUoJycpO1xubGV0IGlzRGF0ZSA9IG9iaiA9PiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xuZnVuY3Rpb24gY3JlYXRlJDQoKSB7XG4gIHJldHVybiBuZXcgRGF0ZVNjaGVtYSgpO1xufVxuY2xhc3MgRGF0ZVNjaGVtYSBleHRlbmRzIFNjaGVtYSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKHtcbiAgICAgIHR5cGU6ICdkYXRlJyxcbiAgICAgIGNoZWNrKHYpIHtcbiAgICAgICAgcmV0dXJuIGlzRGF0ZSh2KSAmJiAhaXNOYU4odi5nZXRUaW1lKCkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMud2l0aE11dGF0aW9uKCgpID0+IHtcbiAgICAgIHRoaXMudHJhbnNmb3JtKCh2YWx1ZSwgX3JhdywgY3R4KSA9PiB7XG4gICAgICAgIC8vIG51bGwgLT4gSW52YWxpZERhdGUgaXNuJ3QgdXNlZnVsOyB0cmVhdCBhbGwgbnVsbHMgYXMgbnVsbCBhbmQgbGV0IGl0IGZhaWwgb25cbiAgICAgICAgLy8gbnVsbGFiaWxpdHkgY2hlY2sgdnMgVHlwZUVycm9yc1xuICAgICAgICBpZiAoIWN0eC5zcGVjLmNvZXJjZSB8fCBjdHguaXNUeXBlKHZhbHVlKSB8fCB2YWx1ZSA9PT0gbnVsbCkgcmV0dXJuIHZhbHVlO1xuICAgICAgICB2YWx1ZSA9IHBhcnNlSXNvRGF0ZSh2YWx1ZSk7XG5cbiAgICAgICAgLy8gMCBpcyBhIHZhbGlkIHRpbWVzdGFtcCBlcXVpdmFsZW50IHRvIDE5NzAtMDEtMDFUMDA6MDA6MDBaKHVuaXggZXBvY2gpIG9yIGJlZm9yZS5cbiAgICAgICAgcmV0dXJuICFpc05hTih2YWx1ZSkgPyBuZXcgRGF0ZSh2YWx1ZSkgOiBEYXRlU2NoZW1hLklOVkFMSURfREFURTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIHByZXBhcmVQYXJhbShyZWYsIG5hbWUpIHtcbiAgICBsZXQgcGFyYW07XG4gICAgaWYgKCFSZWZlcmVuY2UuaXNSZWYocmVmKSkge1xuICAgICAgbGV0IGNhc3QgPSB0aGlzLmNhc3QocmVmKTtcbiAgICAgIGlmICghdGhpcy5fdHlwZUNoZWNrKGNhc3QpKSB0aHJvdyBuZXcgVHlwZUVycm9yKGBcXGAke25hbWV9XFxgIG11c3QgYmUgYSBEYXRlIG9yIGEgdmFsdWUgdGhhdCBjYW4gYmUgXFxgY2FzdCgpXFxgIHRvIGEgRGF0ZWApO1xuICAgICAgcGFyYW0gPSBjYXN0O1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJhbSA9IHJlZjtcbiAgICB9XG4gICAgcmV0dXJuIHBhcmFtO1xuICB9XG4gIG1pbihtaW4sIG1lc3NhZ2UgPSBkYXRlLm1pbikge1xuICAgIGxldCBsaW1pdCA9IHRoaXMucHJlcGFyZVBhcmFtKG1pbiwgJ21pbicpO1xuICAgIHJldHVybiB0aGlzLnRlc3Qoe1xuICAgICAgbWVzc2FnZSxcbiAgICAgIG5hbWU6ICdtaW4nLFxuICAgICAgZXhjbHVzaXZlOiB0cnVlLFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIG1pblxuICAgICAgfSxcbiAgICAgIHNraXBBYnNlbnQ6IHRydWUsXG4gICAgICB0ZXN0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA+PSB0aGlzLnJlc29sdmUobGltaXQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIG1heChtYXgsIG1lc3NhZ2UgPSBkYXRlLm1heCkge1xuICAgIGxldCBsaW1pdCA9IHRoaXMucHJlcGFyZVBhcmFtKG1heCwgJ21heCcpO1xuICAgIHJldHVybiB0aGlzLnRlc3Qoe1xuICAgICAgbWVzc2FnZSxcbiAgICAgIG5hbWU6ICdtYXgnLFxuICAgICAgZXhjbHVzaXZlOiB0cnVlLFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIG1heFxuICAgICAgfSxcbiAgICAgIHNraXBBYnNlbnQ6IHRydWUsXG4gICAgICB0ZXN0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA8PSB0aGlzLnJlc29sdmUobGltaXQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5EYXRlU2NoZW1hLklOVkFMSURfREFURSA9IGludmFsaWREYXRlO1xuY3JlYXRlJDQucHJvdG90eXBlID0gRGF0ZVNjaGVtYS5wcm90b3R5cGU7XG5jcmVhdGUkNC5JTlZBTElEX0RBVEUgPSBpbnZhbGlkRGF0ZTtcblxuLy8gQHRzLWV4cGVjdC1lcnJvclxuZnVuY3Rpb24gc29ydEZpZWxkcyhmaWVsZHMsIGV4Y2x1ZGVkRWRnZXMgPSBbXSkge1xuICBsZXQgZWRnZXMgPSBbXTtcbiAgbGV0IG5vZGVzID0gbmV3IFNldCgpO1xuICBsZXQgZXhjbHVkZXMgPSBuZXcgU2V0KGV4Y2x1ZGVkRWRnZXMubWFwKChbYSwgYl0pID0+IGAke2F9LSR7Yn1gKSk7XG4gIGZ1bmN0aW9uIGFkZE5vZGUoZGVwUGF0aCwga2V5KSB7XG4gICAgbGV0IG5vZGUgPSBzcGxpdChkZXBQYXRoKVswXTtcbiAgICBub2Rlcy5hZGQobm9kZSk7XG4gICAgaWYgKCFleGNsdWRlcy5oYXMoYCR7a2V5fS0ke25vZGV9YCkpIGVkZ2VzLnB1c2goW2tleSwgbm9kZV0pO1xuICB9XG4gIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGZpZWxkcykpIHtcbiAgICBsZXQgdmFsdWUgPSBmaWVsZHNba2V5XTtcbiAgICBub2Rlcy5hZGQoa2V5KTtcbiAgICBpZiAoUmVmZXJlbmNlLmlzUmVmKHZhbHVlKSAmJiB2YWx1ZS5pc1NpYmxpbmcpIGFkZE5vZGUodmFsdWUucGF0aCwga2V5KTtlbHNlIGlmIChpc1NjaGVtYSh2YWx1ZSkgJiYgJ2RlcHMnIGluIHZhbHVlKSB2YWx1ZS5kZXBzLmZvckVhY2gocGF0aCA9PiBhZGROb2RlKHBhdGgsIGtleSkpO1xuICB9XG4gIHJldHVybiB0b3Bvc29ydC5hcnJheShBcnJheS5mcm9tKG5vZGVzKSwgZWRnZXMpLnJldmVyc2UoKTtcbn1cblxuZnVuY3Rpb24gZmluZEluZGV4KGFyciwgZXJyKSB7XG4gIGxldCBpZHggPSBJbmZpbml0eTtcbiAgYXJyLnNvbWUoKGtleSwgaWkpID0+IHtcbiAgICB2YXIgX2VyciRwYXRoO1xuICAgIGlmICgoX2VyciRwYXRoID0gZXJyLnBhdGgpICE9IG51bGwgJiYgX2VyciRwYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgIGlkeCA9IGlpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGlkeDtcbn1cbmZ1bmN0aW9uIHNvcnRCeUtleU9yZGVyKGtleXMpIHtcbiAgcmV0dXJuIChhLCBiKSA9PiB7XG4gICAgcmV0dXJuIGZpbmRJbmRleChrZXlzLCBhKSAtIGZpbmRJbmRleChrZXlzLCBiKTtcbiAgfTtcbn1cblxuY29uc3QgcGFyc2VKc29uID0gKHZhbHVlLCBfLCBjdHgpID0+IHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgbGV0IHBhcnNlZCA9IHZhbHVlO1xuICB0cnkge1xuICAgIHBhcnNlZCA9IEpTT04ucGFyc2UodmFsdWUpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvKiAqL1xuICB9XG4gIHJldHVybiBjdHguaXNUeXBlKHBhcnNlZCkgPyBwYXJzZWQgOiB2YWx1ZTtcbn07XG5cbi8vIEB0cy1pZ25vcmVcbmZ1bmN0aW9uIGRlZXBQYXJ0aWFsKHNjaGVtYSkge1xuICBpZiAoJ2ZpZWxkcycgaW4gc2NoZW1hKSB7XG4gICAgY29uc3QgcGFydGlhbCA9IHt9O1xuICAgIGZvciAoY29uc3QgW2tleSwgZmllbGRTY2hlbWFdIG9mIE9iamVjdC5lbnRyaWVzKHNjaGVtYS5maWVsZHMpKSB7XG4gICAgICBwYXJ0aWFsW2tleV0gPSBkZWVwUGFydGlhbChmaWVsZFNjaGVtYSk7XG4gICAgfVxuICAgIHJldHVybiBzY2hlbWEuc2V0RmllbGRzKHBhcnRpYWwpO1xuICB9XG4gIGlmIChzY2hlbWEudHlwZSA9PT0gJ2FycmF5Jykge1xuICAgIGNvbnN0IG5leHRBcnJheSA9IHNjaGVtYS5vcHRpb25hbCgpO1xuICAgIGlmIChuZXh0QXJyYXkuaW5uZXJUeXBlKSBuZXh0QXJyYXkuaW5uZXJUeXBlID0gZGVlcFBhcnRpYWwobmV4dEFycmF5LmlubmVyVHlwZSk7XG4gICAgcmV0dXJuIG5leHRBcnJheTtcbiAgfVxuICBpZiAoc2NoZW1hLnR5cGUgPT09ICd0dXBsZScpIHtcbiAgICByZXR1cm4gc2NoZW1hLm9wdGlvbmFsKCkuY2xvbmUoe1xuICAgICAgdHlwZXM6IHNjaGVtYS5zcGVjLnR5cGVzLm1hcChkZWVwUGFydGlhbClcbiAgICB9KTtcbiAgfVxuICBpZiAoJ29wdGlvbmFsJyBpbiBzY2hlbWEpIHtcbiAgICByZXR1cm4gc2NoZW1hLm9wdGlvbmFsKCk7XG4gIH1cbiAgcmV0dXJuIHNjaGVtYTtcbn1cbmNvbnN0IGRlZXBIYXMgPSAob2JqLCBwKSA9PiB7XG4gIGNvbnN0IHBhdGggPSBbLi4ubm9ybWFsaXplUGF0aChwKV07XG4gIGlmIChwYXRoLmxlbmd0aCA9PT0gMSkgcmV0dXJuIHBhdGhbMF0gaW4gb2JqO1xuICBsZXQgbGFzdCA9IHBhdGgucG9wKCk7XG4gIGxldCBwYXJlbnQgPSBnZXR0ZXIoam9pbihwYXRoKSwgdHJ1ZSkob2JqKTtcbiAgcmV0dXJuICEhKHBhcmVudCAmJiBsYXN0IGluIHBhcmVudCk7XG59O1xubGV0IGlzT2JqZWN0ID0gb2JqID0+IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBPYmplY3RdJztcbmZ1bmN0aW9uIHVua25vd24oY3R4LCB2YWx1ZSkge1xuICBsZXQga25vd24gPSBPYmplY3Qua2V5cyhjdHguZmllbGRzKTtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHZhbHVlKS5maWx0ZXIoa2V5ID0+IGtub3duLmluZGV4T2Yoa2V5KSA9PT0gLTEpO1xufVxuY29uc3QgZGVmYXVsdFNvcnQgPSBzb3J0QnlLZXlPcmRlcihbXSk7XG5mdW5jdGlvbiBjcmVhdGUkMyhzcGVjKSB7XG4gIHJldHVybiBuZXcgT2JqZWN0U2NoZW1hKHNwZWMpO1xufVxuY2xhc3MgT2JqZWN0U2NoZW1hIGV4dGVuZHMgU2NoZW1hIHtcbiAgY29uc3RydWN0b3Ioc3BlYykge1xuICAgIHN1cGVyKHtcbiAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgY2hlY2sodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbic7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5maWVsZHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuX3NvcnRFcnJvcnMgPSBkZWZhdWx0U29ydDtcbiAgICB0aGlzLl9ub2RlcyA9IFtdO1xuICAgIHRoaXMuX2V4Y2x1ZGVkRWRnZXMgPSBbXTtcbiAgICB0aGlzLndpdGhNdXRhdGlvbigoKSA9PiB7XG4gICAgICBpZiAoc3BlYykge1xuICAgICAgICB0aGlzLnNoYXBlKHNwZWMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIF9jYXN0KF92YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgdmFyIF9vcHRpb25zJHN0cmlwVW5rbm93bjtcbiAgICBsZXQgdmFsdWUgPSBzdXBlci5fY2FzdChfdmFsdWUsIG9wdGlvbnMpO1xuXG4gICAgLy9zaG91bGQgaWdub3JlIG51bGxzIGhlcmVcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHRoaXMuZ2V0RGVmYXVsdChvcHRpb25zKTtcbiAgICBpZiAoIXRoaXMuX3R5cGVDaGVjayh2YWx1ZSkpIHJldHVybiB2YWx1ZTtcbiAgICBsZXQgZmllbGRzID0gdGhpcy5maWVsZHM7XG4gICAgbGV0IHN0cmlwID0gKF9vcHRpb25zJHN0cmlwVW5rbm93biA9IG9wdGlvbnMuc3RyaXBVbmtub3duKSAhPSBudWxsID8gX29wdGlvbnMkc3RyaXBVbmtub3duIDogdGhpcy5zcGVjLm5vVW5rbm93bjtcbiAgICBsZXQgcHJvcHMgPSBbXS5jb25jYXQodGhpcy5fbm9kZXMsIE9iamVjdC5rZXlzKHZhbHVlKS5maWx0ZXIodiA9PiAhdGhpcy5fbm9kZXMuaW5jbHVkZXModikpKTtcbiAgICBsZXQgaW50ZXJtZWRpYXRlVmFsdWUgPSB7fTsgLy8gaXMgZmlsbGVkIGR1cmluZyB0aGUgdHJhbnNmb3JtIGJlbG93XG4gICAgbGV0IGlubmVyT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHtcbiAgICAgIHBhcmVudDogaW50ZXJtZWRpYXRlVmFsdWUsXG4gICAgICBfX3ZhbGlkYXRpbmc6IG9wdGlvbnMuX192YWxpZGF0aW5nIHx8IGZhbHNlXG4gICAgfSk7XG4gICAgbGV0IGlzQ2hhbmdlZCA9IGZhbHNlO1xuICAgIGZvciAoY29uc3QgcHJvcCBvZiBwcm9wcykge1xuICAgICAgbGV0IGZpZWxkID0gZmllbGRzW3Byb3BdO1xuICAgICAgbGV0IGV4aXN0cyA9IChwcm9wIGluIHZhbHVlKTtcbiAgICAgIGlmIChmaWVsZCkge1xuICAgICAgICBsZXQgZmllbGRWYWx1ZTtcbiAgICAgICAgbGV0IGlucHV0VmFsdWUgPSB2YWx1ZVtwcm9wXTtcblxuICAgICAgICAvLyBzYWZlIHRvIG11dGF0ZSBzaW5jZSB0aGlzIGlzIGZpcmVkIGluIHNlcXVlbmNlXG4gICAgICAgIGlubmVyT3B0aW9ucy5wYXRoID0gKG9wdGlvbnMucGF0aCA/IGAke29wdGlvbnMucGF0aH0uYCA6ICcnKSArIHByb3A7XG4gICAgICAgIGZpZWxkID0gZmllbGQucmVzb2x2ZSh7XG4gICAgICAgICAgdmFsdWU6IGlucHV0VmFsdWUsXG4gICAgICAgICAgY29udGV4dDogb3B0aW9ucy5jb250ZXh0LFxuICAgICAgICAgIHBhcmVudDogaW50ZXJtZWRpYXRlVmFsdWVcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBmaWVsZFNwZWMgPSBmaWVsZCBpbnN0YW5jZW9mIFNjaGVtYSA/IGZpZWxkLnNwZWMgOiB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBzdHJpY3QgPSBmaWVsZFNwZWMgPT0gbnVsbCA/IHZvaWQgMCA6IGZpZWxkU3BlYy5zdHJpY3Q7XG4gICAgICAgIGlmIChmaWVsZFNwZWMgIT0gbnVsbCAmJiBmaWVsZFNwZWMuc3RyaXApIHtcbiAgICAgICAgICBpc0NoYW5nZWQgPSBpc0NoYW5nZWQgfHwgcHJvcCBpbiB2YWx1ZTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBmaWVsZFZhbHVlID0gIW9wdGlvbnMuX192YWxpZGF0aW5nIHx8ICFzdHJpY3QgP1xuICAgICAgICAvLyBUT0RPOiB1c2UgX2Nhc3QsIHRoaXMgaXMgZG91YmxlIHJlc29sdmluZ1xuICAgICAgICBmaWVsZC5jYXN0KHZhbHVlW3Byb3BdLCBpbm5lck9wdGlvbnMpIDogdmFsdWVbcHJvcF07XG4gICAgICAgIGlmIChmaWVsZFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpbnRlcm1lZGlhdGVWYWx1ZVtwcm9wXSA9IGZpZWxkVmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZXhpc3RzICYmICFzdHJpcCkge1xuICAgICAgICBpbnRlcm1lZGlhdGVWYWx1ZVtwcm9wXSA9IHZhbHVlW3Byb3BdO1xuICAgICAgfVxuICAgICAgaWYgKGV4aXN0cyAhPT0gcHJvcCBpbiBpbnRlcm1lZGlhdGVWYWx1ZSB8fCBpbnRlcm1lZGlhdGVWYWx1ZVtwcm9wXSAhPT0gdmFsdWVbcHJvcF0pIHtcbiAgICAgICAgaXNDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGlzQ2hhbmdlZCA/IGludGVybWVkaWF0ZVZhbHVlIDogdmFsdWU7XG4gIH1cbiAgX3ZhbGlkYXRlKF92YWx1ZSwgb3B0aW9ucyA9IHt9LCBwYW5pYywgbmV4dCkge1xuICAgIGxldCB7XG4gICAgICBmcm9tID0gW10sXG4gICAgICBvcmlnaW5hbFZhbHVlID0gX3ZhbHVlLFxuICAgICAgcmVjdXJzaXZlID0gdGhpcy5zcGVjLnJlY3Vyc2l2ZVxuICAgIH0gPSBvcHRpb25zO1xuICAgIG9wdGlvbnMuZnJvbSA9IFt7XG4gICAgICBzY2hlbWE6IHRoaXMsXG4gICAgICB2YWx1ZTogb3JpZ2luYWxWYWx1ZVxuICAgIH0sIC4uLmZyb21dO1xuICAgIC8vIHRoaXMgZmxhZyBpcyBuZWVkZWQgZm9yIGhhbmRsaW5nIGBzdHJpY3RgIGNvcnJlY3RseSBpbiB0aGUgY29udGV4dCBvZlxuICAgIC8vIHZhbGlkYXRpb24gdnMganVzdCBjYXN0aW5nLiBlLmcgc3RyaWN0KCkgb24gYSBmaWVsZCBpcyBvbmx5IHVzZWQgd2hlbiB2YWxpZGF0aW5nXG4gICAgb3B0aW9ucy5fX3ZhbGlkYXRpbmcgPSB0cnVlO1xuICAgIG9wdGlvbnMub3JpZ2luYWxWYWx1ZSA9IG9yaWdpbmFsVmFsdWU7XG4gICAgc3VwZXIuX3ZhbGlkYXRlKF92YWx1ZSwgb3B0aW9ucywgcGFuaWMsIChvYmplY3RFcnJvcnMsIHZhbHVlKSA9PiB7XG4gICAgICBpZiAoIXJlY3Vyc2l2ZSB8fCAhaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgIG5leHQob2JqZWN0RXJyb3JzLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG9yaWdpbmFsVmFsdWUgPSBvcmlnaW5hbFZhbHVlIHx8IHZhbHVlO1xuICAgICAgbGV0IHRlc3RzID0gW107XG4gICAgICBmb3IgKGxldCBrZXkgb2YgdGhpcy5fbm9kZXMpIHtcbiAgICAgICAgbGV0IGZpZWxkID0gdGhpcy5maWVsZHNba2V5XTtcbiAgICAgICAgaWYgKCFmaWVsZCB8fCBSZWZlcmVuY2UuaXNSZWYoZmllbGQpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdGVzdHMucHVzaChmaWVsZC5hc05lc3RlZFRlc3Qoe1xuICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAga2V5LFxuICAgICAgICAgIHBhcmVudDogdmFsdWUsXG4gICAgICAgICAgcGFyZW50UGF0aDogb3B0aW9ucy5wYXRoLFxuICAgICAgICAgIG9yaWdpbmFsUGFyZW50OiBvcmlnaW5hbFZhbHVlXG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucnVuVGVzdHMoe1xuICAgICAgICB0ZXN0cyxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIG9yaWdpbmFsVmFsdWUsXG4gICAgICAgIG9wdGlvbnNcbiAgICAgIH0sIHBhbmljLCBmaWVsZEVycm9ycyA9PiB7XG4gICAgICAgIG5leHQoZmllbGRFcnJvcnMuc29ydCh0aGlzLl9zb3J0RXJyb3JzKS5jb25jYXQob2JqZWN0RXJyb3JzKSwgdmFsdWUpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgY2xvbmUoc3BlYykge1xuICAgIGNvbnN0IG5leHQgPSBzdXBlci5jbG9uZShzcGVjKTtcbiAgICBuZXh0LmZpZWxkcyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuZmllbGRzKTtcbiAgICBuZXh0Ll9ub2RlcyA9IHRoaXMuX25vZGVzO1xuICAgIG5leHQuX2V4Y2x1ZGVkRWRnZXMgPSB0aGlzLl9leGNsdWRlZEVkZ2VzO1xuICAgIG5leHQuX3NvcnRFcnJvcnMgPSB0aGlzLl9zb3J0RXJyb3JzO1xuICAgIHJldHVybiBuZXh0O1xuICB9XG4gIGNvbmNhdChzY2hlbWEpIHtcbiAgICBsZXQgbmV4dCA9IHN1cGVyLmNvbmNhdChzY2hlbWEpO1xuICAgIGxldCBuZXh0RmllbGRzID0gbmV4dC5maWVsZHM7XG4gICAgZm9yIChsZXQgW2ZpZWxkLCBzY2hlbWFPclJlZl0gb2YgT2JqZWN0LmVudHJpZXModGhpcy5maWVsZHMpKSB7XG4gICAgICBjb25zdCB0YXJnZXQgPSBuZXh0RmllbGRzW2ZpZWxkXTtcbiAgICAgIG5leHRGaWVsZHNbZmllbGRdID0gdGFyZ2V0ID09PSB1bmRlZmluZWQgPyBzY2hlbWFPclJlZiA6IHRhcmdldDtcbiAgICB9XG4gICAgcmV0dXJuIG5leHQud2l0aE11dGF0aW9uKHMgPT5cbiAgICAvLyBYWFg6IGV4Y2x1ZGVzIGhlcmUgaXMgd3JvbmdcbiAgICBzLnNldEZpZWxkcyhuZXh0RmllbGRzLCBbLi4udGhpcy5fZXhjbHVkZWRFZGdlcywgLi4uc2NoZW1hLl9leGNsdWRlZEVkZ2VzXSkpO1xuICB9XG4gIF9nZXREZWZhdWx0KG9wdGlvbnMpIHtcbiAgICBpZiAoJ2RlZmF1bHQnIGluIHRoaXMuc3BlYykge1xuICAgICAgcmV0dXJuIHN1cGVyLl9nZXREZWZhdWx0KG9wdGlvbnMpO1xuICAgIH1cblxuICAgIC8vIGlmIHRoZXJlIGlzIG5vIGRlZmF1bHQgc2V0IGludmVudCBvbmVcbiAgICBpZiAoIXRoaXMuX25vZGVzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgbGV0IGRmdCA9IHt9O1xuICAgIHRoaXMuX25vZGVzLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIHZhciBfaW5uZXJPcHRpb25zO1xuICAgICAgY29uc3QgZmllbGQgPSB0aGlzLmZpZWxkc1trZXldO1xuICAgICAgbGV0IGlubmVyT3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICBpZiAoKF9pbm5lck9wdGlvbnMgPSBpbm5lck9wdGlvbnMpICE9IG51bGwgJiYgX2lubmVyT3B0aW9ucy52YWx1ZSkge1xuICAgICAgICBpbm5lck9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBpbm5lck9wdGlvbnMsIHtcbiAgICAgICAgICBwYXJlbnQ6IGlubmVyT3B0aW9ucy52YWx1ZSxcbiAgICAgICAgICB2YWx1ZTogaW5uZXJPcHRpb25zLnZhbHVlW2tleV1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBkZnRba2V5XSA9IGZpZWxkICYmICdnZXREZWZhdWx0JyBpbiBmaWVsZCA/IGZpZWxkLmdldERlZmF1bHQoaW5uZXJPcHRpb25zKSA6IHVuZGVmaW5lZDtcbiAgICB9KTtcbiAgICByZXR1cm4gZGZ0O1xuICB9XG4gIHNldEZpZWxkcyhzaGFwZSwgZXhjbHVkZWRFZGdlcykge1xuICAgIGxldCBuZXh0ID0gdGhpcy5jbG9uZSgpO1xuICAgIG5leHQuZmllbGRzID0gc2hhcGU7XG4gICAgbmV4dC5fbm9kZXMgPSBzb3J0RmllbGRzKHNoYXBlLCBleGNsdWRlZEVkZ2VzKTtcbiAgICBuZXh0Ll9zb3J0RXJyb3JzID0gc29ydEJ5S2V5T3JkZXIoT2JqZWN0LmtleXMoc2hhcGUpKTtcbiAgICAvLyBYWFg6IHRoaXMgY2FycmllcyBvdmVyIGVkZ2VzIHdoaWNoIG1heSBub3QgYmUgd2hhdCB5b3Ugd2FudFxuICAgIGlmIChleGNsdWRlZEVkZ2VzKSBuZXh0Ll9leGNsdWRlZEVkZ2VzID0gZXhjbHVkZWRFZGdlcztcbiAgICByZXR1cm4gbmV4dDtcbiAgfVxuICBzaGFwZShhZGRpdGlvbnMsIGV4Y2x1ZGVzID0gW10pIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLndpdGhNdXRhdGlvbihuZXh0ID0+IHtcbiAgICAgIGxldCBlZGdlcyA9IG5leHQuX2V4Y2x1ZGVkRWRnZXM7XG4gICAgICBpZiAoZXhjbHVkZXMubGVuZ3RoKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShleGNsdWRlc1swXSkpIGV4Y2x1ZGVzID0gW2V4Y2x1ZGVzXTtcbiAgICAgICAgZWRnZXMgPSBbLi4ubmV4dC5fZXhjbHVkZWRFZGdlcywgLi4uZXhjbHVkZXNdO1xuICAgICAgfVxuXG4gICAgICAvLyBYWFg6IGV4Y2x1ZGVzIGhlcmUgaXMgd3JvbmdcbiAgICAgIHJldHVybiBuZXh0LnNldEZpZWxkcyhPYmplY3QuYXNzaWduKG5leHQuZmllbGRzLCBhZGRpdGlvbnMpLCBlZGdlcyk7XG4gICAgfSk7XG4gIH1cbiAgcGFydGlhbCgpIHtcbiAgICBjb25zdCBwYXJ0aWFsID0ge307XG4gICAgZm9yIChjb25zdCBba2V5LCBzY2hlbWFdIG9mIE9iamVjdC5lbnRyaWVzKHRoaXMuZmllbGRzKSkge1xuICAgICAgcGFydGlhbFtrZXldID0gJ29wdGlvbmFsJyBpbiBzY2hlbWEgJiYgc2NoZW1hLm9wdGlvbmFsIGluc3RhbmNlb2YgRnVuY3Rpb24gPyBzY2hlbWEub3B0aW9uYWwoKSA6IHNjaGVtYTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc2V0RmllbGRzKHBhcnRpYWwpO1xuICB9XG4gIGRlZXBQYXJ0aWFsKCkge1xuICAgIGNvbnN0IG5leHQgPSBkZWVwUGFydGlhbCh0aGlzKTtcbiAgICByZXR1cm4gbmV4dDtcbiAgfVxuICBwaWNrKGtleXMpIHtcbiAgICBjb25zdCBwaWNrZWQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICBpZiAodGhpcy5maWVsZHNba2V5XSkgcGlja2VkW2tleV0gPSB0aGlzLmZpZWxkc1trZXldO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zZXRGaWVsZHMocGlja2VkLCB0aGlzLl9leGNsdWRlZEVkZ2VzLmZpbHRlcigoW2EsIGJdKSA9PiBrZXlzLmluY2x1ZGVzKGEpICYmIGtleXMuaW5jbHVkZXMoYikpKTtcbiAgfVxuICBvbWl0KGtleXMpIHtcbiAgICBjb25zdCByZW1haW5pbmcgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyh0aGlzLmZpZWxkcykpIHtcbiAgICAgIGlmIChrZXlzLmluY2x1ZGVzKGtleSkpIGNvbnRpbnVlO1xuICAgICAgcmVtYWluaW5nLnB1c2goa2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucGljayhyZW1haW5pbmcpO1xuICB9XG4gIGZyb20oZnJvbSwgdG8sIGFsaWFzKSB7XG4gICAgbGV0IGZyb21HZXR0ZXIgPSBnZXR0ZXIoZnJvbSwgdHJ1ZSk7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKG9iaiA9PiB7XG4gICAgICBpZiAoIW9iaikgcmV0dXJuIG9iajtcbiAgICAgIGxldCBuZXdPYmogPSBvYmo7XG4gICAgICBpZiAoZGVlcEhhcyhvYmosIGZyb20pKSB7XG4gICAgICAgIG5ld09iaiA9IE9iamVjdC5hc3NpZ24oe30sIG9iaik7XG4gICAgICAgIGlmICghYWxpYXMpIGRlbGV0ZSBuZXdPYmpbZnJvbV07XG4gICAgICAgIG5ld09ialt0b10gPSBmcm9tR2V0dGVyKG9iaik7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3T2JqO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqIFBhcnNlIGFuIGlucHV0IEpTT04gc3RyaW5nIHRvIGFuIG9iamVjdCAqL1xuICBqc29uKCkge1xuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybShwYXJzZUpzb24pO1xuICB9XG4gIG5vVW5rbm93bihub0FsbG93ID0gdHJ1ZSwgbWVzc2FnZSA9IG9iamVjdC5ub1Vua25vd24pIHtcbiAgICBpZiAodHlwZW9mIG5vQWxsb3cgIT09ICdib29sZWFuJykge1xuICAgICAgbWVzc2FnZSA9IG5vQWxsb3c7XG4gICAgICBub0FsbG93ID0gdHJ1ZTtcbiAgICB9XG4gICAgbGV0IG5leHQgPSB0aGlzLnRlc3Qoe1xuICAgICAgbmFtZTogJ25vVW5rbm93bicsXG4gICAgICBleGNsdXNpdmU6IHRydWUsXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlLFxuICAgICAgdGVzdCh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkgcmV0dXJuIHRydWU7XG4gICAgICAgIGNvbnN0IHVua25vd25LZXlzID0gdW5rbm93bih0aGlzLnNjaGVtYSwgdmFsdWUpO1xuICAgICAgICByZXR1cm4gIW5vQWxsb3cgfHwgdW5rbm93bktleXMubGVuZ3RoID09PSAwIHx8IHRoaXMuY3JlYXRlRXJyb3Ioe1xuICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgdW5rbm93bjogdW5rbm93bktleXMuam9pbignLCAnKVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgbmV4dC5zcGVjLm5vVW5rbm93biA9IG5vQWxsb3c7XG4gICAgcmV0dXJuIG5leHQ7XG4gIH1cbiAgdW5rbm93bihhbGxvdyA9IHRydWUsIG1lc3NhZ2UgPSBvYmplY3Qubm9Vbmtub3duKSB7XG4gICAgcmV0dXJuIHRoaXMubm9Vbmtub3duKCFhbGxvdywgbWVzc2FnZSk7XG4gIH1cbiAgdHJhbnNmb3JtS2V5cyhmbikge1xuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybShvYmogPT4ge1xuICAgICAgaWYgKCFvYmopIHJldHVybiBvYmo7XG4gICAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKG9iaikpIHJlc3VsdFtmbihrZXkpXSA9IG9ialtrZXldO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTtcbiAgfVxuICBjYW1lbENhc2UoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtS2V5cyhjYW1lbENhc2UpO1xuICB9XG4gIHNuYWtlQ2FzZSgpIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1LZXlzKHNuYWtlQ2FzZSk7XG4gIH1cbiAgY29uc3RhbnRDYXNlKCkge1xuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybUtleXMoa2V5ID0+IHNuYWtlQ2FzZShrZXkpLnRvVXBwZXJDYXNlKCkpO1xuICB9XG4gIGRlc2NyaWJlKG9wdGlvbnMpIHtcbiAgICBjb25zdCBuZXh0ID0gKG9wdGlvbnMgPyB0aGlzLnJlc29sdmUob3B0aW9ucykgOiB0aGlzKS5jbG9uZSgpO1xuICAgIGNvbnN0IGJhc2UgPSBzdXBlci5kZXNjcmliZShvcHRpb25zKTtcbiAgICBiYXNlLmZpZWxkcyA9IHt9O1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKG5leHQuZmllbGRzKSkge1xuICAgICAgdmFyIF9pbm5lck9wdGlvbnMyO1xuICAgICAgbGV0IGlubmVyT3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICBpZiAoKF9pbm5lck9wdGlvbnMyID0gaW5uZXJPcHRpb25zKSAhPSBudWxsICYmIF9pbm5lck9wdGlvbnMyLnZhbHVlKSB7XG4gICAgICAgIGlubmVyT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGlubmVyT3B0aW9ucywge1xuICAgICAgICAgIHBhcmVudDogaW5uZXJPcHRpb25zLnZhbHVlLFxuICAgICAgICAgIHZhbHVlOiBpbm5lck9wdGlvbnMudmFsdWVba2V5XVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGJhc2UuZmllbGRzW2tleV0gPSB2YWx1ZS5kZXNjcmliZShpbm5lck9wdGlvbnMpO1xuICAgIH1cbiAgICByZXR1cm4gYmFzZTtcbiAgfVxufVxuY3JlYXRlJDMucHJvdG90eXBlID0gT2JqZWN0U2NoZW1hLnByb3RvdHlwZTtcblxuZnVuY3Rpb24gY3JlYXRlJDIodHlwZSkge1xuICByZXR1cm4gbmV3IEFycmF5U2NoZW1hKHR5cGUpO1xufVxuY2xhc3MgQXJyYXlTY2hlbWEgZXh0ZW5kcyBTY2hlbWEge1xuICBjb25zdHJ1Y3Rvcih0eXBlKSB7XG4gICAgc3VwZXIoe1xuICAgICAgdHlwZTogJ2FycmF5JyxcbiAgICAgIHNwZWM6IHtcbiAgICAgICAgdHlwZXM6IHR5cGVcbiAgICAgIH0sXG4gICAgICBjaGVjayh2KSB7XG4gICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHYpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gYHVuZGVmaW5lZGAgc3BlY2lmaWNhbGx5IG1lYW5zIHVuaW5pdGlhbGl6ZWQsIGFzIG9wcG9zZWQgdG8gXCJubyBzdWJ0eXBlXCJcbiAgICB0aGlzLmlubmVyVHlwZSA9IHZvaWQgMDtcbiAgICB0aGlzLmlubmVyVHlwZSA9IHR5cGU7XG4gIH1cbiAgX2Nhc3QoX3ZhbHVlLCBfb3B0cykge1xuICAgIGNvbnN0IHZhbHVlID0gc3VwZXIuX2Nhc3QoX3ZhbHVlLCBfb3B0cyk7XG5cbiAgICAvLyBzaG91bGQgaWdub3JlIG51bGxzIGhlcmVcbiAgICBpZiAoIXRoaXMuX3R5cGVDaGVjayh2YWx1ZSkgfHwgIXRoaXMuaW5uZXJUeXBlKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGxldCBpc0NoYW5nZWQgPSBmYWxzZTtcbiAgICBjb25zdCBjYXN0QXJyYXkgPSB2YWx1ZS5tYXAoKHYsIGlkeCkgPT4ge1xuICAgICAgY29uc3QgY2FzdEVsZW1lbnQgPSB0aGlzLmlubmVyVHlwZS5jYXN0KHYsIE9iamVjdC5hc3NpZ24oe30sIF9vcHRzLCB7XG4gICAgICAgIHBhdGg6IGAke19vcHRzLnBhdGggfHwgJyd9WyR7aWR4fV1gXG4gICAgICB9KSk7XG4gICAgICBpZiAoY2FzdEVsZW1lbnQgIT09IHYpIHtcbiAgICAgICAgaXNDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjYXN0RWxlbWVudDtcbiAgICB9KTtcbiAgICByZXR1cm4gaXNDaGFuZ2VkID8gY2FzdEFycmF5IDogdmFsdWU7XG4gIH1cbiAgX3ZhbGlkYXRlKF92YWx1ZSwgb3B0aW9ucyA9IHt9LCBwYW5pYywgbmV4dCkge1xuICAgIHZhciBfb3B0aW9ucyRyZWN1cnNpdmU7XG4gICAgLy8gbGV0IHN5bmMgPSBvcHRpb25zLnN5bmM7XG4gICAgLy8gbGV0IHBhdGggPSBvcHRpb25zLnBhdGg7XG4gICAgbGV0IGlubmVyVHlwZSA9IHRoaXMuaW5uZXJUeXBlO1xuICAgIC8vIGxldCBlbmRFYXJseSA9IG9wdGlvbnMuYWJvcnRFYXJseSA/PyB0aGlzLnNwZWMuYWJvcnRFYXJseTtcbiAgICBsZXQgcmVjdXJzaXZlID0gKF9vcHRpb25zJHJlY3Vyc2l2ZSA9IG9wdGlvbnMucmVjdXJzaXZlKSAhPSBudWxsID8gX29wdGlvbnMkcmVjdXJzaXZlIDogdGhpcy5zcGVjLnJlY3Vyc2l2ZTtcbiAgICBvcHRpb25zLm9yaWdpbmFsVmFsdWUgIT0gbnVsbCA/IG9wdGlvbnMub3JpZ2luYWxWYWx1ZSA6IF92YWx1ZTtcbiAgICBzdXBlci5fdmFsaWRhdGUoX3ZhbHVlLCBvcHRpb25zLCBwYW5pYywgKGFycmF5RXJyb3JzLCB2YWx1ZSkgPT4ge1xuICAgICAgdmFyIF9vcHRpb25zJG9yaWdpbmFsVmFsdTI7XG4gICAgICBpZiAoIXJlY3Vyc2l2ZSB8fCAhaW5uZXJUeXBlIHx8ICF0aGlzLl90eXBlQ2hlY2sodmFsdWUpKSB7XG4gICAgICAgIG5leHQoYXJyYXlFcnJvcnMsIHZhbHVlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyAjOTUwIEVuc3VyZSB0aGF0IHNwYXJzZSBhcnJheSBlbXB0eSBzbG90cyBhcmUgdmFsaWRhdGVkXG4gICAgICBsZXQgdGVzdHMgPSBuZXcgQXJyYXkodmFsdWUubGVuZ3RoKTtcbiAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCB2YWx1ZS5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgdmFyIF9vcHRpb25zJG9yaWdpbmFsVmFsdTtcbiAgICAgICAgdGVzdHNbaW5kZXhdID0gaW5uZXJUeXBlLmFzTmVzdGVkVGVzdCh7XG4gICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICBpbmRleCxcbiAgICAgICAgICBwYXJlbnQ6IHZhbHVlLFxuICAgICAgICAgIHBhcmVudFBhdGg6IG9wdGlvbnMucGF0aCxcbiAgICAgICAgICBvcmlnaW5hbFBhcmVudDogKF9vcHRpb25zJG9yaWdpbmFsVmFsdSA9IG9wdGlvbnMub3JpZ2luYWxWYWx1ZSkgIT0gbnVsbCA/IF9vcHRpb25zJG9yaWdpbmFsVmFsdSA6IF92YWx1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRoaXMucnVuVGVzdHMoe1xuICAgICAgICB2YWx1ZSxcbiAgICAgICAgdGVzdHMsXG4gICAgICAgIG9yaWdpbmFsVmFsdWU6IChfb3B0aW9ucyRvcmlnaW5hbFZhbHUyID0gb3B0aW9ucy5vcmlnaW5hbFZhbHVlKSAhPSBudWxsID8gX29wdGlvbnMkb3JpZ2luYWxWYWx1MiA6IF92YWx1ZSxcbiAgICAgICAgb3B0aW9uc1xuICAgICAgfSwgcGFuaWMsIGlubmVyVHlwZUVycm9ycyA9PiBuZXh0KGlubmVyVHlwZUVycm9ycy5jb25jYXQoYXJyYXlFcnJvcnMpLCB2YWx1ZSkpO1xuICAgIH0pO1xuICB9XG4gIGNsb25lKHNwZWMpIHtcbiAgICBjb25zdCBuZXh0ID0gc3VwZXIuY2xvbmUoc3BlYyk7XG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciByZWFkb25seVxuICAgIG5leHQuaW5uZXJUeXBlID0gdGhpcy5pbm5lclR5cGU7XG4gICAgcmV0dXJuIG5leHQ7XG4gIH1cblxuICAvKiogUGFyc2UgYW4gaW5wdXQgSlNPTiBzdHJpbmcgdG8gYW4gb2JqZWN0ICovXG4gIGpzb24oKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKHBhcnNlSnNvbik7XG4gIH1cbiAgY29uY2F0KHNjaGVtYSkge1xuICAgIGxldCBuZXh0ID0gc3VwZXIuY29uY2F0KHNjaGVtYSk7XG5cbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIHJlYWRvbmx5XG4gICAgbmV4dC5pbm5lclR5cGUgPSB0aGlzLmlubmVyVHlwZTtcbiAgICBpZiAoc2NoZW1hLmlubmVyVHlwZSlcbiAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgcmVhZG9ubHlcbiAgICAgIG5leHQuaW5uZXJUeXBlID0gbmV4dC5pbm5lclR5cGUgP1xuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciBMYXp5IGRvZXNuJ3QgaGF2ZSBjb25jYXQgYW5kIHdpbGwgYnJlYWtcbiAgICAgIG5leHQuaW5uZXJUeXBlLmNvbmNhdChzY2hlbWEuaW5uZXJUeXBlKSA6IHNjaGVtYS5pbm5lclR5cGU7XG4gICAgcmV0dXJuIG5leHQ7XG4gIH1cbiAgb2Yoc2NoZW1hKSB7XG4gICAgLy8gRklYTUU6IHRoaXMgc2hvdWxkIHJldHVybiBhIG5ldyBpbnN0YW5jZSBvZiBhcnJheSB3aXRob3V0IHRoZSBkZWZhdWx0IHRvIGJlXG4gICAgbGV0IG5leHQgPSB0aGlzLmNsb25lKCk7XG4gICAgaWYgKCFpc1NjaGVtYShzY2hlbWEpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdgYXJyYXkub2YoKWAgc3ViLXNjaGVtYSBtdXN0IGJlIGEgdmFsaWQgeXVwIHNjaGVtYSBub3Q6ICcgKyBwcmludFZhbHVlKHNjaGVtYSkpO1xuXG4gICAgLy8gQHRzLWV4cGVjdC1lcnJvciByZWFkb25seVxuICAgIG5leHQuaW5uZXJUeXBlID0gc2NoZW1hO1xuICAgIG5leHQuc3BlYyA9IE9iamVjdC5hc3NpZ24oe30sIG5leHQuc3BlYywge1xuICAgICAgdHlwZXM6IHNjaGVtYVxuICAgIH0pO1xuICAgIHJldHVybiBuZXh0O1xuICB9XG4gIGxlbmd0aChsZW5ndGgsIG1lc3NhZ2UgPSBhcnJheS5sZW5ndGgpIHtcbiAgICByZXR1cm4gdGhpcy50ZXN0KHtcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBuYW1lOiAnbGVuZ3RoJyxcbiAgICAgIGV4Y2x1c2l2ZTogdHJ1ZSxcbiAgICAgIHBhcmFtczoge1xuICAgICAgICBsZW5ndGhcbiAgICAgIH0sXG4gICAgICBza2lwQWJzZW50OiB0cnVlLFxuICAgICAgdGVzdCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUubGVuZ3RoID09PSB0aGlzLnJlc29sdmUobGVuZ3RoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBtaW4obWluLCBtZXNzYWdlKSB7XG4gICAgbWVzc2FnZSA9IG1lc3NhZ2UgfHwgYXJyYXkubWluO1xuICAgIHJldHVybiB0aGlzLnRlc3Qoe1xuICAgICAgbWVzc2FnZSxcbiAgICAgIG5hbWU6ICdtaW4nLFxuICAgICAgZXhjbHVzaXZlOiB0cnVlLFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIG1pblxuICAgICAgfSxcbiAgICAgIHNraXBBYnNlbnQ6IHRydWUsXG4gICAgICAvLyBGSVhNRSh0cyk6IEFycmF5PHR5cGVvZiBUPlxuICAgICAgdGVzdCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUubGVuZ3RoID49IHRoaXMucmVzb2x2ZShtaW4pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIG1heChtYXgsIG1lc3NhZ2UpIHtcbiAgICBtZXNzYWdlID0gbWVzc2FnZSB8fCBhcnJheS5tYXg7XG4gICAgcmV0dXJuIHRoaXMudGVzdCh7XG4gICAgICBtZXNzYWdlLFxuICAgICAgbmFtZTogJ21heCcsXG4gICAgICBleGNsdXNpdmU6IHRydWUsXG4gICAgICBwYXJhbXM6IHtcbiAgICAgICAgbWF4XG4gICAgICB9LFxuICAgICAgc2tpcEFic2VudDogdHJ1ZSxcbiAgICAgIHRlc3QodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLmxlbmd0aCA8PSB0aGlzLnJlc29sdmUobWF4KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBlbnN1cmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVmYXVsdCgoKSA9PiBbXSkudHJhbnNmb3JtKCh2YWwsIG9yaWdpbmFsKSA9PiB7XG4gICAgICAvLyBXZSBkb24ndCB3YW50IHRvIHJldHVybiBgbnVsbGAgZm9yIG51bGxhYmxlIHNjaGVtYVxuICAgICAgaWYgKHRoaXMuX3R5cGVDaGVjayh2YWwpKSByZXR1cm4gdmFsO1xuICAgICAgcmV0dXJuIG9yaWdpbmFsID09IG51bGwgPyBbXSA6IFtdLmNvbmNhdChvcmlnaW5hbCk7XG4gICAgfSk7XG4gIH1cbiAgY29tcGFjdChyZWplY3Rvcikge1xuICAgIGxldCByZWplY3QgPSAhcmVqZWN0b3IgPyB2ID0+ICEhdiA6ICh2LCBpLCBhKSA9PiAhcmVqZWN0b3IodiwgaSwgYSk7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKHZhbHVlcyA9PiB2YWx1ZXMgIT0gbnVsbCA/IHZhbHVlcy5maWx0ZXIocmVqZWN0KSA6IHZhbHVlcyk7XG4gIH1cbiAgZGVzY3JpYmUob3B0aW9ucykge1xuICAgIGNvbnN0IG5leHQgPSAob3B0aW9ucyA/IHRoaXMucmVzb2x2ZShvcHRpb25zKSA6IHRoaXMpLmNsb25lKCk7XG4gICAgY29uc3QgYmFzZSA9IHN1cGVyLmRlc2NyaWJlKG9wdGlvbnMpO1xuICAgIGlmIChuZXh0LmlubmVyVHlwZSkge1xuICAgICAgdmFyIF9pbm5lck9wdGlvbnM7XG4gICAgICBsZXQgaW5uZXJPcHRpb25zID0gb3B0aW9ucztcbiAgICAgIGlmICgoX2lubmVyT3B0aW9ucyA9IGlubmVyT3B0aW9ucykgIT0gbnVsbCAmJiBfaW5uZXJPcHRpb25zLnZhbHVlKSB7XG4gICAgICAgIGlubmVyT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGlubmVyT3B0aW9ucywge1xuICAgICAgICAgIHBhcmVudDogaW5uZXJPcHRpb25zLnZhbHVlLFxuICAgICAgICAgIHZhbHVlOiBpbm5lck9wdGlvbnMudmFsdWVbMF1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBiYXNlLmlubmVyVHlwZSA9IG5leHQuaW5uZXJUeXBlLmRlc2NyaWJlKGlubmVyT3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiBiYXNlO1xuICB9XG59XG5jcmVhdGUkMi5wcm90b3R5cGUgPSBBcnJheVNjaGVtYS5wcm90b3R5cGU7XG5cbi8vIEB0cy1pZ25vcmVcbmZ1bmN0aW9uIGNyZWF0ZSQxKHNjaGVtYXMpIHtcbiAgcmV0dXJuIG5ldyBUdXBsZVNjaGVtYShzY2hlbWFzKTtcbn1cbmNsYXNzIFR1cGxlU2NoZW1hIGV4dGVuZHMgU2NoZW1hIHtcbiAgY29uc3RydWN0b3Ioc2NoZW1hcykge1xuICAgIHN1cGVyKHtcbiAgICAgIHR5cGU6ICd0dXBsZScsXG4gICAgICBzcGVjOiB7XG4gICAgICAgIHR5cGVzOiBzY2hlbWFzXG4gICAgICB9LFxuICAgICAgY2hlY2sodikge1xuICAgICAgICBjb25zdCB0eXBlcyA9IHRoaXMuc3BlYy50eXBlcztcbiAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodikgJiYgdi5sZW5ndGggPT09IHR5cGVzLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLndpdGhNdXRhdGlvbigoKSA9PiB7XG4gICAgICB0aGlzLnR5cGVFcnJvcih0dXBsZS5ub3RUeXBlKTtcbiAgICB9KTtcbiAgfVxuICBfY2FzdChpbnB1dFZhbHVlLCBvcHRpb25zKSB7XG4gICAgY29uc3Qge1xuICAgICAgdHlwZXNcbiAgICB9ID0gdGhpcy5zcGVjO1xuICAgIGNvbnN0IHZhbHVlID0gc3VwZXIuX2Nhc3QoaW5wdXRWYWx1ZSwgb3B0aW9ucyk7XG4gICAgaWYgKCF0aGlzLl90eXBlQ2hlY2sodmFsdWUpKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGxldCBpc0NoYW5nZWQgPSBmYWxzZTtcbiAgICBjb25zdCBjYXN0QXJyYXkgPSB0eXBlcy5tYXAoKHR5cGUsIGlkeCkgPT4ge1xuICAgICAgY29uc3QgY2FzdEVsZW1lbnQgPSB0eXBlLmNhc3QodmFsdWVbaWR4XSwgT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywge1xuICAgICAgICBwYXRoOiBgJHtvcHRpb25zLnBhdGggfHwgJyd9WyR7aWR4fV1gXG4gICAgICB9KSk7XG4gICAgICBpZiAoY2FzdEVsZW1lbnQgIT09IHZhbHVlW2lkeF0pIGlzQ2hhbmdlZCA9IHRydWU7XG4gICAgICByZXR1cm4gY2FzdEVsZW1lbnQ7XG4gICAgfSk7XG4gICAgcmV0dXJuIGlzQ2hhbmdlZCA/IGNhc3RBcnJheSA6IHZhbHVlO1xuICB9XG4gIF92YWxpZGF0ZShfdmFsdWUsIG9wdGlvbnMgPSB7fSwgcGFuaWMsIG5leHQpIHtcbiAgICBsZXQgaXRlbVR5cGVzID0gdGhpcy5zcGVjLnR5cGVzO1xuICAgIHN1cGVyLl92YWxpZGF0ZShfdmFsdWUsIG9wdGlvbnMsIHBhbmljLCAodHVwbGVFcnJvcnMsIHZhbHVlKSA9PiB7XG4gICAgICB2YXIgX29wdGlvbnMkb3JpZ2luYWxWYWx1MjtcbiAgICAgIC8vIGludGVudGlvbmFsbHkgbm90IHJlc3BlY3RpbmcgcmVjdXJzaXZlXG4gICAgICBpZiAoIXRoaXMuX3R5cGVDaGVjayh2YWx1ZSkpIHtcbiAgICAgICAgbmV4dCh0dXBsZUVycm9ycywgdmFsdWUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsZXQgdGVzdHMgPSBbXTtcbiAgICAgIGZvciAobGV0IFtpbmRleCwgaXRlbVNjaGVtYV0gb2YgaXRlbVR5cGVzLmVudHJpZXMoKSkge1xuICAgICAgICB2YXIgX29wdGlvbnMkb3JpZ2luYWxWYWx1O1xuICAgICAgICB0ZXN0c1tpbmRleF0gPSBpdGVtU2NoZW1hLmFzTmVzdGVkVGVzdCh7XG4gICAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgICBpbmRleCxcbiAgICAgICAgICBwYXJlbnQ6IHZhbHVlLFxuICAgICAgICAgIHBhcmVudFBhdGg6IG9wdGlvbnMucGF0aCxcbiAgICAgICAgICBvcmlnaW5hbFBhcmVudDogKF9vcHRpb25zJG9yaWdpbmFsVmFsdSA9IG9wdGlvbnMub3JpZ2luYWxWYWx1ZSkgIT0gbnVsbCA/IF9vcHRpb25zJG9yaWdpbmFsVmFsdSA6IF92YWx1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRoaXMucnVuVGVzdHMoe1xuICAgICAgICB2YWx1ZSxcbiAgICAgICAgdGVzdHMsXG4gICAgICAgIG9yaWdpbmFsVmFsdWU6IChfb3B0aW9ucyRvcmlnaW5hbFZhbHUyID0gb3B0aW9ucy5vcmlnaW5hbFZhbHVlKSAhPSBudWxsID8gX29wdGlvbnMkb3JpZ2luYWxWYWx1MiA6IF92YWx1ZSxcbiAgICAgICAgb3B0aW9uc1xuICAgICAgfSwgcGFuaWMsIGlubmVyVHlwZUVycm9ycyA9PiBuZXh0KGlubmVyVHlwZUVycm9ycy5jb25jYXQodHVwbGVFcnJvcnMpLCB2YWx1ZSkpO1xuICAgIH0pO1xuICB9XG4gIGRlc2NyaWJlKG9wdGlvbnMpIHtcbiAgICBjb25zdCBuZXh0ID0gKG9wdGlvbnMgPyB0aGlzLnJlc29sdmUob3B0aW9ucykgOiB0aGlzKS5jbG9uZSgpO1xuICAgIGNvbnN0IGJhc2UgPSBzdXBlci5kZXNjcmliZShvcHRpb25zKTtcbiAgICBiYXNlLmlubmVyVHlwZSA9IG5leHQuc3BlYy50eXBlcy5tYXAoKHNjaGVtYSwgaW5kZXgpID0+IHtcbiAgICAgIHZhciBfaW5uZXJPcHRpb25zO1xuICAgICAgbGV0IGlubmVyT3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICBpZiAoKF9pbm5lck9wdGlvbnMgPSBpbm5lck9wdGlvbnMpICE9IG51bGwgJiYgX2lubmVyT3B0aW9ucy52YWx1ZSkge1xuICAgICAgICBpbm5lck9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBpbm5lck9wdGlvbnMsIHtcbiAgICAgICAgICBwYXJlbnQ6IGlubmVyT3B0aW9ucy52YWx1ZSxcbiAgICAgICAgICB2YWx1ZTogaW5uZXJPcHRpb25zLnZhbHVlW2luZGV4XVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzY2hlbWEuZGVzY3JpYmUoaW5uZXJPcHRpb25zKTtcbiAgICB9KTtcbiAgICByZXR1cm4gYmFzZTtcbiAgfVxufVxuY3JlYXRlJDEucHJvdG90eXBlID0gVHVwbGVTY2hlbWEucHJvdG90eXBlO1xuXG5mdW5jdGlvbiBjcmVhdGUoYnVpbGRlcikge1xuICByZXR1cm4gbmV3IExhenkoYnVpbGRlcik7XG59XG5jbGFzcyBMYXp5IHtcbiAgY29uc3RydWN0b3IoYnVpbGRlcikge1xuICAgIHRoaXMudHlwZSA9ICdsYXp5JztcbiAgICB0aGlzLl9faXNZdXBTY2hlbWFfXyA9IHRydWU7XG4gICAgdGhpcy5zcGVjID0gdm9pZCAwO1xuICAgIHRoaXMuX3Jlc29sdmUgPSAodmFsdWUsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgbGV0IHNjaGVtYSA9IHRoaXMuYnVpbGRlcih2YWx1ZSwgb3B0aW9ucyk7XG4gICAgICBpZiAoIWlzU2NoZW1hKHNjaGVtYSkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2xhenkoKSBmdW5jdGlvbnMgbXVzdCByZXR1cm4gYSB2YWxpZCBzY2hlbWEnKTtcbiAgICAgIGlmICh0aGlzLnNwZWMub3B0aW9uYWwpIHNjaGVtYSA9IHNjaGVtYS5vcHRpb25hbCgpO1xuICAgICAgcmV0dXJuIHNjaGVtYS5yZXNvbHZlKG9wdGlvbnMpO1xuICAgIH07XG4gICAgdGhpcy5idWlsZGVyID0gYnVpbGRlcjtcbiAgICB0aGlzLnNwZWMgPSB7XG4gICAgICBtZXRhOiB1bmRlZmluZWQsXG4gICAgICBvcHRpb25hbDogZmFsc2VcbiAgICB9O1xuICB9XG4gIGNsb25lKHNwZWMpIHtcbiAgICBjb25zdCBuZXh0ID0gbmV3IExhenkodGhpcy5idWlsZGVyKTtcbiAgICBuZXh0LnNwZWMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLnNwZWMsIHNwZWMpO1xuICAgIHJldHVybiBuZXh0O1xuICB9XG4gIG9wdGlvbmFsaXR5KG9wdGlvbmFsKSB7XG4gICAgY29uc3QgbmV4dCA9IHRoaXMuY2xvbmUoe1xuICAgICAgb3B0aW9uYWxcbiAgICB9KTtcbiAgICByZXR1cm4gbmV4dDtcbiAgfVxuICBvcHRpb25hbCgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25hbGl0eSh0cnVlKTtcbiAgfVxuICByZXNvbHZlKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZShvcHRpb25zLnZhbHVlLCBvcHRpb25zKTtcbiAgfVxuICBjYXN0KHZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc29sdmUodmFsdWUsIG9wdGlvbnMpLmNhc3QodmFsdWUsIG9wdGlvbnMpO1xuICB9XG4gIGFzTmVzdGVkVGVzdChjb25maWcpIHtcbiAgICBsZXQge1xuICAgICAga2V5LFxuICAgICAgaW5kZXgsXG4gICAgICBwYXJlbnQsXG4gICAgICBvcHRpb25zXG4gICAgfSA9IGNvbmZpZztcbiAgICBsZXQgdmFsdWUgPSBwYXJlbnRbaW5kZXggIT0gbnVsbCA/IGluZGV4IDoga2V5XTtcbiAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZSh2YWx1ZSwgT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywge1xuICAgICAgdmFsdWUsXG4gICAgICBwYXJlbnRcbiAgICB9KSkuYXNOZXN0ZWRUZXN0KGNvbmZpZyk7XG4gIH1cbiAgdmFsaWRhdGUodmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZSh2YWx1ZSwgb3B0aW9ucykudmFsaWRhdGUodmFsdWUsIG9wdGlvbnMpO1xuICB9XG4gIHZhbGlkYXRlU3luYyh2YWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLl9yZXNvbHZlKHZhbHVlLCBvcHRpb25zKS52YWxpZGF0ZVN5bmModmFsdWUsIG9wdGlvbnMpO1xuICB9XG4gIHZhbGlkYXRlQXQocGF0aCwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZSh2YWx1ZSwgb3B0aW9ucykudmFsaWRhdGVBdChwYXRoLCB2YWx1ZSwgb3B0aW9ucyk7XG4gIH1cbiAgdmFsaWRhdGVTeW5jQXQocGF0aCwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZSh2YWx1ZSwgb3B0aW9ucykudmFsaWRhdGVTeW5jQXQocGF0aCwgdmFsdWUsIG9wdGlvbnMpO1xuICB9XG4gIGlzVmFsaWQodmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZSh2YWx1ZSwgb3B0aW9ucykuaXNWYWxpZCh2YWx1ZSwgb3B0aW9ucyk7XG4gIH1cbiAgaXNWYWxpZFN5bmModmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZSh2YWx1ZSwgb3B0aW9ucykuaXNWYWxpZFN5bmModmFsdWUsIG9wdGlvbnMpO1xuICB9XG4gIGRlc2NyaWJlKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gb3B0aW9ucyA/IHRoaXMucmVzb2x2ZShvcHRpb25zKS5kZXNjcmliZShvcHRpb25zKSA6IHtcbiAgICAgIHR5cGU6ICdsYXp5JyxcbiAgICAgIG1ldGE6IHRoaXMuc3BlYy5tZXRhLFxuICAgICAgbGFiZWw6IHVuZGVmaW5lZFxuICAgIH07XG4gIH1cbiAgbWV0YSguLi5hcmdzKSB7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5zcGVjLm1ldGE7XG4gICAgbGV0IG5leHQgPSB0aGlzLmNsb25lKCk7XG4gICAgbmV4dC5zcGVjLm1ldGEgPSBPYmplY3QuYXNzaWduKG5leHQuc3BlYy5tZXRhIHx8IHt9LCBhcmdzWzBdKTtcbiAgICByZXR1cm4gbmV4dDtcbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRMb2NhbGUoY3VzdG9tKSB7XG4gIE9iamVjdC5rZXlzKGN1c3RvbSkuZm9yRWFjaCh0eXBlID0+IHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgT2JqZWN0LmtleXMoY3VzdG9tW3R5cGVdKS5mb3JFYWNoKG1ldGhvZCA9PiB7XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICBsb2NhbGVbdHlwZV1bbWV0aG9kXSA9IGN1c3RvbVt0eXBlXVttZXRob2RdO1xuICAgIH0pO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gYWRkTWV0aG9kKHNjaGVtYVR5cGUsIG5hbWUsIGZuKSB7XG4gIGlmICghc2NoZW1hVHlwZSB8fCAhaXNTY2hlbWEoc2NoZW1hVHlwZS5wcm90b3R5cGUpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdZb3UgbXVzdCBwcm92aWRlIGEgeXVwIHNjaGVtYSBjb25zdHJ1Y3RvciBmdW5jdGlvbicpO1xuICBpZiAodHlwZW9mIG5hbWUgIT09ICdzdHJpbmcnKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBIE1ldGhvZCBuYW1lIG11c3QgYmUgcHJvdmlkZWQnKTtcbiAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IFR5cGVFcnJvcignTWV0aG9kIGZ1bmN0aW9uIG11c3QgYmUgcHJvdmlkZWQnKTtcbiAgc2NoZW1hVHlwZS5wcm90b3R5cGVbbmFtZV0gPSBmbjtcbn1cblxuZXhwb3J0IHsgQXJyYXlTY2hlbWEsIEJvb2xlYW5TY2hlbWEsIERhdGVTY2hlbWEsIE1peGVkU2NoZW1hLCBOdW1iZXJTY2hlbWEsIE9iamVjdFNjaGVtYSwgU2NoZW1hLCBTdHJpbmdTY2hlbWEsIFR1cGxlU2NoZW1hLCBWYWxpZGF0aW9uRXJyb3IsIGFkZE1ldGhvZCwgY3JlYXRlJDIgYXMgYXJyYXksIGNyZWF0ZSQ3IGFzIGJvb2wsIGNyZWF0ZSQ3IGFzIGJvb2xlYW4sIGNyZWF0ZSQ0IGFzIGRhdGUsIGxvY2FsZSBhcyBkZWZhdWx0TG9jYWxlLCBnZXRJbiwgaXNTY2hlbWEsIGNyZWF0ZSBhcyBsYXp5LCBjcmVhdGUkOCBhcyBtaXhlZCwgY3JlYXRlJDUgYXMgbnVtYmVyLCBjcmVhdGUkMyBhcyBvYmplY3QsIHByaW50VmFsdWUsIHJlYWNoLCBjcmVhdGUkOSBhcyByZWYsIHNldExvY2FsZSwgY3JlYXRlJDYgYXMgc3RyaW5nLCBjcmVhdGUkMSBhcyB0dXBsZSB9O1xuIl0sIm5hbWVzIjpbImdldHRlciIsImZvckVhY2giLCJzcGxpdCIsIm5vcm1hbGl6ZVBhdGgiLCJqb2luIiwiY2FtZWxDYXNlIiwic25ha2VDYXNlIiwidG9wb3NvcnQiLCJ0b1N0cmluZyIsIk9iamVjdCIsInByb3RvdHlwZSIsImVycm9yVG9TdHJpbmciLCJFcnJvciIsInJlZ0V4cFRvU3RyaW5nIiwiUmVnRXhwIiwic3ltYm9sVG9TdHJpbmciLCJTeW1ib2wiLCJTWU1CT0xfUkVHRVhQIiwicHJpbnROdW1iZXIiLCJ2YWwiLCJpc05lZ2F0aXZlWmVybyIsInByaW50U2ltcGxlVmFsdWUiLCJxdW90ZVN0cmluZ3MiLCJhcmd1bWVudHMiLCJsZW5ndGgiLCJ1bmRlZmluZWQiLCJ0eXBlT2YiLCJfdHlwZW9mIiwiY29uY2F0IiwibmFtZSIsImNhbGwiLCJyZXBsYWNlIiwidGFnIiwic2xpY2UiLCJpc05hTiIsImdldFRpbWUiLCJ0b0lTT1N0cmluZyIsInByaW50VmFsdWUiLCJ2YWx1ZSIsInJlc3VsdCIsIkpTT04iLCJzdHJpbmdpZnkiLCJrZXkiLCJ0b0FycmF5IiwiX1N5bWJvbCR0b1N0cmluZ1RhZyIsIl9TeW1ib2wkaGFzSW5zdGFuY2UiLCJfU3ltYm9sJHRvU3RyaW5nVGFnMiIsInN0clJlZyIsInRvU3RyaW5nVGFnIiwiVmFsaWRhdGlvbkVycm9yTm9TdGFjayIsIl9jcmVhdGVDbGFzcyIsImVycm9yT3JFcnJvcnMiLCJmaWVsZCIsInR5cGUiLCJfdGhpcyIsIl9jbGFzc0NhbGxDaGVjayIsIm1lc3NhZ2UiLCJwYXRoIiwicGFyYW1zIiwiZXJyb3JzIiwiaW5uZXIiLCJlcnIiLCJWYWxpZGF0aW9uRXJyb3IiLCJpc0Vycm9yIiwiX3RoaXMkZXJyb3JzIiwiX3RoaXMkaW5uZXIiLCJwdXNoIiwiYXBwbHkiLCJfdG9Db25zdW1hYmxlQXJyYXkiLCJpbm5lckVycm9ycyIsImhhc0luc3RhbmNlIiwiX0Vycm9yIiwiX1N5bWJvbCRoYXNJbnN0YW5jZTIiLCJkaXNhYmxlU3RhY2siLCJfdGhpczIiLCJlcnJvck5vU3RhY2siLCJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiIsIl9jYWxsU3VwZXIiLCJjYXB0dXJlU3RhY2tUcmFjZSIsIl9pbmhlcml0cyIsImZvcm1hdEVycm9yIiwibGFiZWwiLCJhc3NpZ24iLCJfIiwiaW5zdCIsIl9zdXBlclByb3BHZXQiLCJfd3JhcE5hdGl2ZVN1cGVyIiwibWl4ZWQiLCJkZWZhdWx0IiwicmVxdWlyZWQiLCJkZWZpbmVkIiwibm90TnVsbCIsIm9uZU9mIiwibm90T25lT2YiLCJub3RUeXBlIiwiX3JlZiIsIm9yaWdpbmFsVmFsdWUiLCJjYXN0TXNnIiwic3RyaW5nIiwibWluIiwibWF4IiwibWF0Y2hlcyIsImVtYWlsIiwidXJsIiwidXVpZCIsImRhdGV0aW1lIiwiZGF0ZXRpbWVfcHJlY2lzaW9uIiwiZGF0ZXRpbWVfb2Zmc2V0IiwidHJpbSIsImxvd2VyY2FzZSIsInVwcGVyY2FzZSIsIm51bWJlciIsImxlc3NUaGFuIiwibW9yZVRoYW4iLCJwb3NpdGl2ZSIsIm5lZ2F0aXZlIiwiaW50ZWdlciIsImRhdGUiLCJib29sZWFuIiwiaXNWYWx1ZSIsIm9iamVjdCIsIm5vVW5rbm93biIsImFycmF5IiwidHVwbGUiLCJzcGVjIiwidHlwZUxlbiIsInR5cGVzIiwiQXJyYXkiLCJpc0FycmF5IiwibG9jYWxlIiwiY3JlYXRlIiwiaXNTY2hlbWEiLCJvYmoiLCJfX2lzWXVwU2NoZW1hX18iLCJDb25kaXRpb24iLCJyZWZzIiwiYnVpbGRlciIsImZuIiwicmVzb2x2ZSIsImJhc2UiLCJvcHRpb25zIiwidmFsdWVzIiwibWFwIiwicmVmIiwiZ2V0VmFsdWUiLCJwYXJlbnQiLCJjb250ZXh0Iiwic2NoZW1hIiwiVHlwZUVycm9yIiwiZnJvbU9wdGlvbnMiLCJjb25maWciLCJ0aGVuIiwib3RoZXJ3aXNlIiwiaXMiLCJjaGVjayIsIl9sZW4iLCJfa2V5IiwiZXZlcnkiLCJfYnJhbmNoIiwiYnJhbmNoIiwicHJlZml4ZXMiLCJjcmVhdGUkOSIsIlJlZmVyZW5jZSIsImlzQ29udGV4dCIsImlzU2libGluZyIsInByZWZpeCIsImNhc3QiLCJkZXNjcmliZSIsImlzUmVmIiwiX19pc1l1cFJlZiIsImlzQWJzZW50IiwiY3JlYXRlVmFsaWRhdGlvbiIsInZhbGlkYXRlIiwiX3JlZjIiLCJwYW5pYyIsIm5leHQiLCJfcmVmMiRwYXRoIiwidGVzdCIsInNraXBBYnNlbnQiLCJfb3B0aW9ucyRhYm9ydEVhcmx5MiIsImFib3J0RWFybHkiLCJfb3B0aW9ucyRkaXNhYmxlU3RhY2s0IiwiZGlzYWJsZVN0YWNrVHJhY2UiLCJpdGVtIiwiY3JlYXRlRXJyb3IiLCJvdmVycmlkZXMiLCJuZXh0UGFyYW1zIiwiX2kiLCJfT2JqZWN0JGtleXMiLCJrZXlzIiwiZXJyb3IiLCJpbnZhbGlkIiwiY3R4IiwiZnJvbSIsImhhbmRsZVJlc3VsdCIsInZhbGlkT3JFcnJvciIsImhhbmRsZUVycm9yIiwic2hvdWxkU2tpcCIsIl9yZXN1bHQiLCJzeW5jIiwiUHJvbWlzZSIsIk9QVElPTlMiLCJnZXRJbiIsImxhc3RQYXJ0IiwibGFzdFBhcnREZWJ1ZyIsInBhcmVudFBhdGgiLCJfcGFydCIsImlzQnJhY2tldCIsInBhcnQiLCJpc1R1cGxlIiwiaWR4IiwicGFyc2VJbnQiLCJpbm5lclR5cGUiLCJmaWVsZHMiLCJyZWFjaCIsIlJlZmVyZW5jZVNldCIsIl9TZXQiLCJkZXNjcmlwdGlvbiIsIl9pdGVyYXRvciIsIl9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyIiwiX3N0ZXAiLCJzIiwibiIsImRvbmUiLCJlIiwiZiIsInJlc29sdmVBbGwiLCJfaXRlcmF0b3IyIiwiX3N0ZXAyIiwiY2xvbmUiLCJtZXJnZSIsIm5ld0l0ZW1zIiwicmVtb3ZlSXRlbXMiLCJhZGQiLCJkZWxldGUiLCJTZXQiLCJzcmMiLCJzZWVuIiwiTWFwIiwiaGFzIiwiZ2V0IiwiY29weSIsIkRhdGUiLCJzZXQiLCJpIiwiX2l0ZXJhdG9yMyIsImVudHJpZXMiLCJfc3RlcDMiLCJfc3RlcDMkdmFsdWUiLCJfc2xpY2VkVG9BcnJheSIsImsiLCJ2IiwiX2l0ZXJhdG9yNCIsIl9zdGVwNCIsIl9pMiIsIl9PYmplY3QkZW50cmllcyIsIl9PYmplY3QkZW50cmllcyRfaSIsIlNjaGVtYSIsIl90aGlzMyIsImRlcHMiLCJ0ZXN0cyIsInRyYW5zZm9ybXMiLCJjb25kaXRpb25zIiwiX211dGF0ZSIsImludGVybmFsVGVzdHMiLCJfd2hpdGVsaXN0IiwiX2JsYWNrbGlzdCIsImV4Y2x1c2l2ZVRlc3RzIiwiX3R5cGVDaGVjayIsIndpdGhNdXRhdGlvbiIsInR5cGVFcnJvciIsInN0cmlwIiwic3RyaWN0IiwicmVjdXJzaXZlIiwibnVsbGFibGUiLCJvcHRpb25hbCIsImNvZXJjZSIsIm5vbk51bGxhYmxlIiwiZ2V0UHJvdG90eXBlT2YiLCJtZXRhIiwiYmVmb3JlIiwiY29tYmluZWQiLCJtZXJnZWRTcGVjIiwiaXNUeXBlIiwicmVkdWNlIiwicHJldlNjaGVtYSIsImNvbmRpdGlvbiIsInJlc29sdmVPcHRpb25zIiwiX29wdGlvbnMkc3RyaWN0IiwiX29wdGlvbnMkYWJvcnRFYXJseSIsIl9vcHRpb25zJHJlY3Vyc2l2ZSIsIl9vcHRpb25zJGRpc2FibGVTdGFjayIsInJlc29sdmVkU2NoZW1hIiwiYWxsb3dPcHRpb25hbGl0eSIsImFzc2VydCIsIl9jYXN0IiwiZm9ybWF0dGVkVmFsdWUiLCJmb3JtYXR0ZWRSZXN1bHQiLCJyYXdWYWx1ZSIsIl90aGlzNCIsInByZXZWYWx1ZSIsImdldERlZmF1bHQiLCJfdmFsaWRhdGUiLCJfdmFsdWUiLCJfdGhpczUiLCJfb3B0aW9ucyRvcmlnaW5hbFZhbHUzIiwiX29wdGlvbnMkc3RyaWN0MiIsImluaXRpYWxUZXN0cyIsIl9pMyIsIl9PYmplY3QkdmFsdWVzIiwicnVuVGVzdHMiLCJpbml0aWFsRXJyb3JzIiwicnVuT3B0aW9ucyIsImZpcmVkIiwicGFuaWNPbmNlIiwiYXJnIiwibmV4dE9uY2UiLCJjb3VudCIsIm5lc3RlZEVycm9ycyIsImFyZ3MiLCJmaW5pc2hUZXN0UnVuIiwiYXNOZXN0ZWRUZXN0IiwiX3JlZjMiLCJfdGhpczYiLCJpbmRleCIsIm9yaWdpbmFsUGFyZW50IiwiaXNJbmRleCIsInRlc3RPcHRpb25zIiwiX2RlZmluZVByb3BlcnR5IiwiaW5jbHVkZXMiLCJfb3B0aW9ucyRkaXNhYmxlU3RhY2syIiwicmVqZWN0IiwicGFyc2VkIiwidmFsaWRhdGVkIiwidmFsaWRhdGVTeW5jIiwiX29wdGlvbnMkZGlzYWJsZVN0YWNrMyIsImlzVmFsaWQiLCJpc1ZhbGlkU3luYyIsIl9nZXREZWZhdWx0IiwiZGVmYXVsdFZhbHVlIiwiZGVmIiwiaXNTdHJpY3QiLCJudWxsYWJpbGl0eSIsIm9wdGlvbmFsaXR5Iiwibm90UmVxdWlyZWQiLCJ0cmFuc2Zvcm0iLCJvcHRzIiwiaXNFeGNsdXNpdmUiLCJleGNsdXNpdmUiLCJmaWx0ZXIiLCJ3aGVuIiwiZGVwIiwiZW51bXMiLCJ3aGl0ZUxpc3QiLCJ2YWxpZHMiLCJyZXNvbHZlZCIsImJsYWNrbGlzdCIsImludmFsaWRzIiwiX25leHQkc3BlYyIsImxpc3QiLCJmaW5kSW5kZXgiLCJjIiwiX2xvb3AiLCJtZXRob2QiLCJfYXJyIiwiX2k0IiwiX2dldEluIiwiX2k1IiwiX2FycjIiLCJhbGlhcyIsIl9pNiIsIl9hcnIzIiwicmV0dXJuc1RydWUiLCJjcmVhdGUkOCIsIk1peGVkU2NoZW1hIiwiX1NjaGVtYSIsImNyZWF0ZSQ3IiwiQm9vbGVhblNjaGVtYSIsIl9TY2hlbWEyIiwiX3RoaXM3IiwiQm9vbGVhbiIsInZhbHVlT2YiLCJfcmF3IiwiU3RyaW5nIiwiaXNUcnVlIiwiaXNGYWxzZSIsIm1zZyIsImlzb1JlZyIsInBhcnNlSXNvRGF0ZSIsInN0cnVjdCIsInBhcnNlRGF0ZVN0cnVjdCIsInBhcnNlIiwiTnVtYmVyIiwiTmFOIiwieiIsInBsdXNNaW51cyIsInllYXIiLCJtb250aCIsImRheSIsImhvdXIiLCJtaW51dGUiLCJzZWNvbmQiLCJtaWxsaXNlY29uZCIsInRvdGFsTWludXRlc09mZnNldCIsImhvdXJPZmZzZXQiLCJtaW51dGVPZmZzZXQiLCJVVEMiLCJfcmVnZXhSZXN1bHQkNyRsZW5ndGgiLCJfcmVnZXhSZXN1bHQkIiwicmVnZXhSZXN1bHQiLCJleGVjIiwidG9OdW1iZXIiLCJzdWJzdHJpbmciLCJwcmVjaXNpb24iLCJzdHIiLCJyRW1haWwiLCJyVXJsIiwiclVVSUQiLCJ5ZWFyTW9udGhEYXkiLCJob3VyTWludXRlU2Vjb25kIiwiek9yT2Zmc2V0Iiwicklzb0RhdGVUaW1lIiwiaXNUcmltbWVkIiwib2JqU3RyaW5nVGFnIiwiY3JlYXRlJDYiLCJTdHJpbmdTY2hlbWEiLCJfU2NoZW1hMyIsIl90aGlzOCIsInN0clZhbHVlIiwidCIsInJlZ2V4IiwiZXhjbHVkZUVtcHR5U3RyaW5nIiwiX29wdGlvbnMkZXhjbHVkZUVtcHR5Iiwic2VhcmNoIiwiYWxsb3dPZmZzZXQiLCJfb3B0aW9ucyRtZXNzYWdlIiwiX29wdGlvbnMkYWxsb3dPZmZzZXQiLCJfb3B0aW9ucyRwcmVjaXNpb24iLCJlbnN1cmUiLCJ0b0xvd2VyQ2FzZSIsInRvVXBwZXJDYXNlIiwiaXNOYU4kMSIsImNyZWF0ZSQ1IiwiTnVtYmVyU2NoZW1hIiwiX1NjaGVtYTQiLCJfdGhpczkiLCJwYXJzZUZsb2F0IiwibGVzcyIsIm1vcmUiLCJpc0ludGVnZXIiLCJ0cnVuY2F0ZSIsInJvdW5kIiwiX21ldGhvZCIsImF2YWlsIiwiaW5kZXhPZiIsIk1hdGgiLCJpbnZhbGlkRGF0ZSIsImlzRGF0ZSIsImNyZWF0ZSQ0IiwiRGF0ZVNjaGVtYSIsIl9TY2hlbWE1IiwiX3RoaXMxMCIsIklOVkFMSURfREFURSIsInByZXBhcmVQYXJhbSIsInBhcmFtIiwibGltaXQiLCJzb3J0RmllbGRzIiwiZXhjbHVkZWRFZGdlcyIsImVkZ2VzIiwibm9kZXMiLCJleGNsdWRlcyIsIl9yZWY0IiwiX3JlZjUiLCJhIiwiYiIsImFkZE5vZGUiLCJkZXBQYXRoIiwibm9kZSIsIl9sb29wMiIsIl9PYmplY3Qka2V5czIiLCJfaTciLCJyZXZlcnNlIiwiYXJyIiwiSW5maW5pdHkiLCJzb21lIiwiaWkiLCJfZXJyJHBhdGgiLCJzb3J0QnlLZXlPcmRlciIsInBhcnNlSnNvbiIsImRlZXBQYXJ0aWFsIiwicGFydGlhbCIsIl9pOCIsIl9PYmplY3QkZW50cmllczIiLCJfT2JqZWN0JGVudHJpZXMyJF9pIiwiZmllbGRTY2hlbWEiLCJzZXRGaWVsZHMiLCJuZXh0QXJyYXkiLCJkZWVwSGFzIiwicCIsImxhc3QiLCJwb3AiLCJpc09iamVjdCIsInVua25vd24iLCJrbm93biIsImRlZmF1bHRTb3J0IiwiY3JlYXRlJDMiLCJPYmplY3RTY2hlbWEiLCJfU2NoZW1hNiIsIl90aGlzMTEiLCJfc29ydEVycm9ycyIsIl9ub2RlcyIsIl9leGNsdWRlZEVkZ2VzIiwic2hhcGUiLCJfdGhpczEyIiwiX29wdGlvbnMkc3RyaXBVbmtub3duIiwic3RyaXBVbmtub3duIiwicHJvcHMiLCJpbnRlcm1lZGlhdGVWYWx1ZSIsImlubmVyT3B0aW9ucyIsIl9fdmFsaWRhdGluZyIsImlzQ2hhbmdlZCIsIl9pdGVyYXRvcjUiLCJfc3RlcDUiLCJwcm9wIiwiZXhpc3RzIiwiZmllbGRWYWx1ZSIsImlucHV0VmFsdWUiLCJmaWVsZFNwZWMiLCJfdGhpczEzIiwiX29wdGlvbnMkZnJvbSIsIl9vcHRpb25zJG9yaWdpbmFsVmFsdTQiLCJfb3B0aW9ucyRyZWN1cnNpdmUyIiwib2JqZWN0RXJyb3JzIiwiX2l0ZXJhdG9yNiIsIl9zdGVwNiIsImZpZWxkRXJyb3JzIiwic29ydCIsIl90aGlzMTQiLCJuZXh0RmllbGRzIiwiX2k5IiwiX09iamVjdCRlbnRyaWVzMyIsIl9PYmplY3QkZW50cmllczMkX2kiLCJzY2hlbWFPclJlZiIsInRhcmdldCIsIl90aGlzMTUiLCJkZnQiLCJfaW5uZXJPcHRpb25zIiwiYWRkaXRpb25zIiwiX2kxMCIsIl9PYmplY3QkZW50cmllczQiLCJfT2JqZWN0JGVudHJpZXM0JF9pIiwiRnVuY3Rpb24iLCJwaWNrIiwicGlja2VkIiwiX2l0ZXJhdG9yNyIsIl9zdGVwNyIsIl9yZWY2IiwiX3JlZjciLCJvbWl0IiwicmVtYWluaW5nIiwiX2kxMSIsIl9PYmplY3Qka2V5czMiLCJ0byIsImZyb21HZXR0ZXIiLCJuZXdPYmoiLCJqc29uIiwibm9BbGxvdyIsInVua25vd25LZXlzIiwiYWxsb3ciLCJ0cmFuc2Zvcm1LZXlzIiwiX2kxMiIsIl9PYmplY3Qka2V5czQiLCJjb25zdGFudENhc2UiLCJfaTEzIiwiX09iamVjdCRlbnRyaWVzNSIsIl9PYmplY3QkZW50cmllczUkX2kiLCJfaW5uZXJPcHRpb25zMiIsImNyZWF0ZSQyIiwiQXJyYXlTY2hlbWEiLCJfU2NoZW1hNyIsIl90aGlzMTYiLCJfb3B0cyIsIl90aGlzMTciLCJjYXN0QXJyYXkiLCJjYXN0RWxlbWVudCIsIl90aGlzMTgiLCJhcnJheUVycm9ycyIsIl9vcHRpb25zJG9yaWdpbmFsVmFsdTIiLCJfb3B0aW9ucyRvcmlnaW5hbFZhbHUiLCJpbm5lclR5cGVFcnJvcnMiLCJvZiIsIl90aGlzMTkiLCJvcmlnaW5hbCIsImNvbXBhY3QiLCJyZWplY3RvciIsImNyZWF0ZSQxIiwic2NoZW1hcyIsIlR1cGxlU2NoZW1hIiwiX1NjaGVtYTgiLCJfdGhpczIwIiwiX3RoaXMyMSIsIml0ZW1UeXBlcyIsInR1cGxlRXJyb3JzIiwiX2l0ZXJhdG9yOCIsIl9zdGVwOCIsIl9zdGVwOCR2YWx1ZSIsIml0ZW1TY2hlbWEiLCJMYXp5IiwiX3RoaXMyMiIsIl9yZXNvbHZlIiwidmFsaWRhdGVBdCIsInZhbGlkYXRlU3luY0F0Iiwic2V0TG9jYWxlIiwiY3VzdG9tIiwiYWRkTWV0aG9kIiwic2NoZW1hVHlwZSIsImJvb2wiLCJkZWZhdWx0TG9jYWxlIiwibGF6eSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///3135\n')},1575:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('\n// EXPORTS\n__webpack_require__.d(__webpack_exports__, {\n  t: () => (/* binding */ o)\n});\n\n// EXTERNAL MODULE: ./node_modules/react-hook-form/dist/index.esm.mjs\nvar index_esm = __webpack_require__(9785);\n;// ./node_modules/@hookform/resolvers/dist/resolvers.mjs\nconst s=(e,s,o)=>{if(e&&"reportValidity"in e){const r=(0,index_esm/* get */.Jt)(o,s);e.setCustomValidity(r&&r.message||""),e.reportValidity()}},resolvers_o=(t,e)=>{for(const o in e.fields){const r=e.fields[o];r&&r.ref&&"reportValidity"in r.ref?s(r.ref,o,t):r.refs&&r.refs.forEach(e=>s(e,o,t))}},r=(s,r)=>{r.shouldUseNativeValidation&&resolvers_o(s,r);const f={};for(const o in s){const n=(0,index_esm/* get */.Jt)(r.fields,o),a=Object.assign(s[o]||{},{ref:n&&n.ref});if(i(r.names||Object.keys(s),o)){const s=Object.assign({},(0,index_esm/* get */.Jt)(f,o));(0,index_esm/* set */.hZ)(s,"root",a),(0,index_esm/* set */.hZ)(f,o,s)}else (0,index_esm/* set */.hZ)(f,o,a)}return f},i=(t,e)=>t.some(t=>t.startsWith(e+"."));\n//# sourceMappingURL=resolvers.mjs.map\n\n;// ./node_modules/@hookform/resolvers/yup/dist/yup.mjs\nfunction o(o,n,a){return void 0===n&&(n={}),void 0===a&&(a={}),function(s,i,c){try{return Promise.resolve(function(t,r){try{var u=(n.context&&"development"==="production"&&0,Promise.resolve(o["sync"===a.mode?"validateSync":"validate"](s,Object.assign({abortEarly:!1},n,{context:i}))).then(function(t){return c.shouldUseNativeValidation&&resolvers_o({},c),{values:a.raw?s:t,errors:{}}}))}catch(e){return r(e)}return u&&u.then?u.then(void 0,r):u}(0,function(e){if(!e.inner)throw e;return{values:{},errors:r((o=e,n=!c.shouldUseNativeValidation&&"all"===c.criteriaMode,(o.inner||[]).reduce(function(e,t){if(e[t.path]||(e[t.path]={message:t.message,type:t.type}),n){var o=e[t.path].types,a=o&&o[t.type];e[t.path]=(0,index_esm/* appendErrors */.Gb)(t.path,n,e,t.type,a?[].concat(a,t.message):t.message)}return e},{})),c)};var o,n}))}catch(e){return Promise.reject(e)}}}\n//# sourceMappingURL=yup.module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMTU3NS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBK0Msa0JBQWtCLDRCQUE0QixRQUFRLHlCQUFDLE1BQU0sMERBQTBELENBQUMsV0FBQyxTQUFTLHlCQUF5QixvQkFBb0IscUZBQXFGLFdBQVcsNkJBQTZCLFdBQUMsTUFBTSxXQUFXLGtCQUFrQixRQUFRLHlCQUFDLHFDQUFxQyxFQUFFLGFBQWEsRUFBRSxpQ0FBaUMsd0JBQXdCLENBQUMseUJBQUMsT0FBTyx5QkFBQyxhQUFhLHlCQUFDLFFBQVEsS0FBSyx5QkFBQyxRQUFRLFNBQVMseUNBQStGO0FBQzdvQjs7O0FDRDhILGtCQUFrQix3QkFBd0IsbUJBQW1CLGtCQUFrQixJQUFJLHFDQUFxQyxJQUFJLGtDQUFrQyxZQUFvQixFQUFFLENBQTZHLCtFQUErRSxjQUFjLElBQUksVUFBVSxxQkFBcUIsb0NBQW9DLFdBQUMsR0FBRyxLQUFLLDRCQUE0QixHQUFHLFNBQVMsWUFBWSxvQ0FBb0MsZUFBZSxvQkFBb0IsT0FBTyxTQUFTLFFBQVEsQ0FBQyxnR0FBZ0csMEJBQTBCLDhCQUE4QixLQUFLLHFDQUFxQyxVQUFVLGtDQUFDLHVEQUF1RCxTQUFTLEdBQUcsT0FBTyxRQUFRLEdBQUcsU0FBUywyQkFBb0Q7QUFDL2pDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZm9vZC8uL25vZGVfbW9kdWxlcy9AaG9va2Zvcm0vcmVzb2x2ZXJzL2Rpc3QvcmVzb2x2ZXJzLm1qcz82ZDAyIiwid2VicGFjazovL2Zvb2QvLi9ub2RlX21vZHVsZXMvQGhvb2tmb3JtL3Jlc29sdmVycy95dXAvZGlzdC95dXAubWpzP2FlOWIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0e2dldCBhcyB0LHNldCBhcyBlfWZyb21cInJlYWN0LWhvb2stZm9ybVwiO2NvbnN0IHM9KGUscyxvKT0+e2lmKGUmJlwicmVwb3J0VmFsaWRpdHlcImluIGUpe2NvbnN0IHI9dChvLHMpO2Uuc2V0Q3VzdG9tVmFsaWRpdHkociYmci5tZXNzYWdlfHxcIlwiKSxlLnJlcG9ydFZhbGlkaXR5KCl9fSxvPSh0LGUpPT57Zm9yKGNvbnN0IG8gaW4gZS5maWVsZHMpe2NvbnN0IHI9ZS5maWVsZHNbb107ciYmci5yZWYmJlwicmVwb3J0VmFsaWRpdHlcImluIHIucmVmP3Moci5yZWYsbyx0KTpyLnJlZnMmJnIucmVmcy5mb3JFYWNoKGU9PnMoZSxvLHQpKX19LHI9KHMscik9PntyLnNob3VsZFVzZU5hdGl2ZVZhbGlkYXRpb24mJm8ocyxyKTtjb25zdCBmPXt9O2Zvcihjb25zdCBvIGluIHMpe2NvbnN0IG49dChyLmZpZWxkcyxvKSxhPU9iamVjdC5hc3NpZ24oc1tvXXx8e30se3JlZjpuJiZuLnJlZn0pO2lmKGkoci5uYW1lc3x8T2JqZWN0LmtleXMocyksbykpe2NvbnN0IHM9T2JqZWN0LmFzc2lnbih7fSx0KGYsbykpO2UocyxcInJvb3RcIixhKSxlKGYsbyxzKX1lbHNlIGUoZixvLGEpfXJldHVybiBmfSxpPSh0LGUpPT50LnNvbWUodD0+dC5zdGFydHNXaXRoKGUrXCIuXCIpKTtleHBvcnR7ciBhcyB0b05lc3RFcnJvcnMsbyBhcyB2YWxpZGF0ZUZpZWxkc05hdGl2ZWx5fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlc29sdmVycy5tanMubWFwXG4iLCJpbXBvcnR7dmFsaWRhdGVGaWVsZHNOYXRpdmVseSBhcyBlLHRvTmVzdEVycm9ycyBhcyB0fWZyb21cIkBob29rZm9ybS9yZXNvbHZlcnNcIjtpbXBvcnR7YXBwZW5kRXJyb3JzIGFzIHJ9ZnJvbVwicmVhY3QtaG9vay1mb3JtXCI7ZnVuY3Rpb24gbyhvLG4sYSl7cmV0dXJuIHZvaWQgMD09PW4mJihuPXt9KSx2b2lkIDA9PT1hJiYoYT17fSksZnVuY3Rpb24ocyxpLGMpe3RyeXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGZ1bmN0aW9uKHQscil7dHJ5e3ZhciB1PShuLmNvbnRleHQmJlwiZGV2ZWxvcG1lbnRcIj09PXByb2Nlc3MuZW52Lk5PREVfRU5WJiZjb25zb2xlLndhcm4oXCJZb3Ugc2hvdWxkIG5vdCB1c2VkIHRoZSB5dXAgb3B0aW9ucyBjb250ZXh0LiBQbGVhc2UsIHVzZSB0aGUgJ3VzZUZvcm0nIGNvbnRleHQgb2JqZWN0IGluc3RlYWRcIiksUHJvbWlzZS5yZXNvbHZlKG9bXCJzeW5jXCI9PT1hLm1vZGU/XCJ2YWxpZGF0ZVN5bmNcIjpcInZhbGlkYXRlXCJdKHMsT2JqZWN0LmFzc2lnbih7YWJvcnRFYXJseTohMX0sbix7Y29udGV4dDppfSkpKS50aGVuKGZ1bmN0aW9uKHQpe3JldHVybiBjLnNob3VsZFVzZU5hdGl2ZVZhbGlkYXRpb24mJmUoe30sYykse3ZhbHVlczphLnJhdz9zOnQsZXJyb3JzOnt9fX0pKX1jYXRjaChlKXtyZXR1cm4gcihlKX1yZXR1cm4gdSYmdS50aGVuP3UudGhlbih2b2lkIDAscik6dX0oMCxmdW5jdGlvbihlKXtpZighZS5pbm5lcil0aHJvdyBlO3JldHVybnt2YWx1ZXM6e30sZXJyb3JzOnQoKG89ZSxuPSFjLnNob3VsZFVzZU5hdGl2ZVZhbGlkYXRpb24mJlwiYWxsXCI9PT1jLmNyaXRlcmlhTW9kZSwoby5pbm5lcnx8W10pLnJlZHVjZShmdW5jdGlvbihlLHQpe2lmKGVbdC5wYXRoXXx8KGVbdC5wYXRoXT17bWVzc2FnZTp0Lm1lc3NhZ2UsdHlwZTp0LnR5cGV9KSxuKXt2YXIgbz1lW3QucGF0aF0udHlwZXMsYT1vJiZvW3QudHlwZV07ZVt0LnBhdGhdPXIodC5wYXRoLG4sZSx0LnR5cGUsYT9bXS5jb25jYXQoYSx0Lm1lc3NhZ2UpOnQubWVzc2FnZSl9cmV0dXJuIGV9LHt9KSksYyl9O3ZhciBvLG59KSl9Y2F0Y2goZSl7cmV0dXJuIFByb21pc2UucmVqZWN0KGUpfX19ZXhwb3J0e28gYXMgeXVwUmVzb2x2ZXJ9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9eXVwLm1vZHVsZS5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///1575\n')},9785:(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Gb: () => (/* binding */ appendErrors),\n/* harmony export */   Jt: () => (/* binding */ get),\n/* harmony export */   hZ: () => (/* binding */ set),\n/* harmony export */   mN: () => (/* binding */ useForm)\n/* harmony export */ });\n/* unused harmony exports Controller, Form, FormProvider, useController, useFieldArray, useFormContext, useFormState, useWatch */\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9471);\n\n\nvar isCheckBoxInput = (element) => element.type === 'checkbox';\n\nvar isDateObject = (value) => value instanceof Date;\n\nvar isNullOrUndefined = (value) => value == null;\n\nconst isObjectType = (value) => typeof value === 'object';\nvar isObject = (value) => !isNullOrUndefined(value) &&\n    !Array.isArray(value) &&\n    isObjectType(value) &&\n    !isDateObject(value);\n\nvar getEventValue = (event) => isObject(event) && event.target\n    ? isCheckBoxInput(event.target)\n        ? event.target.checked\n        : event.target.value\n    : event;\n\nvar getNodeParentName = (name) => name.substring(0, name.search(/\\.\\d+(\\.|$)/)) || name;\n\nvar isNameInFieldArray = (names, name) => names.has(getNodeParentName(name));\n\nvar isPlainObject = (tempObject) => {\n    const prototypeCopy = tempObject.constructor && tempObject.constructor.prototype;\n    return (isObject(prototypeCopy) && prototypeCopy.hasOwnProperty('isPrototypeOf'));\n};\n\nvar isWeb = typeof window !== 'undefined' &&\n    typeof window.HTMLElement !== 'undefined' &&\n    typeof document !== 'undefined';\n\nfunction cloneObject(data) {\n    let copy;\n    const isArray = Array.isArray(data);\n    if (data instanceof Date) {\n        copy = new Date(data);\n    }\n    else if (data instanceof Set) {\n        copy = new Set(data);\n    }\n    else if (!(isWeb && (data instanceof Blob || data instanceof FileList)) &&\n        (isArray || isObject(data))) {\n        copy = isArray ? [] : {};\n        if (!isArray && !isPlainObject(data)) {\n            copy = data;\n        }\n        else {\n            for (const key in data) {\n                if (data.hasOwnProperty(key)) {\n                    copy[key] = cloneObject(data[key]);\n                }\n            }\n        }\n    }\n    else {\n        return data;\n    }\n    return copy;\n}\n\nvar compact = (value) => Array.isArray(value) ? value.filter(Boolean) : [];\n\nvar isUndefined = (val) => val === undefined;\n\nvar get = (object, path, defaultValue) => {\n    if (!path || !isObject(object)) {\n        return defaultValue;\n    }\n    const result = compact(path.split(/[,[\\].]+?/)).reduce((result, key) => isNullOrUndefined(result) ? result : result[key], object);\n    return isUndefined(result) || result === object\n        ? isUndefined(object[path])\n            ? defaultValue\n            : object[path]\n        : result;\n};\n\nvar isBoolean = (value) => typeof value === 'boolean';\n\nvar isKey = (value) => /^\\w*$/.test(value);\n\nvar stringToPath = (input) => compact(input.replace(/[\"|']|\\]/g, '').split(/\\.|\\[/));\n\nvar set = (object, path, value) => {\n    let index = -1;\n    const tempPath = isKey(path) ? [path] : stringToPath(path);\n    const length = tempPath.length;\n    const lastIndex = length - 1;\n    while (++index < length) {\n        const key = tempPath[index];\n        let newValue = value;\n        if (index !== lastIndex) {\n            const objValue = object[key];\n            newValue =\n                isObject(objValue) || Array.isArray(objValue)\n                    ? objValue\n                    : !isNaN(+tempPath[index + 1])\n                        ? []\n                        : {};\n        }\n        if (key === '__proto__') {\n            return;\n        }\n        object[key] = newValue;\n        object = object[key];\n    }\n    return object;\n};\n\nconst EVENTS = {\n    BLUR: 'blur',\n    FOCUS_OUT: 'focusout',\n    CHANGE: 'change',\n};\nconst VALIDATION_MODE = {\n    onBlur: 'onBlur',\n    onChange: 'onChange',\n    onSubmit: 'onSubmit',\n    onTouched: 'onTouched',\n    all: 'all',\n};\nconst INPUT_VALIDATION_RULES = {\n    max: 'max',\n    min: 'min',\n    maxLength: 'maxLength',\n    minLength: 'minLength',\n    pattern: 'pattern',\n    required: 'required',\n    validate: 'validate',\n};\n\nconst HookFormContext = react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\n/**\n * This custom hook allows you to access the form context. useFormContext is intended to be used in deeply nested structures, where it would become inconvenient to pass the context as a prop. To be used with {@link FormProvider}.\n *\n * @remarks\n * [API](https://react-hook-form.com/docs/useformcontext) • [Demo](https://codesandbox.io/s/react-hook-form-v7-form-context-ytudi)\n *\n * @returns return all useForm methods\n *\n * @example\n * ```tsx\n * function App() {\n *   const methods = useForm();\n *   const onSubmit = data => console.log(data);\n *\n *   return (\n *     <FormProvider {...methods} >\n *       <form onSubmit={methods.handleSubmit(onSubmit)}>\n *         <NestedInput />\n *         <input type=\"submit\" />\n *       </form>\n *     </FormProvider>\n *   );\n * }\n *\n *  function NestedInput() {\n *   const { register } = useFormContext(); // retrieve all hook methods\n *   return <input {...register(\"test\")} />;\n * }\n * ```\n */\nconst useFormContext = () => React.useContext(HookFormContext);\n/**\n * A provider component that propagates the `useForm` methods to all children components via [React Context](https://reactjs.org/docs/context.html) API. To be used with {@link useFormContext}.\n *\n * @remarks\n * [API](https://react-hook-form.com/docs/useformcontext) • [Demo](https://codesandbox.io/s/react-hook-form-v7-form-context-ytudi)\n *\n * @param props - all useForm methods\n *\n * @example\n * ```tsx\n * function App() {\n *   const methods = useForm();\n *   const onSubmit = data => console.log(data);\n *\n *   return (\n *     <FormProvider {...methods} >\n *       <form onSubmit={methods.handleSubmit(onSubmit)}>\n *         <NestedInput />\n *         <input type=\"submit\" />\n *       </form>\n *     </FormProvider>\n *   );\n * }\n *\n *  function NestedInput() {\n *   const { register } = useFormContext(); // retrieve all hook methods\n *   return <input {...register(\"test\")} />;\n * }\n * ```\n */\nconst FormProvider = (props) => {\n    const { children, ...data } = props;\n    return (React.createElement(HookFormContext.Provider, { value: data }, children));\n};\n\nvar getProxyFormState = (formState, control, localProxyFormState, isRoot = true) => {\n    const result = {\n        defaultValues: control._defaultValues,\n    };\n    for (const key in formState) {\n        Object.defineProperty(result, key, {\n            get: () => {\n                const _key = key;\n                if (control._proxyFormState[_key] !== VALIDATION_MODE.all) {\n                    control._proxyFormState[_key] = !isRoot || VALIDATION_MODE.all;\n                }\n                localProxyFormState && (localProxyFormState[_key] = true);\n                return formState[_key];\n            },\n        });\n    }\n    return result;\n};\n\nvar isEmptyObject = (value) => isObject(value) && !Object.keys(value).length;\n\nvar shouldRenderFormState = (formStateData, _proxyFormState, updateFormState, isRoot) => {\n    updateFormState(formStateData);\n    const { name, ...formState } = formStateData;\n    return (isEmptyObject(formState) ||\n        Object.keys(formState).length >= Object.keys(_proxyFormState).length ||\n        Object.keys(formState).find((key) => _proxyFormState[key] ===\n            (!isRoot || VALIDATION_MODE.all)));\n};\n\nvar convertToArrayPayload = (value) => (Array.isArray(value) ? value : [value]);\n\nvar shouldSubscribeByName = (name, signalName, exact) => !name ||\n    !signalName ||\n    name === signalName ||\n    convertToArrayPayload(name).some((currentName) => currentName &&\n        (exact\n            ? currentName === signalName\n            : currentName.startsWith(signalName) ||\n                signalName.startsWith(currentName)));\n\nfunction useSubscribe(props) {\n    const _props = react__WEBPACK_IMPORTED_MODULE_0__.useRef(props);\n    _props.current = props;\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n        const subscription = !props.disabled &&\n            _props.current.subject &&\n            _props.current.subject.subscribe({\n                next: _props.current.next,\n            });\n        return () => {\n            subscription && subscription.unsubscribe();\n        };\n    }, [props.disabled]);\n}\n\n/**\n * This custom hook allows you to subscribe to each form state, and isolate the re-render at the custom hook level. It has its scope in terms of form state subscription, so it would not affect other useFormState and useForm. Using this hook can reduce the re-render impact on large and complex form application.\n *\n * @remarks\n * [API](https://react-hook-form.com/docs/useformstate) • [Demo](https://codesandbox.io/s/useformstate-75xly)\n *\n * @param props - include options on specify fields to subscribe. {@link UseFormStateReturn}\n *\n * @example\n * ```tsx\n * function App() {\n *   const { register, handleSubmit, control } = useForm({\n *     defaultValues: {\n *     firstName: \"firstName\"\n *   }});\n *   const { dirtyFields } = useFormState({\n *     control\n *   });\n *   const onSubmit = (data) => console.log(data);\n *\n *   return (\n *     <form onSubmit={handleSubmit(onSubmit)}>\n *       <input {...register(\"firstName\")} placeholder=\"First Name\" />\n *       {dirtyFields.firstName && <p>Field is dirty.</p>}\n *       <input type=\"submit\" />\n *     </form>\n *   );\n * }\n * ```\n */\nfunction useFormState(props) {\n    const methods = useFormContext();\n    const { control = methods.control, disabled, name, exact } = props || {};\n    const [formState, updateFormState] = React.useState(control._formState);\n    const _mounted = React.useRef(true);\n    const _localProxyFormState = React.useRef({\n        isDirty: false,\n        isLoading: false,\n        dirtyFields: false,\n        touchedFields: false,\n        validatingFields: false,\n        isValidating: false,\n        isValid: false,\n        errors: false,\n    });\n    const _name = React.useRef(name);\n    _name.current = name;\n    useSubscribe({\n        disabled,\n        next: (value) => _mounted.current &&\n            shouldSubscribeByName(_name.current, value.name, exact) &&\n            shouldRenderFormState(value, _localProxyFormState.current, control._updateFormState) &&\n            updateFormState({\n                ...control._formState,\n                ...value,\n            }),\n        subject: control._subjects.state,\n    });\n    React.useEffect(() => {\n        _mounted.current = true;\n        _localProxyFormState.current.isValid && control._updateValid(true);\n        return () => {\n            _mounted.current = false;\n        };\n    }, [control]);\n    return getProxyFormState(formState, control, _localProxyFormState.current, false);\n}\n\nvar isString = (value) => typeof value === 'string';\n\nvar generateWatchOutput = (names, _names, formValues, isGlobal, defaultValue) => {\n    if (isString(names)) {\n        isGlobal && _names.watch.add(names);\n        return get(formValues, names, defaultValue);\n    }\n    if (Array.isArray(names)) {\n        return names.map((fieldName) => (isGlobal && _names.watch.add(fieldName), get(formValues, fieldName)));\n    }\n    isGlobal && (_names.watchAll = true);\n    return formValues;\n};\n\n/**\n * Custom hook to subscribe to field change and isolate re-rendering at the component level.\n *\n * @remarks\n *\n * [API](https://react-hook-form.com/docs/usewatch) • [Demo](https://codesandbox.io/s/react-hook-form-v7-ts-usewatch-h9i5e)\n *\n * @example\n * ```tsx\n * const { control } = useForm();\n * const values = useWatch({\n *   name: \"fieldName\"\n *   control,\n * })\n * ```\n */\nfunction useWatch(props) {\n    const methods = useFormContext();\n    const { control = methods.control, name, defaultValue, disabled, exact, } = props || {};\n    const _name = React.useRef(name);\n    _name.current = name;\n    useSubscribe({\n        disabled,\n        subject: control._subjects.values,\n        next: (formState) => {\n            if (shouldSubscribeByName(_name.current, formState.name, exact)) {\n                updateValue(cloneObject(generateWatchOutput(_name.current, control._names, formState.values || control._formValues, false, defaultValue)));\n            }\n        },\n    });\n    const [value, updateValue] = React.useState(control._getWatch(name, defaultValue));\n    React.useEffect(() => control._removeUnmounted());\n    return value;\n}\n\n/**\n * Custom hook to work with controlled component, this function provide you with both form and field level state. Re-render is isolated at the hook level.\n *\n * @remarks\n * [API](https://react-hook-form.com/docs/usecontroller) • [Demo](https://codesandbox.io/s/usecontroller-0o8px)\n *\n * @param props - the path name to the form field value, and validation rules.\n *\n * @returns field properties, field and form state. {@link UseControllerReturn}\n *\n * @example\n * ```tsx\n * function Input(props) {\n *   const { field, fieldState, formState } = useController(props);\n *   return (\n *     <div>\n *       <input {...field} placeholder={props.name} />\n *       <p>{fieldState.isTouched && \"Touched\"}</p>\n *       <p>{formState.isSubmitted ? \"submitted\" : \"\"}</p>\n *     </div>\n *   );\n * }\n * ```\n */\nfunction useController(props) {\n    const methods = useFormContext();\n    const { name, disabled, control = methods.control, shouldUnregister } = props;\n    const isArrayField = isNameInFieldArray(control._names.array, name);\n    const value = useWatch({\n        control,\n        name,\n        defaultValue: get(control._formValues, name, get(control._defaultValues, name, props.defaultValue)),\n        exact: true,\n    });\n    const formState = useFormState({\n        control,\n        name,\n        exact: true,\n    });\n    const _registerProps = React.useRef(control.register(name, {\n        ...props.rules,\n        value,\n        ...(isBoolean(props.disabled) ? { disabled: props.disabled } : {}),\n    }));\n    React.useEffect(() => {\n        const _shouldUnregisterField = control._options.shouldUnregister || shouldUnregister;\n        const updateMounted = (name, value) => {\n            const field = get(control._fields, name);\n            if (field && field._f) {\n                field._f.mount = value;\n            }\n        };\n        updateMounted(name, true);\n        if (_shouldUnregisterField) {\n            const value = cloneObject(get(control._options.defaultValues, name));\n            set(control._defaultValues, name, value);\n            if (isUndefined(get(control._formValues, name))) {\n                set(control._formValues, name, value);\n            }\n        }\n        return () => {\n            (isArrayField\n                ? _shouldUnregisterField && !control._state.action\n                : _shouldUnregisterField)\n                ? control.unregister(name)\n                : updateMounted(name, false);\n        };\n    }, [name, control, isArrayField, shouldUnregister]);\n    React.useEffect(() => {\n        if (get(control._fields, name)) {\n            control._updateDisabledField({\n                disabled,\n                fields: control._fields,\n                name,\n                value: get(control._fields, name)._f.value,\n            });\n        }\n    }, [disabled, name, control]);\n    return {\n        field: {\n            name,\n            value,\n            ...(isBoolean(disabled) || formState.disabled\n                ? { disabled: formState.disabled || disabled }\n                : {}),\n            onChange: React.useCallback((event) => _registerProps.current.onChange({\n                target: {\n                    value: getEventValue(event),\n                    name: name,\n                },\n                type: EVENTS.CHANGE,\n            }), [name]),\n            onBlur: React.useCallback(() => _registerProps.current.onBlur({\n                target: {\n                    value: get(control._formValues, name),\n                    name: name,\n                },\n                type: EVENTS.BLUR,\n            }), [name, control]),\n            ref: React.useCallback((elm) => {\n                const field = get(control._fields, name);\n                if (field && elm) {\n                    field._f.ref = {\n                        focus: () => elm.focus(),\n                        select: () => elm.select(),\n                        setCustomValidity: (message) => elm.setCustomValidity(message),\n                        reportValidity: () => elm.reportValidity(),\n                    };\n                }\n            }, [control._fields, name]),\n        },\n        formState,\n        fieldState: Object.defineProperties({}, {\n            invalid: {\n                enumerable: true,\n                get: () => !!get(formState.errors, name),\n            },\n            isDirty: {\n                enumerable: true,\n                get: () => !!get(formState.dirtyFields, name),\n            },\n            isTouched: {\n                enumerable: true,\n                get: () => !!get(formState.touchedFields, name),\n            },\n            isValidating: {\n                enumerable: true,\n                get: () => !!get(formState.validatingFields, name),\n            },\n            error: {\n                enumerable: true,\n                get: () => get(formState.errors, name),\n            },\n        }),\n    };\n}\n\n/**\n * Component based on `useController` hook to work with controlled component.\n *\n * @remarks\n * [API](https://react-hook-form.com/docs/usecontroller/controller) • [Demo](https://codesandbox.io/s/react-hook-form-v6-controller-ts-jwyzw) • [Video](https://www.youtube.com/watch?v=N2UNk_UCVyA)\n *\n * @param props - the path name to the form field value, and validation rules.\n *\n * @returns provide field handler functions, field and form state.\n *\n * @example\n * ```tsx\n * function App() {\n *   const { control } = useForm<FormValues>({\n *     defaultValues: {\n *       test: \"\"\n *     }\n *   });\n *\n *   return (\n *     <form>\n *       <Controller\n *         control={control}\n *         name=\"test\"\n *         render={({ field: { onChange, onBlur, value, ref }, formState, fieldState }) => (\n *           <>\n *             <input\n *               onChange={onChange} // send value to hook form\n *               onBlur={onBlur} // notify when input is touched\n *               value={value} // return updated value\n *               ref={ref} // set ref for focus management\n *             />\n *             <p>{formState.isSubmitted ? \"submitted\" : \"\"}</p>\n *             <p>{fieldState.isTouched ? \"touched\" : \"\"}</p>\n *           </>\n *         )}\n *       />\n *     </form>\n *   );\n * }\n * ```\n */\nconst Controller = (props) => props.render(useController(props));\n\nconst flatten = (obj) => {\n    const output = {};\n    for (const key of Object.keys(obj)) {\n        if (isObjectType(obj[key])) {\n            const nested = flatten(obj[key]);\n            for (const nestedKey of Object.keys(nested)) {\n                output[`${key}.${nestedKey}`] = nested[nestedKey];\n            }\n        }\n        else {\n            output[key] = obj[key];\n        }\n    }\n    return output;\n};\n\nconst POST_REQUEST = 'post';\n/**\n * Form component to manage submission.\n *\n * @param props - to setup submission detail. {@link FormProps}\n *\n * @returns form component or headless render prop.\n *\n * @example\n * ```tsx\n * function App() {\n *   const { control, formState: { errors } } = useForm();\n *\n *   return (\n *     <Form action=\"/api\" control={control}>\n *       <input {...register(\"name\")} />\n *       <p>{errors?.root?.server && 'Server error'}</p>\n *       <button>Submit</button>\n *     </Form>\n *   );\n * }\n * ```\n */\nfunction Form(props) {\n    const methods = useFormContext();\n    const [mounted, setMounted] = React.useState(false);\n    const { control = methods.control, onSubmit, children, action, method = POST_REQUEST, headers, encType, onError, render, onSuccess, validateStatus, ...rest } = props;\n    const submit = async (event) => {\n        let hasError = false;\n        let type = '';\n        await control.handleSubmit(async (data) => {\n            const formData = new FormData();\n            let formDataJson = '';\n            try {\n                formDataJson = JSON.stringify(data);\n            }\n            catch (_a) { }\n            const flattenFormValues = flatten(control._formValues);\n            for (const key in flattenFormValues) {\n                formData.append(key, flattenFormValues[key]);\n            }\n            if (onSubmit) {\n                await onSubmit({\n                    data,\n                    event,\n                    method,\n                    formData,\n                    formDataJson,\n                });\n            }\n            if (action) {\n                try {\n                    const shouldStringifySubmissionData = [\n                        headers && headers['Content-Type'],\n                        encType,\n                    ].some((value) => value && value.includes('json'));\n                    const response = await fetch(action, {\n                        method,\n                        headers: {\n                            ...headers,\n                            ...(encType ? { 'Content-Type': encType } : {}),\n                        },\n                        body: shouldStringifySubmissionData ? formDataJson : formData,\n                    });\n                    if (response &&\n                        (validateStatus\n                            ? !validateStatus(response.status)\n                            : response.status < 200 || response.status >= 300)) {\n                        hasError = true;\n                        onError && onError({ response });\n                        type = String(response.status);\n                    }\n                    else {\n                        onSuccess && onSuccess({ response });\n                    }\n                }\n                catch (error) {\n                    hasError = true;\n                    onError && onError({ error });\n                }\n            }\n        })(event);\n        if (hasError && props.control) {\n            props.control._subjects.state.next({\n                isSubmitSuccessful: false,\n            });\n            props.control.setError('root.server', {\n                type,\n            });\n        }\n    };\n    React.useEffect(() => {\n        setMounted(true);\n    }, []);\n    return render ? (React.createElement(React.Fragment, null, render({\n        submit,\n    }))) : (React.createElement(\"form\", { noValidate: mounted, action: action, method: method, encType: encType, onSubmit: submit, ...rest }, children));\n}\n\nvar appendErrors = (name, validateAllFieldCriteria, errors, type, message) => validateAllFieldCriteria\n    ? {\n        ...errors[name],\n        types: {\n            ...(errors[name] && errors[name].types ? errors[name].types : {}),\n            [type]: message || true,\n        },\n    }\n    : {};\n\nvar generateId = () => {\n    const d = typeof performance === 'undefined' ? Date.now() : performance.now() * 1000;\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {\n        const r = (Math.random() * 16 + d) % 16 | 0;\n        return (c == 'x' ? r : (r & 0x3) | 0x8).toString(16);\n    });\n};\n\nvar getFocusFieldName = (name, index, options = {}) => options.shouldFocus || isUndefined(options.shouldFocus)\n    ? options.focusName ||\n        `${name}.${isUndefined(options.focusIndex) ? index : options.focusIndex}.`\n    : '';\n\nvar getValidationModes = (mode) => ({\n    isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,\n    isOnBlur: mode === VALIDATION_MODE.onBlur,\n    isOnChange: mode === VALIDATION_MODE.onChange,\n    isOnAll: mode === VALIDATION_MODE.all,\n    isOnTouch: mode === VALIDATION_MODE.onTouched,\n});\n\nvar isWatched = (name, _names, isBlurEvent) => !isBlurEvent &&\n    (_names.watchAll ||\n        _names.watch.has(name) ||\n        [..._names.watch].some((watchName) => name.startsWith(watchName) &&\n            /^\\.\\w+/.test(name.slice(watchName.length))));\n\nconst iterateFieldsByAction = (fields, action, fieldsNames, abortEarly) => {\n    for (const key of fieldsNames || Object.keys(fields)) {\n        const field = get(fields, key);\n        if (field) {\n            const { _f, ...currentField } = field;\n            if (_f) {\n                if (_f.refs && _f.refs[0] && action(_f.refs[0], key) && !abortEarly) {\n                    return true;\n                }\n                else if (_f.ref && action(_f.ref, _f.name) && !abortEarly) {\n                    return true;\n                }\n                else {\n                    if (iterateFieldsByAction(currentField, action)) {\n                        break;\n                    }\n                }\n            }\n            else if (isObject(currentField)) {\n                if (iterateFieldsByAction(currentField, action)) {\n                    break;\n                }\n            }\n        }\n    }\n    return;\n};\n\nvar updateFieldArrayRootError = (errors, error, name) => {\n    const fieldArrayErrors = convertToArrayPayload(get(errors, name));\n    set(fieldArrayErrors, 'root', error[name]);\n    set(errors, name, fieldArrayErrors);\n    return errors;\n};\n\nvar isFileInput = (element) => element.type === 'file';\n\nvar isFunction = (value) => typeof value === 'function';\n\nvar isHTMLElement = (value) => {\n    if (!isWeb) {\n        return false;\n    }\n    const owner = value ? value.ownerDocument : 0;\n    return (value instanceof\n        (owner && owner.defaultView ? owner.defaultView.HTMLElement : HTMLElement));\n};\n\nvar isMessage = (value) => isString(value);\n\nvar isRadioInput = (element) => element.type === 'radio';\n\nvar isRegex = (value) => value instanceof RegExp;\n\nconst defaultResult = {\n    value: false,\n    isValid: false,\n};\nconst validResult = { value: true, isValid: true };\nvar getCheckboxValue = (options) => {\n    if (Array.isArray(options)) {\n        if (options.length > 1) {\n            const values = options\n                .filter((option) => option && option.checked && !option.disabled)\n                .map((option) => option.value);\n            return { value: values, isValid: !!values.length };\n        }\n        return options[0].checked && !options[0].disabled\n            ? // @ts-expect-error expected to work in the browser\n                options[0].attributes && !isUndefined(options[0].attributes.value)\n                    ? isUndefined(options[0].value) || options[0].value === ''\n                        ? validResult\n                        : { value: options[0].value, isValid: true }\n                    : validResult\n            : defaultResult;\n    }\n    return defaultResult;\n};\n\nconst defaultReturn = {\n    isValid: false,\n    value: null,\n};\nvar getRadioValue = (options) => Array.isArray(options)\n    ? options.reduce((previous, option) => option && option.checked && !option.disabled\n        ? {\n            isValid: true,\n            value: option.value,\n        }\n        : previous, defaultReturn)\n    : defaultReturn;\n\nfunction getValidateError(result, ref, type = 'validate') {\n    if (isMessage(result) ||\n        (Array.isArray(result) && result.every(isMessage)) ||\n        (isBoolean(result) && !result)) {\n        return {\n            type,\n            message: isMessage(result) ? result : '',\n            ref,\n        };\n    }\n}\n\nvar getValueAndMessage = (validationData) => isObject(validationData) && !isRegex(validationData)\n    ? validationData\n    : {\n        value: validationData,\n        message: '',\n    };\n\nvar validateField = async (field, formValues, validateAllFieldCriteria, shouldUseNativeValidation, isFieldArray) => {\n    const { ref, refs, required, maxLength, minLength, min, max, pattern, validate, name, valueAsNumber, mount, disabled, } = field._f;\n    const inputValue = get(formValues, name);\n    if (!mount || disabled) {\n        return {};\n    }\n    const inputRef = refs ? refs[0] : ref;\n    const setCustomValidity = (message) => {\n        if (shouldUseNativeValidation && inputRef.reportValidity) {\n            inputRef.setCustomValidity(isBoolean(message) ? '' : message || '');\n            inputRef.reportValidity();\n        }\n    };\n    const error = {};\n    const isRadio = isRadioInput(ref);\n    const isCheckBox = isCheckBoxInput(ref);\n    const isRadioOrCheckbox = isRadio || isCheckBox;\n    const isEmpty = ((valueAsNumber || isFileInput(ref)) &&\n        isUndefined(ref.value) &&\n        isUndefined(inputValue)) ||\n        (isHTMLElement(ref) && ref.value === '') ||\n        inputValue === '' ||\n        (Array.isArray(inputValue) && !inputValue.length);\n    const appendErrorsCurry = appendErrors.bind(null, name, validateAllFieldCriteria, error);\n    const getMinMaxMessage = (exceedMax, maxLengthMessage, minLengthMessage, maxType = INPUT_VALIDATION_RULES.maxLength, minType = INPUT_VALIDATION_RULES.minLength) => {\n        const message = exceedMax ? maxLengthMessage : minLengthMessage;\n        error[name] = {\n            type: exceedMax ? maxType : minType,\n            message,\n            ref,\n            ...appendErrorsCurry(exceedMax ? maxType : minType, message),\n        };\n    };\n    if (isFieldArray\n        ? !Array.isArray(inputValue) || !inputValue.length\n        : required &&\n            ((!isRadioOrCheckbox && (isEmpty || isNullOrUndefined(inputValue))) ||\n                (isBoolean(inputValue) && !inputValue) ||\n                (isCheckBox && !getCheckboxValue(refs).isValid) ||\n                (isRadio && !getRadioValue(refs).isValid))) {\n        const { value, message } = isMessage(required)\n            ? { value: !!required, message: required }\n            : getValueAndMessage(required);\n        if (value) {\n            error[name] = {\n                type: INPUT_VALIDATION_RULES.required,\n                message,\n                ref: inputRef,\n                ...appendErrorsCurry(INPUT_VALIDATION_RULES.required, message),\n            };\n            if (!validateAllFieldCriteria) {\n                setCustomValidity(message);\n                return error;\n            }\n        }\n    }\n    if (!isEmpty && (!isNullOrUndefined(min) || !isNullOrUndefined(max))) {\n        let exceedMax;\n        let exceedMin;\n        const maxOutput = getValueAndMessage(max);\n        const minOutput = getValueAndMessage(min);\n        if (!isNullOrUndefined(inputValue) && !isNaN(inputValue)) {\n            const valueNumber = ref.valueAsNumber ||\n                (inputValue ? +inputValue : inputValue);\n            if (!isNullOrUndefined(maxOutput.value)) {\n                exceedMax = valueNumber > maxOutput.value;\n            }\n            if (!isNullOrUndefined(minOutput.value)) {\n                exceedMin = valueNumber < minOutput.value;\n            }\n        }\n        else {\n            const valueDate = ref.valueAsDate || new Date(inputValue);\n            const convertTimeToDate = (time) => new Date(new Date().toDateString() + ' ' + time);\n            const isTime = ref.type == 'time';\n            const isWeek = ref.type == 'week';\n            if (isString(maxOutput.value) && inputValue) {\n                exceedMax = isTime\n                    ? convertTimeToDate(inputValue) > convertTimeToDate(maxOutput.value)\n                    : isWeek\n                        ? inputValue > maxOutput.value\n                        : valueDate > new Date(maxOutput.value);\n            }\n            if (isString(minOutput.value) && inputValue) {\n                exceedMin = isTime\n                    ? convertTimeToDate(inputValue) < convertTimeToDate(minOutput.value)\n                    : isWeek\n                        ? inputValue < minOutput.value\n                        : valueDate < new Date(minOutput.value);\n            }\n        }\n        if (exceedMax || exceedMin) {\n            getMinMaxMessage(!!exceedMax, maxOutput.message, minOutput.message, INPUT_VALIDATION_RULES.max, INPUT_VALIDATION_RULES.min);\n            if (!validateAllFieldCriteria) {\n                setCustomValidity(error[name].message);\n                return error;\n            }\n        }\n    }\n    if ((maxLength || minLength) &&\n        !isEmpty &&\n        (isString(inputValue) || (isFieldArray && Array.isArray(inputValue)))) {\n        const maxLengthOutput = getValueAndMessage(maxLength);\n        const minLengthOutput = getValueAndMessage(minLength);\n        const exceedMax = !isNullOrUndefined(maxLengthOutput.value) &&\n            inputValue.length > +maxLengthOutput.value;\n        const exceedMin = !isNullOrUndefined(minLengthOutput.value) &&\n            inputValue.length < +minLengthOutput.value;\n        if (exceedMax || exceedMin) {\n            getMinMaxMessage(exceedMax, maxLengthOutput.message, minLengthOutput.message);\n            if (!validateAllFieldCriteria) {\n                setCustomValidity(error[name].message);\n                return error;\n            }\n        }\n    }\n    if (pattern && !isEmpty && isString(inputValue)) {\n        const { value: patternValue, message } = getValueAndMessage(pattern);\n        if (isRegex(patternValue) && !inputValue.match(patternValue)) {\n            error[name] = {\n                type: INPUT_VALIDATION_RULES.pattern,\n                message,\n                ref,\n                ...appendErrorsCurry(INPUT_VALIDATION_RULES.pattern, message),\n            };\n            if (!validateAllFieldCriteria) {\n                setCustomValidity(message);\n                return error;\n            }\n        }\n    }\n    if (validate) {\n        if (isFunction(validate)) {\n            const result = await validate(inputValue, formValues);\n            const validateError = getValidateError(result, inputRef);\n            if (validateError) {\n                error[name] = {\n                    ...validateError,\n                    ...appendErrorsCurry(INPUT_VALIDATION_RULES.validate, validateError.message),\n                };\n                if (!validateAllFieldCriteria) {\n                    setCustomValidity(validateError.message);\n                    return error;\n                }\n            }\n        }\n        else if (isObject(validate)) {\n            let validationResult = {};\n            for (const key in validate) {\n                if (!isEmptyObject(validationResult) && !validateAllFieldCriteria) {\n                    break;\n                }\n                const validateError = getValidateError(await validate[key](inputValue, formValues), inputRef, key);\n                if (validateError) {\n                    validationResult = {\n                        ...validateError,\n                        ...appendErrorsCurry(key, validateError.message),\n                    };\n                    setCustomValidity(validateError.message);\n                    if (validateAllFieldCriteria) {\n                        error[name] = validationResult;\n                    }\n                }\n            }\n            if (!isEmptyObject(validationResult)) {\n                error[name] = {\n                    ref: inputRef,\n                    ...validationResult,\n                };\n                if (!validateAllFieldCriteria) {\n                    return error;\n                }\n            }\n        }\n    }\n    setCustomValidity(true);\n    return error;\n};\n\nvar appendAt = (data, value) => [\n    ...data,\n    ...convertToArrayPayload(value),\n];\n\nvar fillEmptyArray = (value) => Array.isArray(value) ? value.map(() => undefined) : undefined;\n\nfunction insert(data, index, value) {\n    return [\n        ...data.slice(0, index),\n        ...convertToArrayPayload(value),\n        ...data.slice(index),\n    ];\n}\n\nvar moveArrayAt = (data, from, to) => {\n    if (!Array.isArray(data)) {\n        return [];\n    }\n    if (isUndefined(data[to])) {\n        data[to] = undefined;\n    }\n    data.splice(to, 0, data.splice(from, 1)[0]);\n    return data;\n};\n\nvar prependAt = (data, value) => [\n    ...convertToArrayPayload(value),\n    ...convertToArrayPayload(data),\n];\n\nfunction removeAtIndexes(data, indexes) {\n    let i = 0;\n    const temp = [...data];\n    for (const index of indexes) {\n        temp.splice(index - i, 1);\n        i++;\n    }\n    return compact(temp).length ? temp : [];\n}\nvar removeArrayAt = (data, index) => isUndefined(index)\n    ? []\n    : removeAtIndexes(data, convertToArrayPayload(index).sort((a, b) => a - b));\n\nvar swapArrayAt = (data, indexA, indexB) => {\n    [data[indexA], data[indexB]] = [data[indexB], data[indexA]];\n};\n\nfunction baseGet(object, updatePath) {\n    const length = updatePath.slice(0, -1).length;\n    let index = 0;\n    while (index < length) {\n        object = isUndefined(object) ? index++ : object[updatePath[index++]];\n    }\n    return object;\n}\nfunction isEmptyArray(obj) {\n    for (const key in obj) {\n        if (obj.hasOwnProperty(key) && !isUndefined(obj[key])) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction unset(object, path) {\n    const paths = Array.isArray(path)\n        ? path\n        : isKey(path)\n            ? [path]\n            : stringToPath(path);\n    const childObject = paths.length === 1 ? object : baseGet(object, paths);\n    const index = paths.length - 1;\n    const key = paths[index];\n    if (childObject) {\n        delete childObject[key];\n    }\n    if (index !== 0 &&\n        ((isObject(childObject) && isEmptyObject(childObject)) ||\n            (Array.isArray(childObject) && isEmptyArray(childObject)))) {\n        unset(object, paths.slice(0, -1));\n    }\n    return object;\n}\n\nvar updateAt = (fieldValues, index, value) => {\n    fieldValues[index] = value;\n    return fieldValues;\n};\n\n/**\n * A custom hook that exposes convenient methods to perform operations with a list of dynamic inputs that need to be appended, updated, removed etc. • [Demo](https://codesandbox.io/s/react-hook-form-usefieldarray-ssugn) • [Video](https://youtu.be/4MrbfGSFY2A)\n *\n * @remarks\n * [API](https://react-hook-form.com/docs/usefieldarray) • [Demo](https://codesandbox.io/s/react-hook-form-usefieldarray-ssugn)\n *\n * @param props - useFieldArray props\n *\n * @returns methods - functions to manipulate with the Field Arrays (dynamic inputs) {@link UseFieldArrayReturn}\n *\n * @example\n * ```tsx\n * function App() {\n *   const { register, control, handleSubmit, reset, trigger, setError } = useForm({\n *     defaultValues: {\n *       test: []\n *     }\n *   });\n *   const { fields, append } = useFieldArray({\n *     control,\n *     name: \"test\"\n *   });\n *\n *   return (\n *     <form onSubmit={handleSubmit(data => console.log(data))}>\n *       {fields.map((item, index) => (\n *          <input key={item.id} {...register(`test.${index}.firstName`)}  />\n *       ))}\n *       <button type=\"button\" onClick={() => append({ firstName: \"bill\" })}>\n *         append\n *       </button>\n *       <input type=\"submit\" />\n *     </form>\n *   );\n * }\n * ```\n */\nfunction useFieldArray(props) {\n    const methods = useFormContext();\n    const { control = methods.control, name, keyName = 'id', shouldUnregister, } = props;\n    const [fields, setFields] = React.useState(control._getFieldArray(name));\n    const ids = React.useRef(control._getFieldArray(name).map(generateId));\n    const _fieldIds = React.useRef(fields);\n    const _name = React.useRef(name);\n    const _actioned = React.useRef(false);\n    _name.current = name;\n    _fieldIds.current = fields;\n    control._names.array.add(name);\n    props.rules &&\n        control.register(name, props.rules);\n    useSubscribe({\n        next: ({ values, name: fieldArrayName, }) => {\n            if (fieldArrayName === _name.current || !fieldArrayName) {\n                const fieldValues = get(values, _name.current);\n                if (Array.isArray(fieldValues)) {\n                    setFields(fieldValues);\n                    ids.current = fieldValues.map(generateId);\n                }\n            }\n        },\n        subject: control._subjects.array,\n    });\n    const updateValues = React.useCallback((updatedFieldArrayValues) => {\n        _actioned.current = true;\n        control._updateFieldArray(name, updatedFieldArrayValues);\n    }, [control, name]);\n    const append = (value, options) => {\n        const appendValue = convertToArrayPayload(cloneObject(value));\n        const updatedFieldArrayValues = appendAt(control._getFieldArray(name), appendValue);\n        control._names.focus = getFocusFieldName(name, updatedFieldArrayValues.length - 1, options);\n        ids.current = appendAt(ids.current, appendValue.map(generateId));\n        updateValues(updatedFieldArrayValues);\n        setFields(updatedFieldArrayValues);\n        control._updateFieldArray(name, updatedFieldArrayValues, appendAt, {\n            argA: fillEmptyArray(value),\n        });\n    };\n    const prepend = (value, options) => {\n        const prependValue = convertToArrayPayload(cloneObject(value));\n        const updatedFieldArrayValues = prependAt(control._getFieldArray(name), prependValue);\n        control._names.focus = getFocusFieldName(name, 0, options);\n        ids.current = prependAt(ids.current, prependValue.map(generateId));\n        updateValues(updatedFieldArrayValues);\n        setFields(updatedFieldArrayValues);\n        control._updateFieldArray(name, updatedFieldArrayValues, prependAt, {\n            argA: fillEmptyArray(value),\n        });\n    };\n    const remove = (index) => {\n        const updatedFieldArrayValues = removeArrayAt(control._getFieldArray(name), index);\n        ids.current = removeArrayAt(ids.current, index);\n        updateValues(updatedFieldArrayValues);\n        setFields(updatedFieldArrayValues);\n        control._updateFieldArray(name, updatedFieldArrayValues, removeArrayAt, {\n            argA: index,\n        });\n    };\n    const insert$1 = (index, value, options) => {\n        const insertValue = convertToArrayPayload(cloneObject(value));\n        const updatedFieldArrayValues = insert(control._getFieldArray(name), index, insertValue);\n        control._names.focus = getFocusFieldName(name, index, options);\n        ids.current = insert(ids.current, index, insertValue.map(generateId));\n        updateValues(updatedFieldArrayValues);\n        setFields(updatedFieldArrayValues);\n        control._updateFieldArray(name, updatedFieldArrayValues, insert, {\n            argA: index,\n            argB: fillEmptyArray(value),\n        });\n    };\n    const swap = (indexA, indexB) => {\n        const updatedFieldArrayValues = control._getFieldArray(name);\n        swapArrayAt(updatedFieldArrayValues, indexA, indexB);\n        swapArrayAt(ids.current, indexA, indexB);\n        updateValues(updatedFieldArrayValues);\n        setFields(updatedFieldArrayValues);\n        control._updateFieldArray(name, updatedFieldArrayValues, swapArrayAt, {\n            argA: indexA,\n            argB: indexB,\n        }, false);\n    };\n    const move = (from, to) => {\n        const updatedFieldArrayValues = control._getFieldArray(name);\n        moveArrayAt(updatedFieldArrayValues, from, to);\n        moveArrayAt(ids.current, from, to);\n        updateValues(updatedFieldArrayValues);\n        setFields(updatedFieldArrayValues);\n        control._updateFieldArray(name, updatedFieldArrayValues, moveArrayAt, {\n            argA: from,\n            argB: to,\n        }, false);\n    };\n    const update = (index, value) => {\n        const updateValue = cloneObject(value);\n        const updatedFieldArrayValues = updateAt(control._getFieldArray(name), index, updateValue);\n        ids.current = [...updatedFieldArrayValues].map((item, i) => !item || i === index ? generateId() : ids.current[i]);\n        updateValues(updatedFieldArrayValues);\n        setFields([...updatedFieldArrayValues]);\n        control._updateFieldArray(name, updatedFieldArrayValues, updateAt, {\n            argA: index,\n            argB: updateValue,\n        }, true, false);\n    };\n    const replace = (value) => {\n        const updatedFieldArrayValues = convertToArrayPayload(cloneObject(value));\n        ids.current = updatedFieldArrayValues.map(generateId);\n        updateValues([...updatedFieldArrayValues]);\n        setFields([...updatedFieldArrayValues]);\n        control._updateFieldArray(name, [...updatedFieldArrayValues], (data) => data, {}, true, false);\n    };\n    React.useEffect(() => {\n        control._state.action = false;\n        isWatched(name, control._names) &&\n            control._subjects.state.next({\n                ...control._formState,\n            });\n        if (_actioned.current &&\n            (!getValidationModes(control._options.mode).isOnSubmit ||\n                control._formState.isSubmitted)) {\n            if (control._options.resolver) {\n                control._executeSchema([name]).then((result) => {\n                    const error = get(result.errors, name);\n                    const existingError = get(control._formState.errors, name);\n                    if (existingError\n                        ? (!error && existingError.type) ||\n                            (error &&\n                                (existingError.type !== error.type ||\n                                    existingError.message !== error.message))\n                        : error && error.type) {\n                        error\n                            ? set(control._formState.errors, name, error)\n                            : unset(control._formState.errors, name);\n                        control._subjects.state.next({\n                            errors: control._formState.errors,\n                        });\n                    }\n                });\n            }\n            else {\n                const field = get(control._fields, name);\n                if (field &&\n                    field._f &&\n                    !(getValidationModes(control._options.reValidateMode).isOnSubmit &&\n                        getValidationModes(control._options.mode).isOnSubmit)) {\n                    validateField(field, control._formValues, control._options.criteriaMode === VALIDATION_MODE.all, control._options.shouldUseNativeValidation, true).then((error) => !isEmptyObject(error) &&\n                        control._subjects.state.next({\n                            errors: updateFieldArrayRootError(control._formState.errors, error, name),\n                        }));\n                }\n            }\n        }\n        control._subjects.values.next({\n            name,\n            values: { ...control._formValues },\n        });\n        control._names.focus &&\n            iterateFieldsByAction(control._fields, (ref, key) => {\n                if (control._names.focus &&\n                    key.startsWith(control._names.focus) &&\n                    ref.focus) {\n                    ref.focus();\n                    return 1;\n                }\n                return;\n            });\n        control._names.focus = '';\n        control._updateValid();\n        _actioned.current = false;\n    }, [fields, name, control]);\n    React.useEffect(() => {\n        !get(control._formValues, name) && control._updateFieldArray(name);\n        return () => {\n            (control._options.shouldUnregister || shouldUnregister) &&\n                control.unregister(name);\n        };\n    }, [name, control, keyName, shouldUnregister]);\n    return {\n        swap: React.useCallback(swap, [updateValues, name, control]),\n        move: React.useCallback(move, [updateValues, name, control]),\n        prepend: React.useCallback(prepend, [updateValues, name, control]),\n        append: React.useCallback(append, [updateValues, name, control]),\n        remove: React.useCallback(remove, [updateValues, name, control]),\n        insert: React.useCallback(insert$1, [updateValues, name, control]),\n        update: React.useCallback(update, [updateValues, name, control]),\n        replace: React.useCallback(replace, [updateValues, name, control]),\n        fields: React.useMemo(() => fields.map((field, index) => ({\n            ...field,\n            [keyName]: ids.current[index] || generateId(),\n        })), [fields, keyName]),\n    };\n}\n\nvar createSubject = () => {\n    let _observers = [];\n    const next = (value) => {\n        for (const observer of _observers) {\n            observer.next && observer.next(value);\n        }\n    };\n    const subscribe = (observer) => {\n        _observers.push(observer);\n        return {\n            unsubscribe: () => {\n                _observers = _observers.filter((o) => o !== observer);\n            },\n        };\n    };\n    const unsubscribe = () => {\n        _observers = [];\n    };\n    return {\n        get observers() {\n            return _observers;\n        },\n        next,\n        subscribe,\n        unsubscribe,\n    };\n};\n\nvar isPrimitive = (value) => isNullOrUndefined(value) || !isObjectType(value);\n\nfunction deepEqual(object1, object2) {\n    if (isPrimitive(object1) || isPrimitive(object2)) {\n        return object1 === object2;\n    }\n    if (isDateObject(object1) && isDateObject(object2)) {\n        return object1.getTime() === object2.getTime();\n    }\n    const keys1 = Object.keys(object1);\n    const keys2 = Object.keys(object2);\n    if (keys1.length !== keys2.length) {\n        return false;\n    }\n    for (const key of keys1) {\n        const val1 = object1[key];\n        if (!keys2.includes(key)) {\n            return false;\n        }\n        if (key !== 'ref') {\n            const val2 = object2[key];\n            if ((isDateObject(val1) && isDateObject(val2)) ||\n                (isObject(val1) && isObject(val2)) ||\n                (Array.isArray(val1) && Array.isArray(val2))\n                ? !deepEqual(val1, val2)\n                : val1 !== val2) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nvar isMultipleSelect = (element) => element.type === `select-multiple`;\n\nvar isRadioOrCheckbox = (ref) => isRadioInput(ref) || isCheckBoxInput(ref);\n\nvar live = (ref) => isHTMLElement(ref) && ref.isConnected;\n\nvar objectHasFunction = (data) => {\n    for (const key in data) {\n        if (isFunction(data[key])) {\n            return true;\n        }\n    }\n    return false;\n};\n\nfunction markFieldsDirty(data, fields = {}) {\n    const isParentNodeArray = Array.isArray(data);\n    if (isObject(data) || isParentNodeArray) {\n        for (const key in data) {\n            if (Array.isArray(data[key]) ||\n                (isObject(data[key]) && !objectHasFunction(data[key]))) {\n                fields[key] = Array.isArray(data[key]) ? [] : {};\n                markFieldsDirty(data[key], fields[key]);\n            }\n            else if (!isNullOrUndefined(data[key])) {\n                fields[key] = true;\n            }\n        }\n    }\n    return fields;\n}\nfunction getDirtyFieldsFromDefaultValues(data, formValues, dirtyFieldsFromValues) {\n    const isParentNodeArray = Array.isArray(data);\n    if (isObject(data) || isParentNodeArray) {\n        for (const key in data) {\n            if (Array.isArray(data[key]) ||\n                (isObject(data[key]) && !objectHasFunction(data[key]))) {\n                if (isUndefined(formValues) ||\n                    isPrimitive(dirtyFieldsFromValues[key])) {\n                    dirtyFieldsFromValues[key] = Array.isArray(data[key])\n                        ? markFieldsDirty(data[key], [])\n                        : { ...markFieldsDirty(data[key]) };\n                }\n                else {\n                    getDirtyFieldsFromDefaultValues(data[key], isNullOrUndefined(formValues) ? {} : formValues[key], dirtyFieldsFromValues[key]);\n                }\n            }\n            else {\n                dirtyFieldsFromValues[key] = !deepEqual(data[key], formValues[key]);\n            }\n        }\n    }\n    return dirtyFieldsFromValues;\n}\nvar getDirtyFields = (defaultValues, formValues) => getDirtyFieldsFromDefaultValues(defaultValues, formValues, markFieldsDirty(formValues));\n\nvar getFieldValueAs = (value, { valueAsNumber, valueAsDate, setValueAs }) => isUndefined(value)\n    ? value\n    : valueAsNumber\n        ? value === ''\n            ? NaN\n            : value\n                ? +value\n                : value\n        : valueAsDate && isString(value)\n            ? new Date(value)\n            : setValueAs\n                ? setValueAs(value)\n                : value;\n\nfunction getFieldValue(_f) {\n    const ref = _f.ref;\n    if (_f.refs ? _f.refs.every((ref) => ref.disabled) : ref.disabled) {\n        return;\n    }\n    if (isFileInput(ref)) {\n        return ref.files;\n    }\n    if (isRadioInput(ref)) {\n        return getRadioValue(_f.refs).value;\n    }\n    if (isMultipleSelect(ref)) {\n        return [...ref.selectedOptions].map(({ value }) => value);\n    }\n    if (isCheckBoxInput(ref)) {\n        return getCheckboxValue(_f.refs).value;\n    }\n    return getFieldValueAs(isUndefined(ref.value) ? _f.ref.value : ref.value, _f);\n}\n\nvar getResolverOptions = (fieldsNames, _fields, criteriaMode, shouldUseNativeValidation) => {\n    const fields = {};\n    for (const name of fieldsNames) {\n        const field = get(_fields, name);\n        field && set(fields, name, field._f);\n    }\n    return {\n        criteriaMode,\n        names: [...fieldsNames],\n        fields,\n        shouldUseNativeValidation,\n    };\n};\n\nvar getRuleValue = (rule) => isUndefined(rule)\n    ? rule\n    : isRegex(rule)\n        ? rule.source\n        : isObject(rule)\n            ? isRegex(rule.value)\n                ? rule.value.source\n                : rule.value\n            : rule;\n\nconst ASYNC_FUNCTION = 'AsyncFunction';\nvar hasPromiseValidation = (fieldReference) => (!fieldReference || !fieldReference.validate) &&\n    !!((isFunction(fieldReference.validate) &&\n        fieldReference.validate.constructor.name === ASYNC_FUNCTION) ||\n        (isObject(fieldReference.validate) &&\n            Object.values(fieldReference.validate).find((validateFunction) => validateFunction.constructor.name === ASYNC_FUNCTION)));\n\nvar hasValidation = (options) => options.mount &&\n    (options.required ||\n        options.min ||\n        options.max ||\n        options.maxLength ||\n        options.minLength ||\n        options.pattern ||\n        options.validate);\n\nfunction schemaErrorLookup(errors, _fields, name) {\n    const error = get(errors, name);\n    if (error || isKey(name)) {\n        return {\n            error,\n            name,\n        };\n    }\n    const names = name.split('.');\n    while (names.length) {\n        const fieldName = names.join('.');\n        const field = get(_fields, fieldName);\n        const foundError = get(errors, fieldName);\n        if (field && !Array.isArray(field) && name !== fieldName) {\n            return { name };\n        }\n        if (foundError && foundError.type) {\n            return {\n                name: fieldName,\n                error: foundError,\n            };\n        }\n        names.pop();\n    }\n    return {\n        name,\n    };\n}\n\nvar skipValidation = (isBlurEvent, isTouched, isSubmitted, reValidateMode, mode) => {\n    if (mode.isOnAll) {\n        return false;\n    }\n    else if (!isSubmitted && mode.isOnTouch) {\n        return !(isTouched || isBlurEvent);\n    }\n    else if (isSubmitted ? reValidateMode.isOnBlur : mode.isOnBlur) {\n        return !isBlurEvent;\n    }\n    else if (isSubmitted ? reValidateMode.isOnChange : mode.isOnChange) {\n        return isBlurEvent;\n    }\n    return true;\n};\n\nvar unsetEmptyArray = (ref, name) => !compact(get(ref, name)).length && unset(ref, name);\n\nconst defaultOptions = {\n    mode: VALIDATION_MODE.onSubmit,\n    reValidateMode: VALIDATION_MODE.onChange,\n    shouldFocusError: true,\n};\nfunction createFormControl(props = {}) {\n    let _options = {\n        ...defaultOptions,\n        ...props,\n    };\n    let _formState = {\n        submitCount: 0,\n        isDirty: false,\n        isLoading: isFunction(_options.defaultValues),\n        isValidating: false,\n        isSubmitted: false,\n        isSubmitting: false,\n        isSubmitSuccessful: false,\n        isValid: false,\n        touchedFields: {},\n        dirtyFields: {},\n        validatingFields: {},\n        errors: _options.errors || {},\n        disabled: _options.disabled || false,\n    };\n    let _fields = {};\n    let _defaultValues = isObject(_options.defaultValues) || isObject(_options.values)\n        ? cloneObject(_options.defaultValues || _options.values) || {}\n        : {};\n    let _formValues = _options.shouldUnregister\n        ? {}\n        : cloneObject(_defaultValues);\n    let _state = {\n        action: false,\n        mount: false,\n        watch: false,\n    };\n    let _names = {\n        mount: new Set(),\n        unMount: new Set(),\n        array: new Set(),\n        watch: new Set(),\n    };\n    let delayErrorCallback;\n    let timer = 0;\n    const _proxyFormState = {\n        isDirty: false,\n        dirtyFields: false,\n        validatingFields: false,\n        touchedFields: false,\n        isValidating: false,\n        isValid: false,\n        errors: false,\n    };\n    const _subjects = {\n        values: createSubject(),\n        array: createSubject(),\n        state: createSubject(),\n    };\n    const validationModeBeforeSubmit = getValidationModes(_options.mode);\n    const validationModeAfterSubmit = getValidationModes(_options.reValidateMode);\n    const shouldDisplayAllAssociatedErrors = _options.criteriaMode === VALIDATION_MODE.all;\n    const debounce = (callback) => (wait) => {\n        clearTimeout(timer);\n        timer = setTimeout(callback, wait);\n    };\n    const _updateValid = async (shouldUpdateValid) => {\n        if (!_options.disabled && (_proxyFormState.isValid || shouldUpdateValid)) {\n            const isValid = _options.resolver\n                ? isEmptyObject((await _executeSchema()).errors)\n                : await executeBuiltInValidation(_fields, true);\n            if (isValid !== _formState.isValid) {\n                _subjects.state.next({\n                    isValid,\n                });\n            }\n        }\n    };\n    const _updateIsValidating = (names, isValidating) => {\n        if (!_options.disabled &&\n            (_proxyFormState.isValidating || _proxyFormState.validatingFields)) {\n            (names || Array.from(_names.mount)).forEach((name) => {\n                if (name) {\n                    isValidating\n                        ? set(_formState.validatingFields, name, isValidating)\n                        : unset(_formState.validatingFields, name);\n                }\n            });\n            _subjects.state.next({\n                validatingFields: _formState.validatingFields,\n                isValidating: !isEmptyObject(_formState.validatingFields),\n            });\n        }\n    };\n    const _updateFieldArray = (name, values = [], method, args, shouldSetValues = true, shouldUpdateFieldsAndState = true) => {\n        if (args && method && !_options.disabled) {\n            _state.action = true;\n            if (shouldUpdateFieldsAndState && Array.isArray(get(_fields, name))) {\n                const fieldValues = method(get(_fields, name), args.argA, args.argB);\n                shouldSetValues && set(_fields, name, fieldValues);\n            }\n            if (shouldUpdateFieldsAndState &&\n                Array.isArray(get(_formState.errors, name))) {\n                const errors = method(get(_formState.errors, name), args.argA, args.argB);\n                shouldSetValues && set(_formState.errors, name, errors);\n                unsetEmptyArray(_formState.errors, name);\n            }\n            if (_proxyFormState.touchedFields &&\n                shouldUpdateFieldsAndState &&\n                Array.isArray(get(_formState.touchedFields, name))) {\n                const touchedFields = method(get(_formState.touchedFields, name), args.argA, args.argB);\n                shouldSetValues && set(_formState.touchedFields, name, touchedFields);\n            }\n            if (_proxyFormState.dirtyFields) {\n                _formState.dirtyFields = getDirtyFields(_defaultValues, _formValues);\n            }\n            _subjects.state.next({\n                name,\n                isDirty: _getDirty(name, values),\n                dirtyFields: _formState.dirtyFields,\n                errors: _formState.errors,\n                isValid: _formState.isValid,\n            });\n        }\n        else {\n            set(_formValues, name, values);\n        }\n    };\n    const updateErrors = (name, error) => {\n        set(_formState.errors, name, error);\n        _subjects.state.next({\n            errors: _formState.errors,\n        });\n    };\n    const _setErrors = (errors) => {\n        _formState.errors = errors;\n        _subjects.state.next({\n            errors: _formState.errors,\n            isValid: false,\n        });\n    };\n    const updateValidAndValue = (name, shouldSkipSetValueAs, value, ref) => {\n        const field = get(_fields, name);\n        if (field) {\n            const defaultValue = get(_formValues, name, isUndefined(value) ? get(_defaultValues, name) : value);\n            isUndefined(defaultValue) ||\n                (ref && ref.defaultChecked) ||\n                shouldSkipSetValueAs\n                ? set(_formValues, name, shouldSkipSetValueAs ? defaultValue : getFieldValue(field._f))\n                : setFieldValue(name, defaultValue);\n            _state.mount && _updateValid();\n        }\n    };\n    const updateTouchAndDirty = (name, fieldValue, isBlurEvent, shouldDirty, shouldRender) => {\n        let shouldUpdateField = false;\n        let isPreviousDirty = false;\n        const output = {\n            name,\n        };\n        if (!_options.disabled) {\n            const disabledField = !!(get(_fields, name) &&\n                get(_fields, name)._f &&\n                get(_fields, name)._f.disabled);\n            if (!isBlurEvent || shouldDirty) {\n                if (_proxyFormState.isDirty) {\n                    isPreviousDirty = _formState.isDirty;\n                    _formState.isDirty = output.isDirty = _getDirty();\n                    shouldUpdateField = isPreviousDirty !== output.isDirty;\n                }\n                const isCurrentFieldPristine = disabledField || deepEqual(get(_defaultValues, name), fieldValue);\n                isPreviousDirty = !!(!disabledField && get(_formState.dirtyFields, name));\n                isCurrentFieldPristine || disabledField\n                    ? unset(_formState.dirtyFields, name)\n                    : set(_formState.dirtyFields, name, true);\n                output.dirtyFields = _formState.dirtyFields;\n                shouldUpdateField =\n                    shouldUpdateField ||\n                        (_proxyFormState.dirtyFields &&\n                            isPreviousDirty !== !isCurrentFieldPristine);\n            }\n            if (isBlurEvent) {\n                const isPreviousFieldTouched = get(_formState.touchedFields, name);\n                if (!isPreviousFieldTouched) {\n                    set(_formState.touchedFields, name, isBlurEvent);\n                    output.touchedFields = _formState.touchedFields;\n                    shouldUpdateField =\n                        shouldUpdateField ||\n                            (_proxyFormState.touchedFields &&\n                                isPreviousFieldTouched !== isBlurEvent);\n                }\n            }\n            shouldUpdateField && shouldRender && _subjects.state.next(output);\n        }\n        return shouldUpdateField ? output : {};\n    };\n    const shouldRenderByError = (name, isValid, error, fieldState) => {\n        const previousFieldError = get(_formState.errors, name);\n        const shouldUpdateValid = _proxyFormState.isValid &&\n            isBoolean(isValid) &&\n            _formState.isValid !== isValid;\n        if (props.delayError && error) {\n            delayErrorCallback = debounce(() => updateErrors(name, error));\n            delayErrorCallback(props.delayError);\n        }\n        else {\n            clearTimeout(timer);\n            delayErrorCallback = null;\n            error\n                ? set(_formState.errors, name, error)\n                : unset(_formState.errors, name);\n        }\n        if ((error ? !deepEqual(previousFieldError, error) : previousFieldError) ||\n            !isEmptyObject(fieldState) ||\n            shouldUpdateValid) {\n            const updatedFormState = {\n                ...fieldState,\n                ...(shouldUpdateValid && isBoolean(isValid) ? { isValid } : {}),\n                errors: _formState.errors,\n                name,\n            };\n            _formState = {\n                ..._formState,\n                ...updatedFormState,\n            };\n            _subjects.state.next(updatedFormState);\n        }\n    };\n    const _executeSchema = async (name) => {\n        _updateIsValidating(name, true);\n        const result = await _options.resolver(_formValues, _options.context, getResolverOptions(name || _names.mount, _fields, _options.criteriaMode, _options.shouldUseNativeValidation));\n        _updateIsValidating(name);\n        return result;\n    };\n    const executeSchemaAndUpdateState = async (names) => {\n        const { errors } = await _executeSchema(names);\n        if (names) {\n            for (const name of names) {\n                const error = get(errors, name);\n                error\n                    ? set(_formState.errors, name, error)\n                    : unset(_formState.errors, name);\n            }\n        }\n        else {\n            _formState.errors = errors;\n        }\n        return errors;\n    };\n    const executeBuiltInValidation = async (fields, shouldOnlyCheckValid, context = {\n        valid: true,\n    }) => {\n        for (const name in fields) {\n            const field = fields[name];\n            if (field) {\n                const { _f, ...fieldValue } = field;\n                if (_f) {\n                    const isFieldArrayRoot = _names.array.has(_f.name);\n                    const isPromiseFunction = field._f && hasPromiseValidation(field._f);\n                    if (isPromiseFunction && _proxyFormState.validatingFields) {\n                        _updateIsValidating([name], true);\n                    }\n                    const fieldError = await validateField(field, _formValues, shouldDisplayAllAssociatedErrors, _options.shouldUseNativeValidation && !shouldOnlyCheckValid, isFieldArrayRoot);\n                    if (isPromiseFunction && _proxyFormState.validatingFields) {\n                        _updateIsValidating([name]);\n                    }\n                    if (fieldError[_f.name]) {\n                        context.valid = false;\n                        if (shouldOnlyCheckValid) {\n                            break;\n                        }\n                    }\n                    !shouldOnlyCheckValid &&\n                        (get(fieldError, _f.name)\n                            ? isFieldArrayRoot\n                                ? updateFieldArrayRootError(_formState.errors, fieldError, _f.name)\n                                : set(_formState.errors, _f.name, fieldError[_f.name])\n                            : unset(_formState.errors, _f.name));\n                }\n                !isEmptyObject(fieldValue) &&\n                    (await executeBuiltInValidation(fieldValue, shouldOnlyCheckValid, context));\n            }\n        }\n        return context.valid;\n    };\n    const _removeUnmounted = () => {\n        for (const name of _names.unMount) {\n            const field = get(_fields, name);\n            field &&\n                (field._f.refs\n                    ? field._f.refs.every((ref) => !live(ref))\n                    : !live(field._f.ref)) &&\n                unregister(name);\n        }\n        _names.unMount = new Set();\n    };\n    const _getDirty = (name, data) => !_options.disabled &&\n        (name && data && set(_formValues, name, data),\n            !deepEqual(getValues(), _defaultValues));\n    const _getWatch = (names, defaultValue, isGlobal) => generateWatchOutput(names, _names, {\n        ...(_state.mount\n            ? _formValues\n            : isUndefined(defaultValue)\n                ? _defaultValues\n                : isString(names)\n                    ? { [names]: defaultValue }\n                    : defaultValue),\n    }, isGlobal, defaultValue);\n    const _getFieldArray = (name) => compact(get(_state.mount ? _formValues : _defaultValues, name, props.shouldUnregister ? get(_defaultValues, name, []) : []));\n    const setFieldValue = (name, value, options = {}) => {\n        const field = get(_fields, name);\n        let fieldValue = value;\n        if (field) {\n            const fieldReference = field._f;\n            if (fieldReference) {\n                !fieldReference.disabled &&\n                    set(_formValues, name, getFieldValueAs(value, fieldReference));\n                fieldValue =\n                    isHTMLElement(fieldReference.ref) && isNullOrUndefined(value)\n                        ? ''\n                        : value;\n                if (isMultipleSelect(fieldReference.ref)) {\n                    [...fieldReference.ref.options].forEach((optionRef) => (optionRef.selected = fieldValue.includes(optionRef.value)));\n                }\n                else if (fieldReference.refs) {\n                    if (isCheckBoxInput(fieldReference.ref)) {\n                        fieldReference.refs.length > 1\n                            ? fieldReference.refs.forEach((checkboxRef) => (!checkboxRef.defaultChecked || !checkboxRef.disabled) &&\n                                (checkboxRef.checked = Array.isArray(fieldValue)\n                                    ? !!fieldValue.find((data) => data === checkboxRef.value)\n                                    : fieldValue === checkboxRef.value))\n                            : fieldReference.refs[0] &&\n                                (fieldReference.refs[0].checked = !!fieldValue);\n                    }\n                    else {\n                        fieldReference.refs.forEach((radioRef) => (radioRef.checked = radioRef.value === fieldValue));\n                    }\n                }\n                else if (isFileInput(fieldReference.ref)) {\n                    fieldReference.ref.value = '';\n                }\n                else {\n                    fieldReference.ref.value = fieldValue;\n                    if (!fieldReference.ref.type) {\n                        _subjects.values.next({\n                            name,\n                            values: { ..._formValues },\n                        });\n                    }\n                }\n            }\n        }\n        (options.shouldDirty || options.shouldTouch) &&\n            updateTouchAndDirty(name, fieldValue, options.shouldTouch, options.shouldDirty, true);\n        options.shouldValidate && trigger(name);\n    };\n    const setValues = (name, value, options) => {\n        for (const fieldKey in value) {\n            const fieldValue = value[fieldKey];\n            const fieldName = `${name}.${fieldKey}`;\n            const field = get(_fields, fieldName);\n            (_names.array.has(name) ||\n                isObject(fieldValue) ||\n                (field && !field._f)) &&\n                !isDateObject(fieldValue)\n                ? setValues(fieldName, fieldValue, options)\n                : setFieldValue(fieldName, fieldValue, options);\n        }\n    };\n    const setValue = (name, value, options = {}) => {\n        const field = get(_fields, name);\n        const isFieldArray = _names.array.has(name);\n        const cloneValue = cloneObject(value);\n        set(_formValues, name, cloneValue);\n        if (isFieldArray) {\n            _subjects.array.next({\n                name,\n                values: { ..._formValues },\n            });\n            if ((_proxyFormState.isDirty || _proxyFormState.dirtyFields) &&\n                options.shouldDirty) {\n                _subjects.state.next({\n                    name,\n                    dirtyFields: getDirtyFields(_defaultValues, _formValues),\n                    isDirty: _getDirty(name, cloneValue),\n                });\n            }\n        }\n        else {\n            field && !field._f && !isNullOrUndefined(cloneValue)\n                ? setValues(name, cloneValue, options)\n                : setFieldValue(name, cloneValue, options);\n        }\n        isWatched(name, _names) && _subjects.state.next({ ..._formState });\n        _subjects.values.next({\n            name: _state.mount ? name : undefined,\n            values: { ..._formValues },\n        });\n    };\n    const onChange = async (event) => {\n        _state.mount = true;\n        const target = event.target;\n        let name = target.name;\n        let isFieldValueUpdated = true;\n        const field = get(_fields, name);\n        const getCurrentFieldValue = () => target.type ? getFieldValue(field._f) : getEventValue(event);\n        const _updateIsFieldValueUpdated = (fieldValue) => {\n            isFieldValueUpdated =\n                Number.isNaN(fieldValue) ||\n                    (isDateObject(fieldValue) && isNaN(fieldValue.getTime())) ||\n                    deepEqual(fieldValue, get(_formValues, name, fieldValue));\n        };\n        if (field) {\n            let error;\n            let isValid;\n            const fieldValue = getCurrentFieldValue();\n            const isBlurEvent = event.type === EVENTS.BLUR || event.type === EVENTS.FOCUS_OUT;\n            const shouldSkipValidation = (!hasValidation(field._f) &&\n                !_options.resolver &&\n                !get(_formState.errors, name) &&\n                !field._f.deps) ||\n                skipValidation(isBlurEvent, get(_formState.touchedFields, name), _formState.isSubmitted, validationModeAfterSubmit, validationModeBeforeSubmit);\n            const watched = isWatched(name, _names, isBlurEvent);\n            set(_formValues, name, fieldValue);\n            if (isBlurEvent) {\n                field._f.onBlur && field._f.onBlur(event);\n                delayErrorCallback && delayErrorCallback(0);\n            }\n            else if (field._f.onChange) {\n                field._f.onChange(event);\n            }\n            const fieldState = updateTouchAndDirty(name, fieldValue, isBlurEvent, false);\n            const shouldRender = !isEmptyObject(fieldState) || watched;\n            !isBlurEvent &&\n                _subjects.values.next({\n                    name,\n                    type: event.type,\n                    values: { ..._formValues },\n                });\n            if (shouldSkipValidation) {\n                if (_proxyFormState.isValid) {\n                    if (props.mode === 'onBlur') {\n                        if (isBlurEvent) {\n                            _updateValid();\n                        }\n                    }\n                    else {\n                        _updateValid();\n                    }\n                }\n                return (shouldRender &&\n                    _subjects.state.next({ name, ...(watched ? {} : fieldState) }));\n            }\n            !isBlurEvent && watched && _subjects.state.next({ ..._formState });\n            if (_options.resolver) {\n                const { errors } = await _executeSchema([name]);\n                _updateIsFieldValueUpdated(fieldValue);\n                if (isFieldValueUpdated) {\n                    const previousErrorLookupResult = schemaErrorLookup(_formState.errors, _fields, name);\n                    const errorLookupResult = schemaErrorLookup(errors, _fields, previousErrorLookupResult.name || name);\n                    error = errorLookupResult.error;\n                    name = errorLookupResult.name;\n                    isValid = isEmptyObject(errors);\n                }\n            }\n            else {\n                _updateIsValidating([name], true);\n                error = (await validateField(field, _formValues, shouldDisplayAllAssociatedErrors, _options.shouldUseNativeValidation))[name];\n                _updateIsValidating([name]);\n                _updateIsFieldValueUpdated(fieldValue);\n                if (isFieldValueUpdated) {\n                    if (error) {\n                        isValid = false;\n                    }\n                    else if (_proxyFormState.isValid) {\n                        isValid = await executeBuiltInValidation(_fields, true);\n                    }\n                }\n            }\n            if (isFieldValueUpdated) {\n                field._f.deps &&\n                    trigger(field._f.deps);\n                shouldRenderByError(name, isValid, error, fieldState);\n            }\n        }\n    };\n    const _focusInput = (ref, key) => {\n        if (get(_formState.errors, key) && ref.focus) {\n            ref.focus();\n            return 1;\n        }\n        return;\n    };\n    const trigger = async (name, options = {}) => {\n        let isValid;\n        let validationResult;\n        const fieldNames = convertToArrayPayload(name);\n        if (_options.resolver) {\n            const errors = await executeSchemaAndUpdateState(isUndefined(name) ? name : fieldNames);\n            isValid = isEmptyObject(errors);\n            validationResult = name\n                ? !fieldNames.some((name) => get(errors, name))\n                : isValid;\n        }\n        else if (name) {\n            validationResult = (await Promise.all(fieldNames.map(async (fieldName) => {\n                const field = get(_fields, fieldName);\n                return await executeBuiltInValidation(field && field._f ? { [fieldName]: field } : field);\n            }))).every(Boolean);\n            !(!validationResult && !_formState.isValid) && _updateValid();\n        }\n        else {\n            validationResult = isValid = await executeBuiltInValidation(_fields);\n        }\n        _subjects.state.next({\n            ...(!isString(name) ||\n                (_proxyFormState.isValid && isValid !== _formState.isValid)\n                ? {}\n                : { name }),\n            ...(_options.resolver || !name ? { isValid } : {}),\n            errors: _formState.errors,\n        });\n        options.shouldFocus &&\n            !validationResult &&\n            iterateFieldsByAction(_fields, _focusInput, name ? fieldNames : _names.mount);\n        return validationResult;\n    };\n    const getValues = (fieldNames) => {\n        const values = {\n            ...(_state.mount ? _formValues : _defaultValues),\n        };\n        return isUndefined(fieldNames)\n            ? values\n            : isString(fieldNames)\n                ? get(values, fieldNames)\n                : fieldNames.map((name) => get(values, name));\n    };\n    const getFieldState = (name, formState) => ({\n        invalid: !!get((formState || _formState).errors, name),\n        isDirty: !!get((formState || _formState).dirtyFields, name),\n        error: get((formState || _formState).errors, name),\n        isValidating: !!get(_formState.validatingFields, name),\n        isTouched: !!get((formState || _formState).touchedFields, name),\n    });\n    const clearErrors = (name) => {\n        name &&\n            convertToArrayPayload(name).forEach((inputName) => unset(_formState.errors, inputName));\n        _subjects.state.next({\n            errors: name ? _formState.errors : {},\n        });\n    };\n    const setError = (name, error, options) => {\n        const ref = (get(_fields, name, { _f: {} })._f || {}).ref;\n        const currentError = get(_formState.errors, name) || {};\n        // Don't override existing error messages elsewhere in the object tree.\n        const { ref: currentRef, message, type, ...restOfErrorTree } = currentError;\n        set(_formState.errors, name, {\n            ...restOfErrorTree,\n            ...error,\n            ref,\n        });\n        _subjects.state.next({\n            name,\n            errors: _formState.errors,\n            isValid: false,\n        });\n        options && options.shouldFocus && ref && ref.focus && ref.focus();\n    };\n    const watch = (name, defaultValue) => isFunction(name)\n        ? _subjects.values.subscribe({\n            next: (payload) => name(_getWatch(undefined, defaultValue), payload),\n        })\n        : _getWatch(name, defaultValue, true);\n    const unregister = (name, options = {}) => {\n        for (const fieldName of name ? convertToArrayPayload(name) : _names.mount) {\n            _names.mount.delete(fieldName);\n            _names.array.delete(fieldName);\n            if (!options.keepValue) {\n                unset(_fields, fieldName);\n                unset(_formValues, fieldName);\n            }\n            !options.keepError && unset(_formState.errors, fieldName);\n            !options.keepDirty && unset(_formState.dirtyFields, fieldName);\n            !options.keepTouched && unset(_formState.touchedFields, fieldName);\n            !options.keepIsValidating &&\n                unset(_formState.validatingFields, fieldName);\n            !_options.shouldUnregister &&\n                !options.keepDefaultValue &&\n                unset(_defaultValues, fieldName);\n        }\n        _subjects.values.next({\n            values: { ..._formValues },\n        });\n        _subjects.state.next({\n            ..._formState,\n            ...(!options.keepDirty ? {} : { isDirty: _getDirty() }),\n        });\n        !options.keepIsValid && _updateValid();\n    };\n    const _updateDisabledField = ({ disabled, name, field, fields, value, }) => {\n        if ((isBoolean(disabled) && _state.mount) || !!disabled) {\n            const inputValue = disabled\n                ? undefined\n                : isUndefined(value)\n                    ? getFieldValue(field ? field._f : get(fields, name)._f)\n                    : value;\n            set(_formValues, name, inputValue);\n            updateTouchAndDirty(name, inputValue, false, false, true);\n        }\n    };\n    const register = (name, options = {}) => {\n        let field = get(_fields, name);\n        const disabledIsDefined = isBoolean(options.disabled) || isBoolean(_options.disabled);\n        set(_fields, name, {\n            ...(field || {}),\n            _f: {\n                ...(field && field._f ? field._f : { ref: { name } }),\n                name,\n                mount: true,\n                ...options,\n            },\n        });\n        _names.mount.add(name);\n        if (field) {\n            _updateDisabledField({\n                field,\n                disabled: isBoolean(options.disabled)\n                    ? options.disabled\n                    : _options.disabled,\n                name,\n                value: options.value,\n            });\n        }\n        else {\n            updateValidAndValue(name, true, options.value);\n        }\n        return {\n            ...(disabledIsDefined\n                ? { disabled: options.disabled || _options.disabled }\n                : {}),\n            ...(_options.progressive\n                ? {\n                    required: !!options.required,\n                    min: getRuleValue(options.min),\n                    max: getRuleValue(options.max),\n                    minLength: getRuleValue(options.minLength),\n                    maxLength: getRuleValue(options.maxLength),\n                    pattern: getRuleValue(options.pattern),\n                }\n                : {}),\n            name,\n            onChange,\n            onBlur: onChange,\n            ref: (ref) => {\n                if (ref) {\n                    register(name, options);\n                    field = get(_fields, name);\n                    const fieldRef = isUndefined(ref.value)\n                        ? ref.querySelectorAll\n                            ? ref.querySelectorAll('input,select,textarea')[0] || ref\n                            : ref\n                        : ref;\n                    const radioOrCheckbox = isRadioOrCheckbox(fieldRef);\n                    const refs = field._f.refs || [];\n                    if (radioOrCheckbox\n                        ? refs.find((option) => option === fieldRef)\n                        : fieldRef === field._f.ref) {\n                        return;\n                    }\n                    set(_fields, name, {\n                        _f: {\n                            ...field._f,\n                            ...(radioOrCheckbox\n                                ? {\n                                    refs: [\n                                        ...refs.filter(live),\n                                        fieldRef,\n                                        ...(Array.isArray(get(_defaultValues, name)) ? [{}] : []),\n                                    ],\n                                    ref: { type: fieldRef.type, name },\n                                }\n                                : { ref: fieldRef }),\n                        },\n                    });\n                    updateValidAndValue(name, false, undefined, fieldRef);\n                }\n                else {\n                    field = get(_fields, name, {});\n                    if (field._f) {\n                        field._f.mount = false;\n                    }\n                    (_options.shouldUnregister || options.shouldUnregister) &&\n                        !(isNameInFieldArray(_names.array, name) && _state.action) &&\n                        _names.unMount.add(name);\n                }\n            },\n        };\n    };\n    const _focusError = () => _options.shouldFocusError &&\n        iterateFieldsByAction(_fields, _focusInput, _names.mount);\n    const _disableForm = (disabled) => {\n        if (isBoolean(disabled)) {\n            _subjects.state.next({ disabled });\n            iterateFieldsByAction(_fields, (ref, name) => {\n                const currentField = get(_fields, name);\n                if (currentField) {\n                    ref.disabled = currentField._f.disabled || disabled;\n                    if (Array.isArray(currentField._f.refs)) {\n                        currentField._f.refs.forEach((inputRef) => {\n                            inputRef.disabled = currentField._f.disabled || disabled;\n                        });\n                    }\n                }\n            }, 0, false);\n        }\n    };\n    const handleSubmit = (onValid, onInvalid) => async (e) => {\n        let onValidError = undefined;\n        if (e) {\n            e.preventDefault && e.preventDefault();\n            e.persist && e.persist();\n        }\n        if (_options.disabled) {\n            if (onInvalid) {\n                await onInvalid({ ..._formState.errors }, e);\n            }\n            return;\n        }\n        let fieldValues = cloneObject(_formValues);\n        _subjects.state.next({\n            isSubmitting: true,\n        });\n        if (_options.resolver) {\n            const { errors, values } = await _executeSchema();\n            _formState.errors = errors;\n            fieldValues = values;\n        }\n        else {\n            await executeBuiltInValidation(_fields);\n        }\n        unset(_formState.errors, 'root');\n        if (isEmptyObject(_formState.errors)) {\n            _subjects.state.next({\n                errors: {},\n            });\n            try {\n                await onValid(fieldValues, e);\n            }\n            catch (error) {\n                onValidError = error;\n            }\n        }\n        else {\n            if (onInvalid) {\n                await onInvalid({ ..._formState.errors }, e);\n            }\n            _focusError();\n            setTimeout(_focusError);\n        }\n        _subjects.state.next({\n            isSubmitted: true,\n            isSubmitting: false,\n            isSubmitSuccessful: isEmptyObject(_formState.errors) && !onValidError,\n            submitCount: _formState.submitCount + 1,\n            errors: _formState.errors,\n        });\n        if (onValidError) {\n            throw onValidError;\n        }\n    };\n    const resetField = (name, options = {}) => {\n        if (get(_fields, name)) {\n            if (isUndefined(options.defaultValue)) {\n                setValue(name, cloneObject(get(_defaultValues, name)));\n            }\n            else {\n                setValue(name, options.defaultValue);\n                set(_defaultValues, name, cloneObject(options.defaultValue));\n            }\n            if (!options.keepTouched) {\n                unset(_formState.touchedFields, name);\n            }\n            if (!options.keepDirty) {\n                unset(_formState.dirtyFields, name);\n                _formState.isDirty = options.defaultValue\n                    ? _getDirty(name, cloneObject(get(_defaultValues, name)))\n                    : _getDirty();\n            }\n            if (!options.keepError) {\n                unset(_formState.errors, name);\n                _proxyFormState.isValid && _updateValid();\n            }\n            _subjects.state.next({ ..._formState });\n        }\n    };\n    const _reset = (formValues, keepStateOptions = {}) => {\n        const updatedValues = formValues ? cloneObject(formValues) : _defaultValues;\n        const cloneUpdatedValues = cloneObject(updatedValues);\n        const isEmptyResetValues = isEmptyObject(formValues);\n        const values = isEmptyResetValues ? _defaultValues : cloneUpdatedValues;\n        if (!keepStateOptions.keepDefaultValues) {\n            _defaultValues = updatedValues;\n        }\n        if (!keepStateOptions.keepValues) {\n            if (keepStateOptions.keepDirtyValues) {\n                const fieldsToCheck = new Set([\n                    ..._names.mount,\n                    ...Object.keys(getDirtyFields(_defaultValues, _formValues)),\n                ]);\n                for (const fieldName of Array.from(fieldsToCheck)) {\n                    get(_formState.dirtyFields, fieldName)\n                        ? set(values, fieldName, get(_formValues, fieldName))\n                        : setValue(fieldName, get(values, fieldName));\n                }\n            }\n            else {\n                if (isWeb && isUndefined(formValues)) {\n                    for (const name of _names.mount) {\n                        const field = get(_fields, name);\n                        if (field && field._f) {\n                            const fieldReference = Array.isArray(field._f.refs)\n                                ? field._f.refs[0]\n                                : field._f.ref;\n                            if (isHTMLElement(fieldReference)) {\n                                const form = fieldReference.closest('form');\n                                if (form) {\n                                    form.reset();\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                }\n                _fields = {};\n            }\n            _formValues = props.shouldUnregister\n                ? keepStateOptions.keepDefaultValues\n                    ? cloneObject(_defaultValues)\n                    : {}\n                : cloneObject(values);\n            _subjects.array.next({\n                values: { ...values },\n            });\n            _subjects.values.next({\n                values: { ...values },\n            });\n        }\n        _names = {\n            mount: keepStateOptions.keepDirtyValues ? _names.mount : new Set(),\n            unMount: new Set(),\n            array: new Set(),\n            watch: new Set(),\n            watchAll: false,\n            focus: '',\n        };\n        _state.mount =\n            !_proxyFormState.isValid ||\n                !!keepStateOptions.keepIsValid ||\n                !!keepStateOptions.keepDirtyValues;\n        _state.watch = !!props.shouldUnregister;\n        _subjects.state.next({\n            submitCount: keepStateOptions.keepSubmitCount\n                ? _formState.submitCount\n                : 0,\n            isDirty: isEmptyResetValues\n                ? false\n                : keepStateOptions.keepDirty\n                    ? _formState.isDirty\n                    : !!(keepStateOptions.keepDefaultValues &&\n                        !deepEqual(formValues, _defaultValues)),\n            isSubmitted: keepStateOptions.keepIsSubmitted\n                ? _formState.isSubmitted\n                : false,\n            dirtyFields: isEmptyResetValues\n                ? {}\n                : keepStateOptions.keepDirtyValues\n                    ? keepStateOptions.keepDefaultValues && _formValues\n                        ? getDirtyFields(_defaultValues, _formValues)\n                        : _formState.dirtyFields\n                    : keepStateOptions.keepDefaultValues && formValues\n                        ? getDirtyFields(_defaultValues, formValues)\n                        : keepStateOptions.keepDirty\n                            ? _formState.dirtyFields\n                            : {},\n            touchedFields: keepStateOptions.keepTouched\n                ? _formState.touchedFields\n                : {},\n            errors: keepStateOptions.keepErrors ? _formState.errors : {},\n            isSubmitSuccessful: keepStateOptions.keepIsSubmitSuccessful\n                ? _formState.isSubmitSuccessful\n                : false,\n            isSubmitting: false,\n        });\n    };\n    const reset = (formValues, keepStateOptions) => _reset(isFunction(formValues)\n        ? formValues(_formValues)\n        : formValues, keepStateOptions);\n    const setFocus = (name, options = {}) => {\n        const field = get(_fields, name);\n        const fieldReference = field && field._f;\n        if (fieldReference) {\n            const fieldRef = fieldReference.refs\n                ? fieldReference.refs[0]\n                : fieldReference.ref;\n            if (fieldRef.focus) {\n                fieldRef.focus();\n                options.shouldSelect &&\n                    isFunction(fieldRef.select) &&\n                    fieldRef.select();\n            }\n        }\n    };\n    const _updateFormState = (updatedFormState) => {\n        _formState = {\n            ..._formState,\n            ...updatedFormState,\n        };\n    };\n    const _resetDefaultValues = () => isFunction(_options.defaultValues) &&\n        _options.defaultValues().then((values) => {\n            reset(values, _options.resetOptions);\n            _subjects.state.next({\n                isLoading: false,\n            });\n        });\n    return {\n        control: {\n            register,\n            unregister,\n            getFieldState,\n            handleSubmit,\n            setError,\n            _executeSchema,\n            _getWatch,\n            _getDirty,\n            _updateValid,\n            _removeUnmounted,\n            _updateFieldArray,\n            _updateDisabledField,\n            _getFieldArray,\n            _reset,\n            _resetDefaultValues,\n            _updateFormState,\n            _disableForm,\n            _subjects,\n            _proxyFormState,\n            _setErrors,\n            get _fields() {\n                return _fields;\n            },\n            get _formValues() {\n                return _formValues;\n            },\n            get _state() {\n                return _state;\n            },\n            set _state(value) {\n                _state = value;\n            },\n            get _defaultValues() {\n                return _defaultValues;\n            },\n            get _names() {\n                return _names;\n            },\n            set _names(value) {\n                _names = value;\n            },\n            get _formState() {\n                return _formState;\n            },\n            set _formState(value) {\n                _formState = value;\n            },\n            get _options() {\n                return _options;\n            },\n            set _options(value) {\n                _options = {\n                    ..._options,\n                    ...value,\n                };\n            },\n        },\n        trigger,\n        register,\n        handleSubmit,\n        watch,\n        setValue,\n        getValues,\n        reset,\n        resetField,\n        clearErrors,\n        unregister,\n        setError,\n        setFocus,\n        getFieldState,\n    };\n}\n\n/**\n * Custom hook to manage the entire form.\n *\n * @remarks\n * [API](https://react-hook-form.com/docs/useform) • [Demo](https://codesandbox.io/s/react-hook-form-get-started-ts-5ksmm) • [Video](https://www.youtube.com/watch?v=RkXv4AXXC_4)\n *\n * @param props - form configuration and validation parameters.\n *\n * @returns methods - individual functions to manage the form state. {@link UseFormReturn}\n *\n * @example\n * ```tsx\n * function App() {\n *   const { register, handleSubmit, watch, formState: { errors } } = useForm();\n *   const onSubmit = data => console.log(data);\n *\n *   console.log(watch(\"example\"));\n *\n *   return (\n *     <form onSubmit={handleSubmit(onSubmit)}>\n *       <input defaultValue=\"test\" {...register(\"example\")} />\n *       <input {...register(\"exampleRequired\", { required: true })} />\n *       {errors.exampleRequired && <span>This field is required</span>}\n *       <button>Submit</button>\n *     </form>\n *   );\n * }\n * ```\n */\nfunction useForm(props = {}) {\n    const _formControl = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n    const _values = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n    const [formState, updateFormState] = react__WEBPACK_IMPORTED_MODULE_0__.useState({\n        isDirty: false,\n        isValidating: false,\n        isLoading: isFunction(props.defaultValues),\n        isSubmitted: false,\n        isSubmitting: false,\n        isSubmitSuccessful: false,\n        isValid: false,\n        submitCount: 0,\n        dirtyFields: {},\n        touchedFields: {},\n        validatingFields: {},\n        errors: props.errors || {},\n        disabled: props.disabled || false,\n        defaultValues: isFunction(props.defaultValues)\n            ? undefined\n            : props.defaultValues,\n    });\n    if (!_formControl.current) {\n        _formControl.current = {\n            ...createFormControl(props),\n            formState,\n        };\n    }\n    const control = _formControl.current.control;\n    control._options = props;\n    useSubscribe({\n        subject: control._subjects.state,\n        next: (value) => {\n            if (shouldRenderFormState(value, control._proxyFormState, control._updateFormState, true)) {\n                updateFormState({ ...control._formState });\n            }\n        },\n    });\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => control._disableForm(props.disabled), [control, props.disabled]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n        if (control._proxyFormState.isDirty) {\n            const isDirty = control._getDirty();\n            if (isDirty !== formState.isDirty) {\n                control._subjects.state.next({\n                    isDirty,\n                });\n            }\n        }\n    }, [control, formState.isDirty]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n        if (props.values && !deepEqual(props.values, _values.current)) {\n            control._reset(props.values, control._options.resetOptions);\n            _values.current = props.values;\n            updateFormState((state) => ({ ...state }));\n        }\n        else {\n            control._resetDefaultValues();\n        }\n    }, [props.values, control]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n        if (props.errors) {\n            control._setErrors(props.errors);\n        }\n    }, [props.errors, control]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n        if (!control._state.mount) {\n            control._updateValid();\n            control._state.mount = true;\n        }\n        if (control._state.watch) {\n            control._state.watch = false;\n            control._subjects.state.next({ ...control._formState });\n        }\n        control._removeUnmounted();\n    });\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(() => {\n        props.shouldUnregister &&\n            control._subjects.values.next({\n                values: control._getWatch(),\n            });\n    }, [props.shouldUnregister, control]);\n    _formControl.current.formState = getProxyFormState(formState, control);\n    return _formControl.current;\n}\n\n\n//# sourceMappingURL=index.esm.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxnSEFBZ0g7QUFDNUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpQkFBaUI7QUFDakMsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiwrQkFBK0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0Esa0dBQWtHO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdDQUFnQyx3Q0FBd0M7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxPQUFPO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6Qix1QkFBdUI7QUFDdkIsNEJBQTRCO0FBQzVCLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxVQUFVLElBQUk7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isb0JBQW9CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0EsS0FBSztBQUNMO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxnQkFBZ0I7QUFDdEQseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsS0FBSyxHQUFHLFNBQVM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGdCQUFnQjtBQUMxQyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELGVBQWU7QUFDekU7QUFDQTtBQUNBLHNCQUFzQixnQkFBZ0I7QUFDdEMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixnQkFBZ0I7QUFDOUMsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyx1QkFBdUIsZUFBZTtBQUNqRjtBQUNBLDhEQUE4RCxlQUFlO0FBQzdFO0FBQ0Esd0JBQXdCLFNBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUscUJBQXFCO0FBQ2pHLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsTUFBTTtBQUMxQiwrQ0FBK0MsVUFBVSxJQUFJO0FBQzdEO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRCxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDBDQUEwQyxRQUFRLFVBQVU7QUFDNUQ7QUFDQTtBQUNBLGdCQUFnQixxREFBcUQ7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGdCQUFnQjtBQUN0QyxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHdDQUF3QyxJQUFJLHNCQUFzQjtBQUNsRSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLG9DQUFvQyx1Q0FBdUM7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0EscURBQXFELE9BQU8sUUFBUTtBQUNwRTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRkFBMEY7QUFDMUY7QUFDQSwyQ0FBMkMsMkJBQTJCO0FBQ3RFO0FBQ0Esb0NBQW9DLGVBQWU7QUFDbkQseUJBQXlCO0FBQ3pCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLFVBQVU7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxzQkFBc0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxzQkFBc0I7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLGVBQWU7QUFDbEQ7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsV0FBVztBQUNyQyxhQUFhO0FBQ2I7QUFDQSwwQkFBMEIsV0FBVztBQUNyQyxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQix3RUFBd0U7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsNENBQTRDLFdBQVc7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix1QkFBdUI7QUFDOUMscUNBQXFDLHdCQUF3QjtBQUM3RCxpQkFBaUIsaUNBQWlDLGdCQUFnQixHQUFHO0FBQ3JFLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0IseUJBQXlCLHlDQUFZO0FBQ3JDLG9CQUFvQix5Q0FBWTtBQUNoQyx5Q0FBeUMsMkNBQWM7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2Qix5QkFBeUI7QUFDekIsNEJBQTRCO0FBQzVCLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsdUJBQXVCO0FBQ3pEO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTCxJQUFJLDRDQUFlO0FBQ25CLElBQUksNENBQWU7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUksNENBQWU7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFVBQVU7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSSw0Q0FBZTtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSSw0Q0FBZTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsdUJBQXVCO0FBQ2xFO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSSw0Q0FBZTtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFaUo7QUFDakoiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mb29kLy4vbm9kZV9tb2R1bGVzL3JlYWN0LWhvb2stZm9ybS9kaXN0L2luZGV4LmVzbS5tanM/ZjQ3MyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG52YXIgaXNDaGVja0JveElucHV0ID0gKGVsZW1lbnQpID0+IGVsZW1lbnQudHlwZSA9PT0gJ2NoZWNrYm94JztcblxudmFyIGlzRGF0ZU9iamVjdCA9ICh2YWx1ZSkgPT4gdmFsdWUgaW5zdGFuY2VvZiBEYXRlO1xuXG52YXIgaXNOdWxsT3JVbmRlZmluZWQgPSAodmFsdWUpID0+IHZhbHVlID09IG51bGw7XG5cbmNvbnN0IGlzT2JqZWN0VHlwZSA9ICh2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JztcbnZhciBpc09iamVjdCA9ICh2YWx1ZSkgPT4gIWlzTnVsbE9yVW5kZWZpbmVkKHZhbHVlKSAmJlxuICAgICFBcnJheS5pc0FycmF5KHZhbHVlKSAmJlxuICAgIGlzT2JqZWN0VHlwZSh2YWx1ZSkgJiZcbiAgICAhaXNEYXRlT2JqZWN0KHZhbHVlKTtcblxudmFyIGdldEV2ZW50VmFsdWUgPSAoZXZlbnQpID0+IGlzT2JqZWN0KGV2ZW50KSAmJiBldmVudC50YXJnZXRcbiAgICA/IGlzQ2hlY2tCb3hJbnB1dChldmVudC50YXJnZXQpXG4gICAgICAgID8gZXZlbnQudGFyZ2V0LmNoZWNrZWRcbiAgICAgICAgOiBldmVudC50YXJnZXQudmFsdWVcbiAgICA6IGV2ZW50O1xuXG52YXIgZ2V0Tm9kZVBhcmVudE5hbWUgPSAobmFtZSkgPT4gbmFtZS5zdWJzdHJpbmcoMCwgbmFtZS5zZWFyY2goL1xcLlxcZCsoXFwufCQpLykpIHx8IG5hbWU7XG5cbnZhciBpc05hbWVJbkZpZWxkQXJyYXkgPSAobmFtZXMsIG5hbWUpID0+IG5hbWVzLmhhcyhnZXROb2RlUGFyZW50TmFtZShuYW1lKSk7XG5cbnZhciBpc1BsYWluT2JqZWN0ID0gKHRlbXBPYmplY3QpID0+IHtcbiAgICBjb25zdCBwcm90b3R5cGVDb3B5ID0gdGVtcE9iamVjdC5jb25zdHJ1Y3RvciAmJiB0ZW1wT2JqZWN0LmNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgICByZXR1cm4gKGlzT2JqZWN0KHByb3RvdHlwZUNvcHkpICYmIHByb3RvdHlwZUNvcHkuaGFzT3duUHJvcGVydHkoJ2lzUHJvdG90eXBlT2YnKSk7XG59O1xuXG52YXIgaXNXZWIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiB3aW5kb3cuSFRNTEVsZW1lbnQgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJztcblxuZnVuY3Rpb24gY2xvbmVPYmplY3QoZGF0YSkge1xuICAgIGxldCBjb3B5O1xuICAgIGNvbnN0IGlzQXJyYXkgPSBBcnJheS5pc0FycmF5KGRhdGEpO1xuICAgIGlmIChkYXRhIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgICBjb3B5ID0gbmV3IERhdGUoZGF0YSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRhdGEgaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgY29weSA9IG5ldyBTZXQoZGF0YSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCEoaXNXZWIgJiYgKGRhdGEgaW5zdGFuY2VvZiBCbG9iIHx8IGRhdGEgaW5zdGFuY2VvZiBGaWxlTGlzdCkpICYmXG4gICAgICAgIChpc0FycmF5IHx8IGlzT2JqZWN0KGRhdGEpKSkge1xuICAgICAgICBjb3B5ID0gaXNBcnJheSA/IFtdIDoge307XG4gICAgICAgIGlmICghaXNBcnJheSAmJiAhaXNQbGFpbk9iamVjdChkYXRhKSkge1xuICAgICAgICAgICAgY29weSA9IGRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBkYXRhKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBjb3B5W2tleV0gPSBjbG9uZU9iamVjdChkYXRhW2tleV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIHJldHVybiBjb3B5O1xufVxuXG52YXIgY29tcGFjdCA9ICh2YWx1ZSkgPT4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZS5maWx0ZXIoQm9vbGVhbikgOiBbXTtcblxudmFyIGlzVW5kZWZpbmVkID0gKHZhbCkgPT4gdmFsID09PSB1bmRlZmluZWQ7XG5cbnZhciBnZXQgPSAob2JqZWN0LCBwYXRoLCBkZWZhdWx0VmFsdWUpID0+IHtcbiAgICBpZiAoIXBhdGggfHwgIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gY29tcGFjdChwYXRoLnNwbGl0KC9bLFtcXF0uXSs/LykpLnJlZHVjZSgocmVzdWx0LCBrZXkpID0+IGlzTnVsbE9yVW5kZWZpbmVkKHJlc3VsdCkgPyByZXN1bHQgOiByZXN1bHRba2V5XSwgb2JqZWN0KTtcbiAgICByZXR1cm4gaXNVbmRlZmluZWQocmVzdWx0KSB8fCByZXN1bHQgPT09IG9iamVjdFxuICAgICAgICA/IGlzVW5kZWZpbmVkKG9iamVjdFtwYXRoXSlcbiAgICAgICAgICAgID8gZGVmYXVsdFZhbHVlXG4gICAgICAgICAgICA6IG9iamVjdFtwYXRoXVxuICAgICAgICA6IHJlc3VsdDtcbn07XG5cbnZhciBpc0Jvb2xlYW4gPSAodmFsdWUpID0+IHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nO1xuXG52YXIgaXNLZXkgPSAodmFsdWUpID0+IC9eXFx3KiQvLnRlc3QodmFsdWUpO1xuXG52YXIgc3RyaW5nVG9QYXRoID0gKGlucHV0KSA9PiBjb21wYWN0KGlucHV0LnJlcGxhY2UoL1tcInwnXXxcXF0vZywgJycpLnNwbGl0KC9cXC58XFxbLykpO1xuXG52YXIgc2V0ID0gKG9iamVjdCwgcGF0aCwgdmFsdWUpID0+IHtcbiAgICBsZXQgaW5kZXggPSAtMTtcbiAgICBjb25zdCB0ZW1wUGF0aCA9IGlzS2V5KHBhdGgpID8gW3BhdGhdIDogc3RyaW5nVG9QYXRoKHBhdGgpO1xuICAgIGNvbnN0IGxlbmd0aCA9IHRlbXBQYXRoLmxlbmd0aDtcbiAgICBjb25zdCBsYXN0SW5kZXggPSBsZW5ndGggLSAxO1xuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IHRlbXBQYXRoW2luZGV4XTtcbiAgICAgICAgbGV0IG5ld1ZhbHVlID0gdmFsdWU7XG4gICAgICAgIGlmIChpbmRleCAhPT0gbGFzdEluZGV4KSB7XG4gICAgICAgICAgICBjb25zdCBvYmpWYWx1ZSA9IG9iamVjdFtrZXldO1xuICAgICAgICAgICAgbmV3VmFsdWUgPVxuICAgICAgICAgICAgICAgIGlzT2JqZWN0KG9ialZhbHVlKSB8fCBBcnJheS5pc0FycmF5KG9ialZhbHVlKVxuICAgICAgICAgICAgICAgICAgICA/IG9ialZhbHVlXG4gICAgICAgICAgICAgICAgICAgIDogIWlzTmFOKCt0ZW1wUGF0aFtpbmRleCArIDFdKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBbXVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB7fTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoa2V5ID09PSAnX19wcm90b19fJykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG9iamVjdFtrZXldID0gbmV3VmFsdWU7XG4gICAgICAgIG9iamVjdCA9IG9iamVjdFtrZXldO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xufTtcblxuY29uc3QgRVZFTlRTID0ge1xuICAgIEJMVVI6ICdibHVyJyxcbiAgICBGT0NVU19PVVQ6ICdmb2N1c291dCcsXG4gICAgQ0hBTkdFOiAnY2hhbmdlJyxcbn07XG5jb25zdCBWQUxJREFUSU9OX01PREUgPSB7XG4gICAgb25CbHVyOiAnb25CbHVyJyxcbiAgICBvbkNoYW5nZTogJ29uQ2hhbmdlJyxcbiAgICBvblN1Ym1pdDogJ29uU3VibWl0JyxcbiAgICBvblRvdWNoZWQ6ICdvblRvdWNoZWQnLFxuICAgIGFsbDogJ2FsbCcsXG59O1xuY29uc3QgSU5QVVRfVkFMSURBVElPTl9SVUxFUyA9IHtcbiAgICBtYXg6ICdtYXgnLFxuICAgIG1pbjogJ21pbicsXG4gICAgbWF4TGVuZ3RoOiAnbWF4TGVuZ3RoJyxcbiAgICBtaW5MZW5ndGg6ICdtaW5MZW5ndGgnLFxuICAgIHBhdHRlcm46ICdwYXR0ZXJuJyxcbiAgICByZXF1aXJlZDogJ3JlcXVpcmVkJyxcbiAgICB2YWxpZGF0ZTogJ3ZhbGlkYXRlJyxcbn07XG5cbmNvbnN0IEhvb2tGb3JtQ29udGV4dCA9IFJlYWN0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG4vKipcbiAqIFRoaXMgY3VzdG9tIGhvb2sgYWxsb3dzIHlvdSB0byBhY2Nlc3MgdGhlIGZvcm0gY29udGV4dC4gdXNlRm9ybUNvbnRleHQgaXMgaW50ZW5kZWQgdG8gYmUgdXNlZCBpbiBkZWVwbHkgbmVzdGVkIHN0cnVjdHVyZXMsIHdoZXJlIGl0IHdvdWxkIGJlY29tZSBpbmNvbnZlbmllbnQgdG8gcGFzcyB0aGUgY29udGV4dCBhcyBhIHByb3AuIFRvIGJlIHVzZWQgd2l0aCB7QGxpbmsgRm9ybVByb3ZpZGVyfS5cbiAqXG4gKiBAcmVtYXJrc1xuICogW0FQSV0oaHR0cHM6Ly9yZWFjdC1ob29rLWZvcm0uY29tL2RvY3MvdXNlZm9ybWNvbnRleHQpIOKAoiBbRGVtb10oaHR0cHM6Ly9jb2Rlc2FuZGJveC5pby9zL3JlYWN0LWhvb2stZm9ybS12Ny1mb3JtLWNvbnRleHQteXR1ZGkpXG4gKlxuICogQHJldHVybnMgcmV0dXJuIGFsbCB1c2VGb3JtIG1ldGhvZHNcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHN4XG4gKiBmdW5jdGlvbiBBcHAoKSB7XG4gKiAgIGNvbnN0IG1ldGhvZHMgPSB1c2VGb3JtKCk7XG4gKiAgIGNvbnN0IG9uU3VibWl0ID0gZGF0YSA9PiBjb25zb2xlLmxvZyhkYXRhKTtcbiAqXG4gKiAgIHJldHVybiAoXG4gKiAgICAgPEZvcm1Qcm92aWRlciB7Li4ubWV0aG9kc30gPlxuICogICAgICAgPGZvcm0gb25TdWJtaXQ9e21ldGhvZHMuaGFuZGxlU3VibWl0KG9uU3VibWl0KX0+XG4gKiAgICAgICAgIDxOZXN0ZWRJbnB1dCAvPlxuICogICAgICAgICA8aW5wdXQgdHlwZT1cInN1Ym1pdFwiIC8+XG4gKiAgICAgICA8L2Zvcm0+XG4gKiAgICAgPC9Gb3JtUHJvdmlkZXI+XG4gKiAgICk7XG4gKiB9XG4gKlxuICogIGZ1bmN0aW9uIE5lc3RlZElucHV0KCkge1xuICogICBjb25zdCB7IHJlZ2lzdGVyIH0gPSB1c2VGb3JtQ29udGV4dCgpOyAvLyByZXRyaWV2ZSBhbGwgaG9vayBtZXRob2RzXG4gKiAgIHJldHVybiA8aW5wdXQgey4uLnJlZ2lzdGVyKFwidGVzdFwiKX0gLz47XG4gKiB9XG4gKiBgYGBcbiAqL1xuY29uc3QgdXNlRm9ybUNvbnRleHQgPSAoKSA9PiBSZWFjdC51c2VDb250ZXh0KEhvb2tGb3JtQ29udGV4dCk7XG4vKipcbiAqIEEgcHJvdmlkZXIgY29tcG9uZW50IHRoYXQgcHJvcGFnYXRlcyB0aGUgYHVzZUZvcm1gIG1ldGhvZHMgdG8gYWxsIGNoaWxkcmVuIGNvbXBvbmVudHMgdmlhIFtSZWFjdCBDb250ZXh0XShodHRwczovL3JlYWN0anMub3JnL2RvY3MvY29udGV4dC5odG1sKSBBUEkuIFRvIGJlIHVzZWQgd2l0aCB7QGxpbmsgdXNlRm9ybUNvbnRleHR9LlxuICpcbiAqIEByZW1hcmtzXG4gKiBbQVBJXShodHRwczovL3JlYWN0LWhvb2stZm9ybS5jb20vZG9jcy91c2Vmb3JtY29udGV4dCkg4oCiIFtEZW1vXShodHRwczovL2NvZGVzYW5kYm94LmlvL3MvcmVhY3QtaG9vay1mb3JtLXY3LWZvcm0tY29udGV4dC15dHVkaSlcbiAqXG4gKiBAcGFyYW0gcHJvcHMgLSBhbGwgdXNlRm9ybSBtZXRob2RzXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzeFxuICogZnVuY3Rpb24gQXBwKCkge1xuICogICBjb25zdCBtZXRob2RzID0gdXNlRm9ybSgpO1xuICogICBjb25zdCBvblN1Ym1pdCA9IGRhdGEgPT4gY29uc29sZS5sb2coZGF0YSk7XG4gKlxuICogICByZXR1cm4gKFxuICogICAgIDxGb3JtUHJvdmlkZXIgey4uLm1ldGhvZHN9ID5cbiAqICAgICAgIDxmb3JtIG9uU3VibWl0PXttZXRob2RzLmhhbmRsZVN1Ym1pdChvblN1Ym1pdCl9PlxuICogICAgICAgICA8TmVzdGVkSW5wdXQgLz5cbiAqICAgICAgICAgPGlucHV0IHR5cGU9XCJzdWJtaXRcIiAvPlxuICogICAgICAgPC9mb3JtPlxuICogICAgIDwvRm9ybVByb3ZpZGVyPlxuICogICApO1xuICogfVxuICpcbiAqICBmdW5jdGlvbiBOZXN0ZWRJbnB1dCgpIHtcbiAqICAgY29uc3QgeyByZWdpc3RlciB9ID0gdXNlRm9ybUNvbnRleHQoKTsgLy8gcmV0cmlldmUgYWxsIGhvb2sgbWV0aG9kc1xuICogICByZXR1cm4gPGlucHV0IHsuLi5yZWdpc3RlcihcInRlc3RcIil9IC8+O1xuICogfVxuICogYGBgXG4gKi9cbmNvbnN0IEZvcm1Qcm92aWRlciA9IChwcm9wcykgPT4ge1xuICAgIGNvbnN0IHsgY2hpbGRyZW4sIC4uLmRhdGEgfSA9IHByb3BzO1xuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChIb29rRm9ybUNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IGRhdGEgfSwgY2hpbGRyZW4pKTtcbn07XG5cbnZhciBnZXRQcm94eUZvcm1TdGF0ZSA9IChmb3JtU3RhdGUsIGNvbnRyb2wsIGxvY2FsUHJveHlGb3JtU3RhdGUsIGlzUm9vdCA9IHRydWUpID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgIGRlZmF1bHRWYWx1ZXM6IGNvbnRyb2wuX2RlZmF1bHRWYWx1ZXMsXG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBmb3JtU3RhdGUpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlc3VsdCwga2V5LCB7XG4gICAgICAgICAgICBnZXQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBfa2V5ID0ga2V5O1xuICAgICAgICAgICAgICAgIGlmIChjb250cm9sLl9wcm94eUZvcm1TdGF0ZVtfa2V5XSAhPT0gVkFMSURBVElPTl9NT0RFLmFsbCkge1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sLl9wcm94eUZvcm1TdGF0ZVtfa2V5XSA9ICFpc1Jvb3QgfHwgVkFMSURBVElPTl9NT0RFLmFsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbG9jYWxQcm94eUZvcm1TdGF0ZSAmJiAobG9jYWxQcm94eUZvcm1TdGF0ZVtfa2V5XSA9IHRydWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmb3JtU3RhdGVbX2tleV07XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbnZhciBpc0VtcHR5T2JqZWN0ID0gKHZhbHVlKSA9PiBpc09iamVjdCh2YWx1ZSkgJiYgIU9iamVjdC5rZXlzKHZhbHVlKS5sZW5ndGg7XG5cbnZhciBzaG91bGRSZW5kZXJGb3JtU3RhdGUgPSAoZm9ybVN0YXRlRGF0YSwgX3Byb3h5Rm9ybVN0YXRlLCB1cGRhdGVGb3JtU3RhdGUsIGlzUm9vdCkgPT4ge1xuICAgIHVwZGF0ZUZvcm1TdGF0ZShmb3JtU3RhdGVEYXRhKTtcbiAgICBjb25zdCB7IG5hbWUsIC4uLmZvcm1TdGF0ZSB9ID0gZm9ybVN0YXRlRGF0YTtcbiAgICByZXR1cm4gKGlzRW1wdHlPYmplY3QoZm9ybVN0YXRlKSB8fFxuICAgICAgICBPYmplY3Qua2V5cyhmb3JtU3RhdGUpLmxlbmd0aCA+PSBPYmplY3Qua2V5cyhfcHJveHlGb3JtU3RhdGUpLmxlbmd0aCB8fFxuICAgICAgICBPYmplY3Qua2V5cyhmb3JtU3RhdGUpLmZpbmQoKGtleSkgPT4gX3Byb3h5Rm9ybVN0YXRlW2tleV0gPT09XG4gICAgICAgICAgICAoIWlzUm9vdCB8fCBWQUxJREFUSU9OX01PREUuYWxsKSkpO1xufTtcblxudmFyIGNvbnZlcnRUb0FycmF5UGF5bG9hZCA9ICh2YWx1ZSkgPT4gKEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbdmFsdWVdKTtcblxudmFyIHNob3VsZFN1YnNjcmliZUJ5TmFtZSA9IChuYW1lLCBzaWduYWxOYW1lLCBleGFjdCkgPT4gIW5hbWUgfHxcbiAgICAhc2lnbmFsTmFtZSB8fFxuICAgIG5hbWUgPT09IHNpZ25hbE5hbWUgfHxcbiAgICBjb252ZXJ0VG9BcnJheVBheWxvYWQobmFtZSkuc29tZSgoY3VycmVudE5hbWUpID0+IGN1cnJlbnROYW1lICYmXG4gICAgICAgIChleGFjdFxuICAgICAgICAgICAgPyBjdXJyZW50TmFtZSA9PT0gc2lnbmFsTmFtZVxuICAgICAgICAgICAgOiBjdXJyZW50TmFtZS5zdGFydHNXaXRoKHNpZ25hbE5hbWUpIHx8XG4gICAgICAgICAgICAgICAgc2lnbmFsTmFtZS5zdGFydHNXaXRoKGN1cnJlbnROYW1lKSkpO1xuXG5mdW5jdGlvbiB1c2VTdWJzY3JpYmUocHJvcHMpIHtcbiAgICBjb25zdCBfcHJvcHMgPSBSZWFjdC51c2VSZWYocHJvcHMpO1xuICAgIF9wcm9wcy5jdXJyZW50ID0gcHJvcHM7XG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9uID0gIXByb3BzLmRpc2FibGVkICYmXG4gICAgICAgICAgICBfcHJvcHMuY3VycmVudC5zdWJqZWN0ICYmXG4gICAgICAgICAgICBfcHJvcHMuY3VycmVudC5zdWJqZWN0LnN1YnNjcmliZSh7XG4gICAgICAgICAgICAgICAgbmV4dDogX3Byb3BzLmN1cnJlbnQubmV4dCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgc3Vic2NyaXB0aW9uICYmIHN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9O1xuICAgIH0sIFtwcm9wcy5kaXNhYmxlZF0pO1xufVxuXG4vKipcbiAqIFRoaXMgY3VzdG9tIGhvb2sgYWxsb3dzIHlvdSB0byBzdWJzY3JpYmUgdG8gZWFjaCBmb3JtIHN0YXRlLCBhbmQgaXNvbGF0ZSB0aGUgcmUtcmVuZGVyIGF0IHRoZSBjdXN0b20gaG9vayBsZXZlbC4gSXQgaGFzIGl0cyBzY29wZSBpbiB0ZXJtcyBvZiBmb3JtIHN0YXRlIHN1YnNjcmlwdGlvbiwgc28gaXQgd291bGQgbm90IGFmZmVjdCBvdGhlciB1c2VGb3JtU3RhdGUgYW5kIHVzZUZvcm0uIFVzaW5nIHRoaXMgaG9vayBjYW4gcmVkdWNlIHRoZSByZS1yZW5kZXIgaW1wYWN0IG9uIGxhcmdlIGFuZCBjb21wbGV4IGZvcm0gYXBwbGljYXRpb24uXG4gKlxuICogQHJlbWFya3NcbiAqIFtBUEldKGh0dHBzOi8vcmVhY3QtaG9vay1mb3JtLmNvbS9kb2NzL3VzZWZvcm1zdGF0ZSkg4oCiIFtEZW1vXShodHRwczovL2NvZGVzYW5kYm94LmlvL3MvdXNlZm9ybXN0YXRlLTc1eGx5KVxuICpcbiAqIEBwYXJhbSBwcm9wcyAtIGluY2x1ZGUgb3B0aW9ucyBvbiBzcGVjaWZ5IGZpZWxkcyB0byBzdWJzY3JpYmUuIHtAbGluayBVc2VGb3JtU3RhdGVSZXR1cm59XG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzeFxuICogZnVuY3Rpb24gQXBwKCkge1xuICogICBjb25zdCB7IHJlZ2lzdGVyLCBoYW5kbGVTdWJtaXQsIGNvbnRyb2wgfSA9IHVzZUZvcm0oe1xuICogICAgIGRlZmF1bHRWYWx1ZXM6IHtcbiAqICAgICBmaXJzdE5hbWU6IFwiZmlyc3ROYW1lXCJcbiAqICAgfX0pO1xuICogICBjb25zdCB7IGRpcnR5RmllbGRzIH0gPSB1c2VGb3JtU3RhdGUoe1xuICogICAgIGNvbnRyb2xcbiAqICAgfSk7XG4gKiAgIGNvbnN0IG9uU3VibWl0ID0gKGRhdGEpID0+IGNvbnNvbGUubG9nKGRhdGEpO1xuICpcbiAqICAgcmV0dXJuIChcbiAqICAgICA8Zm9ybSBvblN1Ym1pdD17aGFuZGxlU3VibWl0KG9uU3VibWl0KX0+XG4gKiAgICAgICA8aW5wdXQgey4uLnJlZ2lzdGVyKFwiZmlyc3ROYW1lXCIpfSBwbGFjZWhvbGRlcj1cIkZpcnN0IE5hbWVcIiAvPlxuICogICAgICAge2RpcnR5RmllbGRzLmZpcnN0TmFtZSAmJiA8cD5GaWVsZCBpcyBkaXJ0eS48L3A+fVxuICogICAgICAgPGlucHV0IHR5cGU9XCJzdWJtaXRcIiAvPlxuICogICAgIDwvZm9ybT5cbiAqICAgKTtcbiAqIH1cbiAqIGBgYFxuICovXG5mdW5jdGlvbiB1c2VGb3JtU3RhdGUocHJvcHMpIHtcbiAgICBjb25zdCBtZXRob2RzID0gdXNlRm9ybUNvbnRleHQoKTtcbiAgICBjb25zdCB7IGNvbnRyb2wgPSBtZXRob2RzLmNvbnRyb2wsIGRpc2FibGVkLCBuYW1lLCBleGFjdCB9ID0gcHJvcHMgfHwge307XG4gICAgY29uc3QgW2Zvcm1TdGF0ZSwgdXBkYXRlRm9ybVN0YXRlXSA9IFJlYWN0LnVzZVN0YXRlKGNvbnRyb2wuX2Zvcm1TdGF0ZSk7XG4gICAgY29uc3QgX21vdW50ZWQgPSBSZWFjdC51c2VSZWYodHJ1ZSk7XG4gICAgY29uc3QgX2xvY2FsUHJveHlGb3JtU3RhdGUgPSBSZWFjdC51c2VSZWYoe1xuICAgICAgICBpc0RpcnR5OiBmYWxzZSxcbiAgICAgICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgZGlydHlGaWVsZHM6IGZhbHNlLFxuICAgICAgICB0b3VjaGVkRmllbGRzOiBmYWxzZSxcbiAgICAgICAgdmFsaWRhdGluZ0ZpZWxkczogZmFsc2UsXG4gICAgICAgIGlzVmFsaWRhdGluZzogZmFsc2UsXG4gICAgICAgIGlzVmFsaWQ6IGZhbHNlLFxuICAgICAgICBlcnJvcnM6IGZhbHNlLFxuICAgIH0pO1xuICAgIGNvbnN0IF9uYW1lID0gUmVhY3QudXNlUmVmKG5hbWUpO1xuICAgIF9uYW1lLmN1cnJlbnQgPSBuYW1lO1xuICAgIHVzZVN1YnNjcmliZSh7XG4gICAgICAgIGRpc2FibGVkLFxuICAgICAgICBuZXh0OiAodmFsdWUpID0+IF9tb3VudGVkLmN1cnJlbnQgJiZcbiAgICAgICAgICAgIHNob3VsZFN1YnNjcmliZUJ5TmFtZShfbmFtZS5jdXJyZW50LCB2YWx1ZS5uYW1lLCBleGFjdCkgJiZcbiAgICAgICAgICAgIHNob3VsZFJlbmRlckZvcm1TdGF0ZSh2YWx1ZSwgX2xvY2FsUHJveHlGb3JtU3RhdGUuY3VycmVudCwgY29udHJvbC5fdXBkYXRlRm9ybVN0YXRlKSAmJlxuICAgICAgICAgICAgdXBkYXRlRm9ybVN0YXRlKHtcbiAgICAgICAgICAgICAgICAuLi5jb250cm9sLl9mb3JtU3RhdGUsXG4gICAgICAgICAgICAgICAgLi4udmFsdWUsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgc3ViamVjdDogY29udHJvbC5fc3ViamVjdHMuc3RhdGUsXG4gICAgfSk7XG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgX21vdW50ZWQuY3VycmVudCA9IHRydWU7XG4gICAgICAgIF9sb2NhbFByb3h5Rm9ybVN0YXRlLmN1cnJlbnQuaXNWYWxpZCAmJiBjb250cm9sLl91cGRhdGVWYWxpZCh0cnVlKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIF9tb3VudGVkLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgfTtcbiAgICB9LCBbY29udHJvbF0pO1xuICAgIHJldHVybiBnZXRQcm94eUZvcm1TdGF0ZShmb3JtU3RhdGUsIGNvbnRyb2wsIF9sb2NhbFByb3h5Rm9ybVN0YXRlLmN1cnJlbnQsIGZhbHNlKTtcbn1cblxudmFyIGlzU3RyaW5nID0gKHZhbHVlKSA9PiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnO1xuXG52YXIgZ2VuZXJhdGVXYXRjaE91dHB1dCA9IChuYW1lcywgX25hbWVzLCBmb3JtVmFsdWVzLCBpc0dsb2JhbCwgZGVmYXVsdFZhbHVlKSA9PiB7XG4gICAgaWYgKGlzU3RyaW5nKG5hbWVzKSkge1xuICAgICAgICBpc0dsb2JhbCAmJiBfbmFtZXMud2F0Y2guYWRkKG5hbWVzKTtcbiAgICAgICAgcmV0dXJuIGdldChmb3JtVmFsdWVzLCBuYW1lcywgZGVmYXVsdFZhbHVlKTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobmFtZXMpKSB7XG4gICAgICAgIHJldHVybiBuYW1lcy5tYXAoKGZpZWxkTmFtZSkgPT4gKGlzR2xvYmFsICYmIF9uYW1lcy53YXRjaC5hZGQoZmllbGROYW1lKSwgZ2V0KGZvcm1WYWx1ZXMsIGZpZWxkTmFtZSkpKTtcbiAgICB9XG4gICAgaXNHbG9iYWwgJiYgKF9uYW1lcy53YXRjaEFsbCA9IHRydWUpO1xuICAgIHJldHVybiBmb3JtVmFsdWVzO1xufTtcblxuLyoqXG4gKiBDdXN0b20gaG9vayB0byBzdWJzY3JpYmUgdG8gZmllbGQgY2hhbmdlIGFuZCBpc29sYXRlIHJlLXJlbmRlcmluZyBhdCB0aGUgY29tcG9uZW50IGxldmVsLlxuICpcbiAqIEByZW1hcmtzXG4gKlxuICogW0FQSV0oaHR0cHM6Ly9yZWFjdC1ob29rLWZvcm0uY29tL2RvY3MvdXNld2F0Y2gpIOKAoiBbRGVtb10oaHR0cHM6Ly9jb2Rlc2FuZGJveC5pby9zL3JlYWN0LWhvb2stZm9ybS12Ny10cy11c2V3YXRjaC1oOWk1ZSlcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHN4XG4gKiBjb25zdCB7IGNvbnRyb2wgfSA9IHVzZUZvcm0oKTtcbiAqIGNvbnN0IHZhbHVlcyA9IHVzZVdhdGNoKHtcbiAqICAgbmFtZTogXCJmaWVsZE5hbWVcIlxuICogICBjb250cm9sLFxuICogfSlcbiAqIGBgYFxuICovXG5mdW5jdGlvbiB1c2VXYXRjaChwcm9wcykge1xuICAgIGNvbnN0IG1ldGhvZHMgPSB1c2VGb3JtQ29udGV4dCgpO1xuICAgIGNvbnN0IHsgY29udHJvbCA9IG1ldGhvZHMuY29udHJvbCwgbmFtZSwgZGVmYXVsdFZhbHVlLCBkaXNhYmxlZCwgZXhhY3QsIH0gPSBwcm9wcyB8fCB7fTtcbiAgICBjb25zdCBfbmFtZSA9IFJlYWN0LnVzZVJlZihuYW1lKTtcbiAgICBfbmFtZS5jdXJyZW50ID0gbmFtZTtcbiAgICB1c2VTdWJzY3JpYmUoe1xuICAgICAgICBkaXNhYmxlZCxcbiAgICAgICAgc3ViamVjdDogY29udHJvbC5fc3ViamVjdHMudmFsdWVzLFxuICAgICAgICBuZXh0OiAoZm9ybVN0YXRlKSA9PiB7XG4gICAgICAgICAgICBpZiAoc2hvdWxkU3Vic2NyaWJlQnlOYW1lKF9uYW1lLmN1cnJlbnQsIGZvcm1TdGF0ZS5uYW1lLCBleGFjdCkpIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVWYWx1ZShjbG9uZU9iamVjdChnZW5lcmF0ZVdhdGNoT3V0cHV0KF9uYW1lLmN1cnJlbnQsIGNvbnRyb2wuX25hbWVzLCBmb3JtU3RhdGUudmFsdWVzIHx8IGNvbnRyb2wuX2Zvcm1WYWx1ZXMsIGZhbHNlLCBkZWZhdWx0VmFsdWUpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfSk7XG4gICAgY29uc3QgW3ZhbHVlLCB1cGRhdGVWYWx1ZV0gPSBSZWFjdC51c2VTdGF0ZShjb250cm9sLl9nZXRXYXRjaChuYW1lLCBkZWZhdWx0VmFsdWUpKTtcbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4gY29udHJvbC5fcmVtb3ZlVW5tb3VudGVkKCkpO1xuICAgIHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBDdXN0b20gaG9vayB0byB3b3JrIHdpdGggY29udHJvbGxlZCBjb21wb25lbnQsIHRoaXMgZnVuY3Rpb24gcHJvdmlkZSB5b3Ugd2l0aCBib3RoIGZvcm0gYW5kIGZpZWxkIGxldmVsIHN0YXRlLiBSZS1yZW5kZXIgaXMgaXNvbGF0ZWQgYXQgdGhlIGhvb2sgbGV2ZWwuXG4gKlxuICogQHJlbWFya3NcbiAqIFtBUEldKGh0dHBzOi8vcmVhY3QtaG9vay1mb3JtLmNvbS9kb2NzL3VzZWNvbnRyb2xsZXIpIOKAoiBbRGVtb10oaHR0cHM6Ly9jb2Rlc2FuZGJveC5pby9zL3VzZWNvbnRyb2xsZXItMG84cHgpXG4gKlxuICogQHBhcmFtIHByb3BzIC0gdGhlIHBhdGggbmFtZSB0byB0aGUgZm9ybSBmaWVsZCB2YWx1ZSwgYW5kIHZhbGlkYXRpb24gcnVsZXMuXG4gKlxuICogQHJldHVybnMgZmllbGQgcHJvcGVydGllcywgZmllbGQgYW5kIGZvcm0gc3RhdGUuIHtAbGluayBVc2VDb250cm9sbGVyUmV0dXJufVxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c3hcbiAqIGZ1bmN0aW9uIElucHV0KHByb3BzKSB7XG4gKiAgIGNvbnN0IHsgZmllbGQsIGZpZWxkU3RhdGUsIGZvcm1TdGF0ZSB9ID0gdXNlQ29udHJvbGxlcihwcm9wcyk7XG4gKiAgIHJldHVybiAoXG4gKiAgICAgPGRpdj5cbiAqICAgICAgIDxpbnB1dCB7Li4uZmllbGR9IHBsYWNlaG9sZGVyPXtwcm9wcy5uYW1lfSAvPlxuICogICAgICAgPHA+e2ZpZWxkU3RhdGUuaXNUb3VjaGVkICYmIFwiVG91Y2hlZFwifTwvcD5cbiAqICAgICAgIDxwPntmb3JtU3RhdGUuaXNTdWJtaXR0ZWQgPyBcInN1Ym1pdHRlZFwiIDogXCJcIn08L3A+XG4gKiAgICAgPC9kaXY+XG4gKiAgICk7XG4gKiB9XG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gdXNlQ29udHJvbGxlcihwcm9wcykge1xuICAgIGNvbnN0IG1ldGhvZHMgPSB1c2VGb3JtQ29udGV4dCgpO1xuICAgIGNvbnN0IHsgbmFtZSwgZGlzYWJsZWQsIGNvbnRyb2wgPSBtZXRob2RzLmNvbnRyb2wsIHNob3VsZFVucmVnaXN0ZXIgfSA9IHByb3BzO1xuICAgIGNvbnN0IGlzQXJyYXlGaWVsZCA9IGlzTmFtZUluRmllbGRBcnJheShjb250cm9sLl9uYW1lcy5hcnJheSwgbmFtZSk7XG4gICAgY29uc3QgdmFsdWUgPSB1c2VXYXRjaCh7XG4gICAgICAgIGNvbnRyb2wsXG4gICAgICAgIG5hbWUsXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogZ2V0KGNvbnRyb2wuX2Zvcm1WYWx1ZXMsIG5hbWUsIGdldChjb250cm9sLl9kZWZhdWx0VmFsdWVzLCBuYW1lLCBwcm9wcy5kZWZhdWx0VmFsdWUpKSxcbiAgICAgICAgZXhhY3Q6IHRydWUsXG4gICAgfSk7XG4gICAgY29uc3QgZm9ybVN0YXRlID0gdXNlRm9ybVN0YXRlKHtcbiAgICAgICAgY29udHJvbCxcbiAgICAgICAgbmFtZSxcbiAgICAgICAgZXhhY3Q6IHRydWUsXG4gICAgfSk7XG4gICAgY29uc3QgX3JlZ2lzdGVyUHJvcHMgPSBSZWFjdC51c2VSZWYoY29udHJvbC5yZWdpc3RlcihuYW1lLCB7XG4gICAgICAgIC4uLnByb3BzLnJ1bGVzLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgLi4uKGlzQm9vbGVhbihwcm9wcy5kaXNhYmxlZCkgPyB7IGRpc2FibGVkOiBwcm9wcy5kaXNhYmxlZCB9IDoge30pLFxuICAgIH0pKTtcbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb25zdCBfc2hvdWxkVW5yZWdpc3RlckZpZWxkID0gY29udHJvbC5fb3B0aW9ucy5zaG91bGRVbnJlZ2lzdGVyIHx8IHNob3VsZFVucmVnaXN0ZXI7XG4gICAgICAgIGNvbnN0IHVwZGF0ZU1vdW50ZWQgPSAobmFtZSwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkID0gZ2V0KGNvbnRyb2wuX2ZpZWxkcywgbmFtZSk7XG4gICAgICAgICAgICBpZiAoZmllbGQgJiYgZmllbGQuX2YpIHtcbiAgICAgICAgICAgICAgICBmaWVsZC5fZi5tb3VudCA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB1cGRhdGVNb3VudGVkKG5hbWUsIHRydWUpO1xuICAgICAgICBpZiAoX3Nob3VsZFVucmVnaXN0ZXJGaWVsZCkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBjbG9uZU9iamVjdChnZXQoY29udHJvbC5fb3B0aW9ucy5kZWZhdWx0VmFsdWVzLCBuYW1lKSk7XG4gICAgICAgICAgICBzZXQoY29udHJvbC5fZGVmYXVsdFZhbHVlcywgbmFtZSwgdmFsdWUpO1xuICAgICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKGdldChjb250cm9sLl9mb3JtVmFsdWVzLCBuYW1lKSkpIHtcbiAgICAgICAgICAgICAgICBzZXQoY29udHJvbC5fZm9ybVZhbHVlcywgbmFtZSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAoaXNBcnJheUZpZWxkXG4gICAgICAgICAgICAgICAgPyBfc2hvdWxkVW5yZWdpc3RlckZpZWxkICYmICFjb250cm9sLl9zdGF0ZS5hY3Rpb25cbiAgICAgICAgICAgICAgICA6IF9zaG91bGRVbnJlZ2lzdGVyRmllbGQpXG4gICAgICAgICAgICAgICAgPyBjb250cm9sLnVucmVnaXN0ZXIobmFtZSlcbiAgICAgICAgICAgICAgICA6IHVwZGF0ZU1vdW50ZWQobmFtZSwgZmFsc2UpO1xuICAgICAgICB9O1xuICAgIH0sIFtuYW1lLCBjb250cm9sLCBpc0FycmF5RmllbGQsIHNob3VsZFVucmVnaXN0ZXJdKTtcbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoZ2V0KGNvbnRyb2wuX2ZpZWxkcywgbmFtZSkpIHtcbiAgICAgICAgICAgIGNvbnRyb2wuX3VwZGF0ZURpc2FibGVkRmllbGQoe1xuICAgICAgICAgICAgICAgIGRpc2FibGVkLFxuICAgICAgICAgICAgICAgIGZpZWxkczogY29udHJvbC5fZmllbGRzLFxuICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGdldChjb250cm9sLl9maWVsZHMsIG5hbWUpLl9mLnZhbHVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LCBbZGlzYWJsZWQsIG5hbWUsIGNvbnRyb2xdKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBmaWVsZDoge1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgLi4uKGlzQm9vbGVhbihkaXNhYmxlZCkgfHwgZm9ybVN0YXRlLmRpc2FibGVkXG4gICAgICAgICAgICAgICAgPyB7IGRpc2FibGVkOiBmb3JtU3RhdGUuZGlzYWJsZWQgfHwgZGlzYWJsZWQgfVxuICAgICAgICAgICAgICAgIDoge30pLFxuICAgICAgICAgICAgb25DaGFuZ2U6IFJlYWN0LnVzZUNhbGxiYWNrKChldmVudCkgPT4gX3JlZ2lzdGVyUHJvcHMuY3VycmVudC5vbkNoYW5nZSh7XG4gICAgICAgICAgICAgICAgdGFyZ2V0OiB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBnZXRFdmVudFZhbHVlKGV2ZW50KSxcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHR5cGU6IEVWRU5UUy5DSEFOR0UsXG4gICAgICAgICAgICB9KSwgW25hbWVdKSxcbiAgICAgICAgICAgIG9uQmx1cjogUmVhY3QudXNlQ2FsbGJhY2soKCkgPT4gX3JlZ2lzdGVyUHJvcHMuY3VycmVudC5vbkJsdXIoe1xuICAgICAgICAgICAgICAgIHRhcmdldDoge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZ2V0KGNvbnRyb2wuX2Zvcm1WYWx1ZXMsIG5hbWUpLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgdHlwZTogRVZFTlRTLkJMVVIsXG4gICAgICAgICAgICB9KSwgW25hbWUsIGNvbnRyb2xdKSxcbiAgICAgICAgICAgIHJlZjogUmVhY3QudXNlQ2FsbGJhY2soKGVsbSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkID0gZ2V0KGNvbnRyb2wuX2ZpZWxkcywgbmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkICYmIGVsbSkge1xuICAgICAgICAgICAgICAgICAgICBmaWVsZC5fZi5yZWYgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb2N1czogKCkgPT4gZWxtLmZvY3VzKCksXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxlY3Q6ICgpID0+IGVsbS5zZWxlY3QoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldEN1c3RvbVZhbGlkaXR5OiAobWVzc2FnZSkgPT4gZWxtLnNldEN1c3RvbVZhbGlkaXR5KG1lc3NhZ2UpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVwb3J0VmFsaWRpdHk6ICgpID0+IGVsbS5yZXBvcnRWYWxpZGl0eSgpLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIFtjb250cm9sLl9maWVsZHMsIG5hbWVdKSxcbiAgICAgICAgfSxcbiAgICAgICAgZm9ybVN0YXRlLFxuICAgICAgICBmaWVsZFN0YXRlOiBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh7fSwge1xuICAgICAgICAgICAgaW52YWxpZDoge1xuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiAoKSA9PiAhIWdldChmb3JtU3RhdGUuZXJyb3JzLCBuYW1lKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpc0RpcnR5OiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6ICgpID0+ICEhZ2V0KGZvcm1TdGF0ZS5kaXJ0eUZpZWxkcywgbmFtZSksXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXNUb3VjaGVkOiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6ICgpID0+ICEhZ2V0KGZvcm1TdGF0ZS50b3VjaGVkRmllbGRzLCBuYW1lKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBpc1ZhbGlkYXRpbmc6IHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogKCkgPT4gISFnZXQoZm9ybVN0YXRlLnZhbGlkYXRpbmdGaWVsZHMsIG5hbWUpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVycm9yOiB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6ICgpID0+IGdldChmb3JtU3RhdGUuZXJyb3JzLCBuYW1lKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pLFxuICAgIH07XG59XG5cbi8qKlxuICogQ29tcG9uZW50IGJhc2VkIG9uIGB1c2VDb250cm9sbGVyYCBob29rIHRvIHdvcmsgd2l0aCBjb250cm9sbGVkIGNvbXBvbmVudC5cbiAqXG4gKiBAcmVtYXJrc1xuICogW0FQSV0oaHR0cHM6Ly9yZWFjdC1ob29rLWZvcm0uY29tL2RvY3MvdXNlY29udHJvbGxlci9jb250cm9sbGVyKSDigKIgW0RlbW9dKGh0dHBzOi8vY29kZXNhbmRib3guaW8vcy9yZWFjdC1ob29rLWZvcm0tdjYtY29udHJvbGxlci10cy1qd3l6dykg4oCiIFtWaWRlb10oaHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1OMlVOa19VQ1Z5QSlcbiAqXG4gKiBAcGFyYW0gcHJvcHMgLSB0aGUgcGF0aCBuYW1lIHRvIHRoZSBmb3JtIGZpZWxkIHZhbHVlLCBhbmQgdmFsaWRhdGlvbiBydWxlcy5cbiAqXG4gKiBAcmV0dXJucyBwcm92aWRlIGZpZWxkIGhhbmRsZXIgZnVuY3Rpb25zLCBmaWVsZCBhbmQgZm9ybSBzdGF0ZS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHN4XG4gKiBmdW5jdGlvbiBBcHAoKSB7XG4gKiAgIGNvbnN0IHsgY29udHJvbCB9ID0gdXNlRm9ybTxGb3JtVmFsdWVzPih7XG4gKiAgICAgZGVmYXVsdFZhbHVlczoge1xuICogICAgICAgdGVzdDogXCJcIlxuICogICAgIH1cbiAqICAgfSk7XG4gKlxuICogICByZXR1cm4gKFxuICogICAgIDxmb3JtPlxuICogICAgICAgPENvbnRyb2xsZXJcbiAqICAgICAgICAgY29udHJvbD17Y29udHJvbH1cbiAqICAgICAgICAgbmFtZT1cInRlc3RcIlxuICogICAgICAgICByZW5kZXI9eyh7IGZpZWxkOiB7IG9uQ2hhbmdlLCBvbkJsdXIsIHZhbHVlLCByZWYgfSwgZm9ybVN0YXRlLCBmaWVsZFN0YXRlIH0pID0+IChcbiAqICAgICAgICAgICA8PlxuICogICAgICAgICAgICAgPGlucHV0XG4gKiAgICAgICAgICAgICAgIG9uQ2hhbmdlPXtvbkNoYW5nZX0gLy8gc2VuZCB2YWx1ZSB0byBob29rIGZvcm1cbiAqICAgICAgICAgICAgICAgb25CbHVyPXtvbkJsdXJ9IC8vIG5vdGlmeSB3aGVuIGlucHV0IGlzIHRvdWNoZWRcbiAqICAgICAgICAgICAgICAgdmFsdWU9e3ZhbHVlfSAvLyByZXR1cm4gdXBkYXRlZCB2YWx1ZVxuICogICAgICAgICAgICAgICByZWY9e3JlZn0gLy8gc2V0IHJlZiBmb3IgZm9jdXMgbWFuYWdlbWVudFxuICogICAgICAgICAgICAgLz5cbiAqICAgICAgICAgICAgIDxwPntmb3JtU3RhdGUuaXNTdWJtaXR0ZWQgPyBcInN1Ym1pdHRlZFwiIDogXCJcIn08L3A+XG4gKiAgICAgICAgICAgICA8cD57ZmllbGRTdGF0ZS5pc1RvdWNoZWQgPyBcInRvdWNoZWRcIiA6IFwiXCJ9PC9wPlxuICogICAgICAgICAgIDwvPlxuICogICAgICAgICApfVxuICogICAgICAgLz5cbiAqICAgICA8L2Zvcm0+XG4gKiAgICk7XG4gKiB9XG4gKiBgYGBcbiAqL1xuY29uc3QgQ29udHJvbGxlciA9IChwcm9wcykgPT4gcHJvcHMucmVuZGVyKHVzZUNvbnRyb2xsZXIocHJvcHMpKTtcblxuY29uc3QgZmxhdHRlbiA9IChvYmopID0+IHtcbiAgICBjb25zdCBvdXRwdXQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhvYmopKSB7XG4gICAgICAgIGlmIChpc09iamVjdFR5cGUob2JqW2tleV0pKSB7XG4gICAgICAgICAgICBjb25zdCBuZXN0ZWQgPSBmbGF0dGVuKG9ialtrZXldKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbmVzdGVkS2V5IG9mIE9iamVjdC5rZXlzKG5lc3RlZCkpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRbYCR7a2V5fS4ke25lc3RlZEtleX1gXSA9IG5lc3RlZFtuZXN0ZWRLZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3V0cHV0W2tleV0gPSBvYmpba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xufTtcblxuY29uc3QgUE9TVF9SRVFVRVNUID0gJ3Bvc3QnO1xuLyoqXG4gKiBGb3JtIGNvbXBvbmVudCB0byBtYW5hZ2Ugc3VibWlzc2lvbi5cbiAqXG4gKiBAcGFyYW0gcHJvcHMgLSB0byBzZXR1cCBzdWJtaXNzaW9uIGRldGFpbC4ge0BsaW5rIEZvcm1Qcm9wc31cbiAqXG4gKiBAcmV0dXJucyBmb3JtIGNvbXBvbmVudCBvciBoZWFkbGVzcyByZW5kZXIgcHJvcC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHN4XG4gKiBmdW5jdGlvbiBBcHAoKSB7XG4gKiAgIGNvbnN0IHsgY29udHJvbCwgZm9ybVN0YXRlOiB7IGVycm9ycyB9IH0gPSB1c2VGb3JtKCk7XG4gKlxuICogICByZXR1cm4gKFxuICogICAgIDxGb3JtIGFjdGlvbj1cIi9hcGlcIiBjb250cm9sPXtjb250cm9sfT5cbiAqICAgICAgIDxpbnB1dCB7Li4ucmVnaXN0ZXIoXCJuYW1lXCIpfSAvPlxuICogICAgICAgPHA+e2Vycm9ycz8ucm9vdD8uc2VydmVyICYmICdTZXJ2ZXIgZXJyb3InfTwvcD5cbiAqICAgICAgIDxidXR0b24+U3VibWl0PC9idXR0b24+XG4gKiAgICAgPC9Gb3JtPlxuICogICApO1xuICogfVxuICogYGBgXG4gKi9cbmZ1bmN0aW9uIEZvcm0ocHJvcHMpIHtcbiAgICBjb25zdCBtZXRob2RzID0gdXNlRm9ybUNvbnRleHQoKTtcbiAgICBjb25zdCBbbW91bnRlZCwgc2V0TW91bnRlZF0gPSBSZWFjdC51c2VTdGF0ZShmYWxzZSk7XG4gICAgY29uc3QgeyBjb250cm9sID0gbWV0aG9kcy5jb250cm9sLCBvblN1Ym1pdCwgY2hpbGRyZW4sIGFjdGlvbiwgbWV0aG9kID0gUE9TVF9SRVFVRVNULCBoZWFkZXJzLCBlbmNUeXBlLCBvbkVycm9yLCByZW5kZXIsIG9uU3VjY2VzcywgdmFsaWRhdGVTdGF0dXMsIC4uLnJlc3QgfSA9IHByb3BzO1xuICAgIGNvbnN0IHN1Ym1pdCA9IGFzeW5jIChldmVudCkgPT4ge1xuICAgICAgICBsZXQgaGFzRXJyb3IgPSBmYWxzZTtcbiAgICAgICAgbGV0IHR5cGUgPSAnJztcbiAgICAgICAgYXdhaXQgY29udHJvbC5oYW5kbGVTdWJtaXQoYXN5bmMgKGRhdGEpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XG4gICAgICAgICAgICBsZXQgZm9ybURhdGFKc29uID0gJyc7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvcm1EYXRhSnNvbiA9IEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKF9hKSB7IH1cbiAgICAgICAgICAgIGNvbnN0IGZsYXR0ZW5Gb3JtVmFsdWVzID0gZmxhdHRlbihjb250cm9sLl9mb3JtVmFsdWVzKTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGZsYXR0ZW5Gb3JtVmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgZm9ybURhdGEuYXBwZW5kKGtleSwgZmxhdHRlbkZvcm1WYWx1ZXNba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAob25TdWJtaXQpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBvblN1Ym1pdCh7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LFxuICAgICAgICAgICAgICAgICAgICBtZXRob2QsXG4gICAgICAgICAgICAgICAgICAgIGZvcm1EYXRhLFxuICAgICAgICAgICAgICAgICAgICBmb3JtRGF0YUpzb24sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2hvdWxkU3RyaW5naWZ5U3VibWlzc2lvbkRhdGEgPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzICYmIGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddLFxuICAgICAgICAgICAgICAgICAgICAgICAgZW5jVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgXS5zb21lKCh2YWx1ZSkgPT4gdmFsdWUgJiYgdmFsdWUuaW5jbHVkZXMoJ2pzb24nKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYWN0aW9uLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2QsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi4oZW5jVHlwZSA/IHsgJ0NvbnRlbnQtVHlwZSc6IGVuY1R5cGUgfSA6IHt9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBzaG91bGRTdHJpbmdpZnlTdWJtaXNzaW9uRGF0YSA/IGZvcm1EYXRhSnNvbiA6IGZvcm1EYXRhLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAodmFsaWRhdGVTdGF0dXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/ICF2YWxpZGF0ZVN0YXR1cyhyZXNwb25zZS5zdGF0dXMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiByZXNwb25zZS5zdGF0dXMgPCAyMDAgfHwgcmVzcG9uc2Uuc3RhdHVzID49IDMwMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc0Vycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uRXJyb3IgJiYgb25FcnJvcih7IHJlc3BvbnNlIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZSA9IFN0cmluZyhyZXNwb25zZS5zdGF0dXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25TdWNjZXNzICYmIG9uU3VjY2Vzcyh7IHJlc3BvbnNlIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBoYXNFcnJvciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3IgJiYgb25FcnJvcih7IGVycm9yIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkoZXZlbnQpO1xuICAgICAgICBpZiAoaGFzRXJyb3IgJiYgcHJvcHMuY29udHJvbCkge1xuICAgICAgICAgICAgcHJvcHMuY29udHJvbC5fc3ViamVjdHMuc3RhdGUubmV4dCh7XG4gICAgICAgICAgICAgICAgaXNTdWJtaXRTdWNjZXNzZnVsOiBmYWxzZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcHJvcHMuY29udHJvbC5zZXRFcnJvcigncm9vdC5zZXJ2ZXInLCB7XG4gICAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBzZXRNb3VudGVkKHRydWUpO1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gcmVuZGVyID8gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIHJlbmRlcih7XG4gICAgICAgIHN1Ym1pdCxcbiAgICB9KSkpIDogKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJmb3JtXCIsIHsgbm9WYWxpZGF0ZTogbW91bnRlZCwgYWN0aW9uOiBhY3Rpb24sIG1ldGhvZDogbWV0aG9kLCBlbmNUeXBlOiBlbmNUeXBlLCBvblN1Ym1pdDogc3VibWl0LCAuLi5yZXN0IH0sIGNoaWxkcmVuKSk7XG59XG5cbnZhciBhcHBlbmRFcnJvcnMgPSAobmFtZSwgdmFsaWRhdGVBbGxGaWVsZENyaXRlcmlhLCBlcnJvcnMsIHR5cGUsIG1lc3NhZ2UpID0+IHZhbGlkYXRlQWxsRmllbGRDcml0ZXJpYVxuICAgID8ge1xuICAgICAgICAuLi5lcnJvcnNbbmFtZV0sXG4gICAgICAgIHR5cGVzOiB7XG4gICAgICAgICAgICAuLi4oZXJyb3JzW25hbWVdICYmIGVycm9yc1tuYW1lXS50eXBlcyA/IGVycm9yc1tuYW1lXS50eXBlcyA6IHt9KSxcbiAgICAgICAgICAgIFt0eXBlXTogbWVzc2FnZSB8fCB0cnVlLFxuICAgICAgICB9LFxuICAgIH1cbiAgICA6IHt9O1xuXG52YXIgZ2VuZXJhdGVJZCA9ICgpID0+IHtcbiAgICBjb25zdCBkID0gdHlwZW9mIHBlcmZvcm1hbmNlID09PSAndW5kZWZpbmVkJyA/IERhdGUubm93KCkgOiBwZXJmb3JtYW5jZS5ub3coKSAqIDEwMDA7XG4gICAgcmV0dXJuICd4eHh4eHh4eC14eHh4LTR4eHgteXh4eC14eHh4eHh4eHh4eHgnLnJlcGxhY2UoL1t4eV0vZywgKGMpID0+IHtcbiAgICAgICAgY29uc3QgciA9IChNYXRoLnJhbmRvbSgpICogMTYgKyBkKSAlIDE2IHwgMDtcbiAgICAgICAgcmV0dXJuIChjID09ICd4JyA/IHIgOiAociAmIDB4MykgfCAweDgpLnRvU3RyaW5nKDE2KTtcbiAgICB9KTtcbn07XG5cbnZhciBnZXRGb2N1c0ZpZWxkTmFtZSA9IChuYW1lLCBpbmRleCwgb3B0aW9ucyA9IHt9KSA9PiBvcHRpb25zLnNob3VsZEZvY3VzIHx8IGlzVW5kZWZpbmVkKG9wdGlvbnMuc2hvdWxkRm9jdXMpXG4gICAgPyBvcHRpb25zLmZvY3VzTmFtZSB8fFxuICAgICAgICBgJHtuYW1lfS4ke2lzVW5kZWZpbmVkKG9wdGlvbnMuZm9jdXNJbmRleCkgPyBpbmRleCA6IG9wdGlvbnMuZm9jdXNJbmRleH0uYFxuICAgIDogJyc7XG5cbnZhciBnZXRWYWxpZGF0aW9uTW9kZXMgPSAobW9kZSkgPT4gKHtcbiAgICBpc09uU3VibWl0OiAhbW9kZSB8fCBtb2RlID09PSBWQUxJREFUSU9OX01PREUub25TdWJtaXQsXG4gICAgaXNPbkJsdXI6IG1vZGUgPT09IFZBTElEQVRJT05fTU9ERS5vbkJsdXIsXG4gICAgaXNPbkNoYW5nZTogbW9kZSA9PT0gVkFMSURBVElPTl9NT0RFLm9uQ2hhbmdlLFxuICAgIGlzT25BbGw6IG1vZGUgPT09IFZBTElEQVRJT05fTU9ERS5hbGwsXG4gICAgaXNPblRvdWNoOiBtb2RlID09PSBWQUxJREFUSU9OX01PREUub25Ub3VjaGVkLFxufSk7XG5cbnZhciBpc1dhdGNoZWQgPSAobmFtZSwgX25hbWVzLCBpc0JsdXJFdmVudCkgPT4gIWlzQmx1ckV2ZW50ICYmXG4gICAgKF9uYW1lcy53YXRjaEFsbCB8fFxuICAgICAgICBfbmFtZXMud2F0Y2guaGFzKG5hbWUpIHx8XG4gICAgICAgIFsuLi5fbmFtZXMud2F0Y2hdLnNvbWUoKHdhdGNoTmFtZSkgPT4gbmFtZS5zdGFydHNXaXRoKHdhdGNoTmFtZSkgJiZcbiAgICAgICAgICAgIC9eXFwuXFx3Ky8udGVzdChuYW1lLnNsaWNlKHdhdGNoTmFtZS5sZW5ndGgpKSkpO1xuXG5jb25zdCBpdGVyYXRlRmllbGRzQnlBY3Rpb24gPSAoZmllbGRzLCBhY3Rpb24sIGZpZWxkc05hbWVzLCBhYm9ydEVhcmx5KSA9PiB7XG4gICAgZm9yIChjb25zdCBrZXkgb2YgZmllbGRzTmFtZXMgfHwgT2JqZWN0LmtleXMoZmllbGRzKSkge1xuICAgICAgICBjb25zdCBmaWVsZCA9IGdldChmaWVsZHMsIGtleSk7XG4gICAgICAgIGlmIChmaWVsZCkge1xuICAgICAgICAgICAgY29uc3QgeyBfZiwgLi4uY3VycmVudEZpZWxkIH0gPSBmaWVsZDtcbiAgICAgICAgICAgIGlmIChfZikge1xuICAgICAgICAgICAgICAgIGlmIChfZi5yZWZzICYmIF9mLnJlZnNbMF0gJiYgYWN0aW9uKF9mLnJlZnNbMF0sIGtleSkgJiYgIWFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKF9mLnJlZiAmJiBhY3Rpb24oX2YucmVmLCBfZi5uYW1lKSAmJiAhYWJvcnRFYXJseSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpdGVyYXRlRmllbGRzQnlBY3Rpb24oY3VycmVudEZpZWxkLCBhY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzT2JqZWN0KGN1cnJlbnRGaWVsZCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXRlcmF0ZUZpZWxkc0J5QWN0aW9uKGN1cnJlbnRGaWVsZCwgYWN0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuO1xufTtcblxudmFyIHVwZGF0ZUZpZWxkQXJyYXlSb290RXJyb3IgPSAoZXJyb3JzLCBlcnJvciwgbmFtZSkgPT4ge1xuICAgIGNvbnN0IGZpZWxkQXJyYXlFcnJvcnMgPSBjb252ZXJ0VG9BcnJheVBheWxvYWQoZ2V0KGVycm9ycywgbmFtZSkpO1xuICAgIHNldChmaWVsZEFycmF5RXJyb3JzLCAncm9vdCcsIGVycm9yW25hbWVdKTtcbiAgICBzZXQoZXJyb3JzLCBuYW1lLCBmaWVsZEFycmF5RXJyb3JzKTtcbiAgICByZXR1cm4gZXJyb3JzO1xufTtcblxudmFyIGlzRmlsZUlucHV0ID0gKGVsZW1lbnQpID0+IGVsZW1lbnQudHlwZSA9PT0gJ2ZpbGUnO1xuXG52YXIgaXNGdW5jdGlvbiA9ICh2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nO1xuXG52YXIgaXNIVE1MRWxlbWVudCA9ICh2YWx1ZSkgPT4ge1xuICAgIGlmICghaXNXZWIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBvd25lciA9IHZhbHVlID8gdmFsdWUub3duZXJEb2N1bWVudCA6IDA7XG4gICAgcmV0dXJuICh2YWx1ZSBpbnN0YW5jZW9mXG4gICAgICAgIChvd25lciAmJiBvd25lci5kZWZhdWx0VmlldyA/IG93bmVyLmRlZmF1bHRWaWV3LkhUTUxFbGVtZW50IDogSFRNTEVsZW1lbnQpKTtcbn07XG5cbnZhciBpc01lc3NhZ2UgPSAodmFsdWUpID0+IGlzU3RyaW5nKHZhbHVlKTtcblxudmFyIGlzUmFkaW9JbnB1dCA9IChlbGVtZW50KSA9PiBlbGVtZW50LnR5cGUgPT09ICdyYWRpbyc7XG5cbnZhciBpc1JlZ2V4ID0gKHZhbHVlKSA9PiB2YWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cDtcblxuY29uc3QgZGVmYXVsdFJlc3VsdCA9IHtcbiAgICB2YWx1ZTogZmFsc2UsXG4gICAgaXNWYWxpZDogZmFsc2UsXG59O1xuY29uc3QgdmFsaWRSZXN1bHQgPSB7IHZhbHVlOiB0cnVlLCBpc1ZhbGlkOiB0cnVlIH07XG52YXIgZ2V0Q2hlY2tib3hWYWx1ZSA9IChvcHRpb25zKSA9PiB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucykpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWVzID0gb3B0aW9uc1xuICAgICAgICAgICAgICAgIC5maWx0ZXIoKG9wdGlvbikgPT4gb3B0aW9uICYmIG9wdGlvbi5jaGVja2VkICYmICFvcHRpb24uZGlzYWJsZWQpXG4gICAgICAgICAgICAgICAgLm1hcCgob3B0aW9uKSA9PiBvcHRpb24udmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IHZhbHVlcywgaXNWYWxpZDogISF2YWx1ZXMubGVuZ3RoIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9wdGlvbnNbMF0uY2hlY2tlZCAmJiAhb3B0aW9uc1swXS5kaXNhYmxlZFxuICAgICAgICAgICAgPyAvLyBAdHMtZXhwZWN0LWVycm9yIGV4cGVjdGVkIHRvIHdvcmsgaW4gdGhlIGJyb3dzZXJcbiAgICAgICAgICAgICAgICBvcHRpb25zWzBdLmF0dHJpYnV0ZXMgJiYgIWlzVW5kZWZpbmVkKG9wdGlvbnNbMF0uYXR0cmlidXRlcy52YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgPyBpc1VuZGVmaW5lZChvcHRpb25zWzBdLnZhbHVlKSB8fCBvcHRpb25zWzBdLnZhbHVlID09PSAnJ1xuICAgICAgICAgICAgICAgICAgICAgICAgPyB2YWxpZFJlc3VsdFxuICAgICAgICAgICAgICAgICAgICAgICAgOiB7IHZhbHVlOiBvcHRpb25zWzBdLnZhbHVlLCBpc1ZhbGlkOiB0cnVlIH1cbiAgICAgICAgICAgICAgICAgICAgOiB2YWxpZFJlc3VsdFxuICAgICAgICAgICAgOiBkZWZhdWx0UmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gZGVmYXVsdFJlc3VsdDtcbn07XG5cbmNvbnN0IGRlZmF1bHRSZXR1cm4gPSB7XG4gICAgaXNWYWxpZDogZmFsc2UsXG4gICAgdmFsdWU6IG51bGwsXG59O1xudmFyIGdldFJhZGlvVmFsdWUgPSAob3B0aW9ucykgPT4gQXJyYXkuaXNBcnJheShvcHRpb25zKVxuICAgID8gb3B0aW9ucy5yZWR1Y2UoKHByZXZpb3VzLCBvcHRpb24pID0+IG9wdGlvbiAmJiBvcHRpb24uY2hlY2tlZCAmJiAhb3B0aW9uLmRpc2FibGVkXG4gICAgICAgID8ge1xuICAgICAgICAgICAgaXNWYWxpZDogdHJ1ZSxcbiAgICAgICAgICAgIHZhbHVlOiBvcHRpb24udmFsdWUsXG4gICAgICAgIH1cbiAgICAgICAgOiBwcmV2aW91cywgZGVmYXVsdFJldHVybilcbiAgICA6IGRlZmF1bHRSZXR1cm47XG5cbmZ1bmN0aW9uIGdldFZhbGlkYXRlRXJyb3IocmVzdWx0LCByZWYsIHR5cGUgPSAndmFsaWRhdGUnKSB7XG4gICAgaWYgKGlzTWVzc2FnZShyZXN1bHQpIHx8XG4gICAgICAgIChBcnJheS5pc0FycmF5KHJlc3VsdCkgJiYgcmVzdWx0LmV2ZXJ5KGlzTWVzc2FnZSkpIHx8XG4gICAgICAgIChpc0Jvb2xlYW4ocmVzdWx0KSAmJiAhcmVzdWx0KSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGlzTWVzc2FnZShyZXN1bHQpID8gcmVzdWx0IDogJycsXG4gICAgICAgICAgICByZWYsXG4gICAgICAgIH07XG4gICAgfVxufVxuXG52YXIgZ2V0VmFsdWVBbmRNZXNzYWdlID0gKHZhbGlkYXRpb25EYXRhKSA9PiBpc09iamVjdCh2YWxpZGF0aW9uRGF0YSkgJiYgIWlzUmVnZXgodmFsaWRhdGlvbkRhdGEpXG4gICAgPyB2YWxpZGF0aW9uRGF0YVxuICAgIDoge1xuICAgICAgICB2YWx1ZTogdmFsaWRhdGlvbkRhdGEsXG4gICAgICAgIG1lc3NhZ2U6ICcnLFxuICAgIH07XG5cbnZhciB2YWxpZGF0ZUZpZWxkID0gYXN5bmMgKGZpZWxkLCBmb3JtVmFsdWVzLCB2YWxpZGF0ZUFsbEZpZWxkQ3JpdGVyaWEsIHNob3VsZFVzZU5hdGl2ZVZhbGlkYXRpb24sIGlzRmllbGRBcnJheSkgPT4ge1xuICAgIGNvbnN0IHsgcmVmLCByZWZzLCByZXF1aXJlZCwgbWF4TGVuZ3RoLCBtaW5MZW5ndGgsIG1pbiwgbWF4LCBwYXR0ZXJuLCB2YWxpZGF0ZSwgbmFtZSwgdmFsdWVBc051bWJlciwgbW91bnQsIGRpc2FibGVkLCB9ID0gZmllbGQuX2Y7XG4gICAgY29uc3QgaW5wdXRWYWx1ZSA9IGdldChmb3JtVmFsdWVzLCBuYW1lKTtcbiAgICBpZiAoIW1vdW50IHx8IGRpc2FibGVkKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgY29uc3QgaW5wdXRSZWYgPSByZWZzID8gcmVmc1swXSA6IHJlZjtcbiAgICBjb25zdCBzZXRDdXN0b21WYWxpZGl0eSA9IChtZXNzYWdlKSA9PiB7XG4gICAgICAgIGlmIChzaG91bGRVc2VOYXRpdmVWYWxpZGF0aW9uICYmIGlucHV0UmVmLnJlcG9ydFZhbGlkaXR5KSB7XG4gICAgICAgICAgICBpbnB1dFJlZi5zZXRDdXN0b21WYWxpZGl0eShpc0Jvb2xlYW4obWVzc2FnZSkgPyAnJyA6IG1lc3NhZ2UgfHwgJycpO1xuICAgICAgICAgICAgaW5wdXRSZWYucmVwb3J0VmFsaWRpdHkoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgZXJyb3IgPSB7fTtcbiAgICBjb25zdCBpc1JhZGlvID0gaXNSYWRpb0lucHV0KHJlZik7XG4gICAgY29uc3QgaXNDaGVja0JveCA9IGlzQ2hlY2tCb3hJbnB1dChyZWYpO1xuICAgIGNvbnN0IGlzUmFkaW9PckNoZWNrYm94ID0gaXNSYWRpbyB8fCBpc0NoZWNrQm94O1xuICAgIGNvbnN0IGlzRW1wdHkgPSAoKHZhbHVlQXNOdW1iZXIgfHwgaXNGaWxlSW5wdXQocmVmKSkgJiZcbiAgICAgICAgaXNVbmRlZmluZWQocmVmLnZhbHVlKSAmJlxuICAgICAgICBpc1VuZGVmaW5lZChpbnB1dFZhbHVlKSkgfHxcbiAgICAgICAgKGlzSFRNTEVsZW1lbnQocmVmKSAmJiByZWYudmFsdWUgPT09ICcnKSB8fFxuICAgICAgICBpbnB1dFZhbHVlID09PSAnJyB8fFxuICAgICAgICAoQXJyYXkuaXNBcnJheShpbnB1dFZhbHVlKSAmJiAhaW5wdXRWYWx1ZS5sZW5ndGgpO1xuICAgIGNvbnN0IGFwcGVuZEVycm9yc0N1cnJ5ID0gYXBwZW5kRXJyb3JzLmJpbmQobnVsbCwgbmFtZSwgdmFsaWRhdGVBbGxGaWVsZENyaXRlcmlhLCBlcnJvcik7XG4gICAgY29uc3QgZ2V0TWluTWF4TWVzc2FnZSA9IChleGNlZWRNYXgsIG1heExlbmd0aE1lc3NhZ2UsIG1pbkxlbmd0aE1lc3NhZ2UsIG1heFR5cGUgPSBJTlBVVF9WQUxJREFUSU9OX1JVTEVTLm1heExlbmd0aCwgbWluVHlwZSA9IElOUFVUX1ZBTElEQVRJT05fUlVMRVMubWluTGVuZ3RoKSA9PiB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBleGNlZWRNYXggPyBtYXhMZW5ndGhNZXNzYWdlIDogbWluTGVuZ3RoTWVzc2FnZTtcbiAgICAgICAgZXJyb3JbbmFtZV0gPSB7XG4gICAgICAgICAgICB0eXBlOiBleGNlZWRNYXggPyBtYXhUeXBlIDogbWluVHlwZSxcbiAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgICByZWYsXG4gICAgICAgICAgICAuLi5hcHBlbmRFcnJvcnNDdXJyeShleGNlZWRNYXggPyBtYXhUeXBlIDogbWluVHlwZSwgbWVzc2FnZSksXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBpZiAoaXNGaWVsZEFycmF5XG4gICAgICAgID8gIUFycmF5LmlzQXJyYXkoaW5wdXRWYWx1ZSkgfHwgIWlucHV0VmFsdWUubGVuZ3RoXG4gICAgICAgIDogcmVxdWlyZWQgJiZcbiAgICAgICAgICAgICgoIWlzUmFkaW9PckNoZWNrYm94ICYmIChpc0VtcHR5IHx8IGlzTnVsbE9yVW5kZWZpbmVkKGlucHV0VmFsdWUpKSkgfHxcbiAgICAgICAgICAgICAgICAoaXNCb29sZWFuKGlucHV0VmFsdWUpICYmICFpbnB1dFZhbHVlKSB8fFxuICAgICAgICAgICAgICAgIChpc0NoZWNrQm94ICYmICFnZXRDaGVja2JveFZhbHVlKHJlZnMpLmlzVmFsaWQpIHx8XG4gICAgICAgICAgICAgICAgKGlzUmFkaW8gJiYgIWdldFJhZGlvVmFsdWUocmVmcykuaXNWYWxpZCkpKSB7XG4gICAgICAgIGNvbnN0IHsgdmFsdWUsIG1lc3NhZ2UgfSA9IGlzTWVzc2FnZShyZXF1aXJlZClcbiAgICAgICAgICAgID8geyB2YWx1ZTogISFyZXF1aXJlZCwgbWVzc2FnZTogcmVxdWlyZWQgfVxuICAgICAgICAgICAgOiBnZXRWYWx1ZUFuZE1lc3NhZ2UocmVxdWlyZWQpO1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIGVycm9yW25hbWVdID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IElOUFVUX1ZBTElEQVRJT05fUlVMRVMucmVxdWlyZWQsXG4gICAgICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgICAgICByZWY6IGlucHV0UmVmLFxuICAgICAgICAgICAgICAgIC4uLmFwcGVuZEVycm9yc0N1cnJ5KElOUFVUX1ZBTElEQVRJT05fUlVMRVMucmVxdWlyZWQsIG1lc3NhZ2UpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICghdmFsaWRhdGVBbGxGaWVsZENyaXRlcmlhKSB7XG4gICAgICAgICAgICAgICAgc2V0Q3VzdG9tVmFsaWRpdHkobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghaXNFbXB0eSAmJiAoIWlzTnVsbE9yVW5kZWZpbmVkKG1pbikgfHwgIWlzTnVsbE9yVW5kZWZpbmVkKG1heCkpKSB7XG4gICAgICAgIGxldCBleGNlZWRNYXg7XG4gICAgICAgIGxldCBleGNlZWRNaW47XG4gICAgICAgIGNvbnN0IG1heE91dHB1dCA9IGdldFZhbHVlQW5kTWVzc2FnZShtYXgpO1xuICAgICAgICBjb25zdCBtaW5PdXRwdXQgPSBnZXRWYWx1ZUFuZE1lc3NhZ2UobWluKTtcbiAgICAgICAgaWYgKCFpc051bGxPclVuZGVmaW5lZChpbnB1dFZhbHVlKSAmJiAhaXNOYU4oaW5wdXRWYWx1ZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlTnVtYmVyID0gcmVmLnZhbHVlQXNOdW1iZXIgfHxcbiAgICAgICAgICAgICAgICAoaW5wdXRWYWx1ZSA/ICtpbnB1dFZhbHVlIDogaW5wdXRWYWx1ZSk7XG4gICAgICAgICAgICBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKG1heE91dHB1dC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBleGNlZWRNYXggPSB2YWx1ZU51bWJlciA+IG1heE91dHB1dC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNOdWxsT3JVbmRlZmluZWQobWluT3V0cHV0LnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGV4Y2VlZE1pbiA9IHZhbHVlTnVtYmVyIDwgbWluT3V0cHV0LnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgdmFsdWVEYXRlID0gcmVmLnZhbHVlQXNEYXRlIHx8IG5ldyBEYXRlKGlucHV0VmFsdWUpO1xuICAgICAgICAgICAgY29uc3QgY29udmVydFRpbWVUb0RhdGUgPSAodGltZSkgPT4gbmV3IERhdGUobmV3IERhdGUoKS50b0RhdGVTdHJpbmcoKSArICcgJyArIHRpbWUpO1xuICAgICAgICAgICAgY29uc3QgaXNUaW1lID0gcmVmLnR5cGUgPT0gJ3RpbWUnO1xuICAgICAgICAgICAgY29uc3QgaXNXZWVrID0gcmVmLnR5cGUgPT0gJ3dlZWsnO1xuICAgICAgICAgICAgaWYgKGlzU3RyaW5nKG1heE91dHB1dC52YWx1ZSkgJiYgaW5wdXRWYWx1ZSkge1xuICAgICAgICAgICAgICAgIGV4Y2VlZE1heCA9IGlzVGltZVxuICAgICAgICAgICAgICAgICAgICA/IGNvbnZlcnRUaW1lVG9EYXRlKGlucHV0VmFsdWUpID4gY29udmVydFRpbWVUb0RhdGUobWF4T3V0cHV0LnZhbHVlKVxuICAgICAgICAgICAgICAgICAgICA6IGlzV2Vla1xuICAgICAgICAgICAgICAgICAgICAgICAgPyBpbnB1dFZhbHVlID4gbWF4T3V0cHV0LnZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHZhbHVlRGF0ZSA+IG5ldyBEYXRlKG1heE91dHB1dC52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNTdHJpbmcobWluT3V0cHV0LnZhbHVlKSAmJiBpbnB1dFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgZXhjZWVkTWluID0gaXNUaW1lXG4gICAgICAgICAgICAgICAgICAgID8gY29udmVydFRpbWVUb0RhdGUoaW5wdXRWYWx1ZSkgPCBjb252ZXJ0VGltZVRvRGF0ZShtaW5PdXRwdXQudmFsdWUpXG4gICAgICAgICAgICAgICAgICAgIDogaXNXZWVrXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGlucHV0VmFsdWUgPCBtaW5PdXRwdXQudmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdmFsdWVEYXRlIDwgbmV3IERhdGUobWluT3V0cHV0LnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZXhjZWVkTWF4IHx8IGV4Y2VlZE1pbikge1xuICAgICAgICAgICAgZ2V0TWluTWF4TWVzc2FnZSghIWV4Y2VlZE1heCwgbWF4T3V0cHV0Lm1lc3NhZ2UsIG1pbk91dHB1dC5tZXNzYWdlLCBJTlBVVF9WQUxJREFUSU9OX1JVTEVTLm1heCwgSU5QVVRfVkFMSURBVElPTl9SVUxFUy5taW4pO1xuICAgICAgICAgICAgaWYgKCF2YWxpZGF0ZUFsbEZpZWxkQ3JpdGVyaWEpIHtcbiAgICAgICAgICAgICAgICBzZXRDdXN0b21WYWxpZGl0eShlcnJvcltuYW1lXS5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKChtYXhMZW5ndGggfHwgbWluTGVuZ3RoKSAmJlxuICAgICAgICAhaXNFbXB0eSAmJlxuICAgICAgICAoaXNTdHJpbmcoaW5wdXRWYWx1ZSkgfHwgKGlzRmllbGRBcnJheSAmJiBBcnJheS5pc0FycmF5KGlucHV0VmFsdWUpKSkpIHtcbiAgICAgICAgY29uc3QgbWF4TGVuZ3RoT3V0cHV0ID0gZ2V0VmFsdWVBbmRNZXNzYWdlKG1heExlbmd0aCk7XG4gICAgICAgIGNvbnN0IG1pbkxlbmd0aE91dHB1dCA9IGdldFZhbHVlQW5kTWVzc2FnZShtaW5MZW5ndGgpO1xuICAgICAgICBjb25zdCBleGNlZWRNYXggPSAhaXNOdWxsT3JVbmRlZmluZWQobWF4TGVuZ3RoT3V0cHV0LnZhbHVlKSAmJlxuICAgICAgICAgICAgaW5wdXRWYWx1ZS5sZW5ndGggPiArbWF4TGVuZ3RoT3V0cHV0LnZhbHVlO1xuICAgICAgICBjb25zdCBleGNlZWRNaW4gPSAhaXNOdWxsT3JVbmRlZmluZWQobWluTGVuZ3RoT3V0cHV0LnZhbHVlKSAmJlxuICAgICAgICAgICAgaW5wdXRWYWx1ZS5sZW5ndGggPCArbWluTGVuZ3RoT3V0cHV0LnZhbHVlO1xuICAgICAgICBpZiAoZXhjZWVkTWF4IHx8IGV4Y2VlZE1pbikge1xuICAgICAgICAgICAgZ2V0TWluTWF4TWVzc2FnZShleGNlZWRNYXgsIG1heExlbmd0aE91dHB1dC5tZXNzYWdlLCBtaW5MZW5ndGhPdXRwdXQubWVzc2FnZSk7XG4gICAgICAgICAgICBpZiAoIXZhbGlkYXRlQWxsRmllbGRDcml0ZXJpYSkge1xuICAgICAgICAgICAgICAgIHNldEN1c3RvbVZhbGlkaXR5KGVycm9yW25hbWVdLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAocGF0dGVybiAmJiAhaXNFbXB0eSAmJiBpc1N0cmluZyhpbnB1dFZhbHVlKSkge1xuICAgICAgICBjb25zdCB7IHZhbHVlOiBwYXR0ZXJuVmFsdWUsIG1lc3NhZ2UgfSA9IGdldFZhbHVlQW5kTWVzc2FnZShwYXR0ZXJuKTtcbiAgICAgICAgaWYgKGlzUmVnZXgocGF0dGVyblZhbHVlKSAmJiAhaW5wdXRWYWx1ZS5tYXRjaChwYXR0ZXJuVmFsdWUpKSB7XG4gICAgICAgICAgICBlcnJvcltuYW1lXSA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBJTlBVVF9WQUxJREFUSU9OX1JVTEVTLnBhdHRlcm4sXG4gICAgICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgICAgICByZWYsXG4gICAgICAgICAgICAgICAgLi4uYXBwZW5kRXJyb3JzQ3VycnkoSU5QVVRfVkFMSURBVElPTl9SVUxFUy5wYXR0ZXJuLCBtZXNzYWdlKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoIXZhbGlkYXRlQWxsRmllbGRDcml0ZXJpYSkge1xuICAgICAgICAgICAgICAgIHNldEN1c3RvbVZhbGlkaXR5KG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodmFsaWRhdGUpIHtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24odmFsaWRhdGUpKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB2YWxpZGF0ZShpbnB1dFZhbHVlLCBmb3JtVmFsdWVzKTtcbiAgICAgICAgICAgIGNvbnN0IHZhbGlkYXRlRXJyb3IgPSBnZXRWYWxpZGF0ZUVycm9yKHJlc3VsdCwgaW5wdXRSZWYpO1xuICAgICAgICAgICAgaWYgKHZhbGlkYXRlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBlcnJvcltuYW1lXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgLi4udmFsaWRhdGVFcnJvcixcbiAgICAgICAgICAgICAgICAgICAgLi4uYXBwZW5kRXJyb3JzQ3VycnkoSU5QVVRfVkFMSURBVElPTl9SVUxFUy52YWxpZGF0ZSwgdmFsaWRhdGVFcnJvci5tZXNzYWdlKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmICghdmFsaWRhdGVBbGxGaWVsZENyaXRlcmlhKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldEN1c3RvbVZhbGlkaXR5KHZhbGlkYXRlRXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNPYmplY3QodmFsaWRhdGUpKSB7XG4gICAgICAgICAgICBsZXQgdmFsaWRhdGlvblJlc3VsdCA9IHt9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdmFsaWRhdGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzRW1wdHlPYmplY3QodmFsaWRhdGlvblJlc3VsdCkgJiYgIXZhbGlkYXRlQWxsRmllbGRDcml0ZXJpYSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsaWRhdGVFcnJvciA9IGdldFZhbGlkYXRlRXJyb3IoYXdhaXQgdmFsaWRhdGVba2V5XShpbnB1dFZhbHVlLCBmb3JtVmFsdWVzKSwgaW5wdXRSZWYsIGtleSk7XG4gICAgICAgICAgICAgICAgaWYgKHZhbGlkYXRlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnZhbGlkYXRlRXJyb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5hcHBlbmRFcnJvcnNDdXJyeShrZXksIHZhbGlkYXRlRXJyb3IubWVzc2FnZSksXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHNldEN1c3RvbVZhbGlkaXR5KHZhbGlkYXRlRXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWxpZGF0ZUFsbEZpZWxkQ3JpdGVyaWEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yW25hbWVdID0gdmFsaWRhdGlvblJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNFbXB0eU9iamVjdCh2YWxpZGF0aW9uUmVzdWx0KSkge1xuICAgICAgICAgICAgICAgIGVycm9yW25hbWVdID0ge1xuICAgICAgICAgICAgICAgICAgICByZWY6IGlucHV0UmVmLFxuICAgICAgICAgICAgICAgICAgICAuLi52YWxpZGF0aW9uUmVzdWx0LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKCF2YWxpZGF0ZUFsbEZpZWxkQ3JpdGVyaWEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRDdXN0b21WYWxpZGl0eSh0cnVlKTtcbiAgICByZXR1cm4gZXJyb3I7XG59O1xuXG52YXIgYXBwZW5kQXQgPSAoZGF0YSwgdmFsdWUpID0+IFtcbiAgICAuLi5kYXRhLFxuICAgIC4uLmNvbnZlcnRUb0FycmF5UGF5bG9hZCh2YWx1ZSksXG5dO1xuXG52YXIgZmlsbEVtcHR5QXJyYXkgPSAodmFsdWUpID0+IEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUubWFwKCgpID0+IHVuZGVmaW5lZCkgOiB1bmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGluc2VydChkYXRhLCBpbmRleCwgdmFsdWUpIHtcbiAgICByZXR1cm4gW1xuICAgICAgICAuLi5kYXRhLnNsaWNlKDAsIGluZGV4KSxcbiAgICAgICAgLi4uY29udmVydFRvQXJyYXlQYXlsb2FkKHZhbHVlKSxcbiAgICAgICAgLi4uZGF0YS5zbGljZShpbmRleCksXG4gICAgXTtcbn1cblxudmFyIG1vdmVBcnJheUF0ID0gKGRhdGEsIGZyb20sIHRvKSA9PiB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgaWYgKGlzVW5kZWZpbmVkKGRhdGFbdG9dKSkge1xuICAgICAgICBkYXRhW3RvXSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZGF0YS5zcGxpY2UodG8sIDAsIGRhdGEuc3BsaWNlKGZyb20sIDEpWzBdKTtcbiAgICByZXR1cm4gZGF0YTtcbn07XG5cbnZhciBwcmVwZW5kQXQgPSAoZGF0YSwgdmFsdWUpID0+IFtcbiAgICAuLi5jb252ZXJ0VG9BcnJheVBheWxvYWQodmFsdWUpLFxuICAgIC4uLmNvbnZlcnRUb0FycmF5UGF5bG9hZChkYXRhKSxcbl07XG5cbmZ1bmN0aW9uIHJlbW92ZUF0SW5kZXhlcyhkYXRhLCBpbmRleGVzKSB7XG4gICAgbGV0IGkgPSAwO1xuICAgIGNvbnN0IHRlbXAgPSBbLi4uZGF0YV07XG4gICAgZm9yIChjb25zdCBpbmRleCBvZiBpbmRleGVzKSB7XG4gICAgICAgIHRlbXAuc3BsaWNlKGluZGV4IC0gaSwgMSk7XG4gICAgICAgIGkrKztcbiAgICB9XG4gICAgcmV0dXJuIGNvbXBhY3QodGVtcCkubGVuZ3RoID8gdGVtcCA6IFtdO1xufVxudmFyIHJlbW92ZUFycmF5QXQgPSAoZGF0YSwgaW5kZXgpID0+IGlzVW5kZWZpbmVkKGluZGV4KVxuICAgID8gW11cbiAgICA6IHJlbW92ZUF0SW5kZXhlcyhkYXRhLCBjb252ZXJ0VG9BcnJheVBheWxvYWQoaW5kZXgpLnNvcnQoKGEsIGIpID0+IGEgLSBiKSk7XG5cbnZhciBzd2FwQXJyYXlBdCA9IChkYXRhLCBpbmRleEEsIGluZGV4QikgPT4ge1xuICAgIFtkYXRhW2luZGV4QV0sIGRhdGFbaW5kZXhCXV0gPSBbZGF0YVtpbmRleEJdLCBkYXRhW2luZGV4QV1dO1xufTtcblxuZnVuY3Rpb24gYmFzZUdldChvYmplY3QsIHVwZGF0ZVBhdGgpIHtcbiAgICBjb25zdCBsZW5ndGggPSB1cGRhdGVQYXRoLnNsaWNlKDAsIC0xKS5sZW5ndGg7XG4gICAgbGV0IGluZGV4ID0gMDtcbiAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgb2JqZWN0ID0gaXNVbmRlZmluZWQob2JqZWN0KSA/IGluZGV4KysgOiBvYmplY3RbdXBkYXRlUGF0aFtpbmRleCsrXV07XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG59XG5mdW5jdGlvbiBpc0VtcHR5QXJyYXkob2JqKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSAmJiAhaXNVbmRlZmluZWQob2JqW2tleV0pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiB1bnNldChvYmplY3QsIHBhdGgpIHtcbiAgICBjb25zdCBwYXRocyA9IEFycmF5LmlzQXJyYXkocGF0aClcbiAgICAgICAgPyBwYXRoXG4gICAgICAgIDogaXNLZXkocGF0aClcbiAgICAgICAgICAgID8gW3BhdGhdXG4gICAgICAgICAgICA6IHN0cmluZ1RvUGF0aChwYXRoKTtcbiAgICBjb25zdCBjaGlsZE9iamVjdCA9IHBhdGhzLmxlbmd0aCA9PT0gMSA/IG9iamVjdCA6IGJhc2VHZXQob2JqZWN0LCBwYXRocyk7XG4gICAgY29uc3QgaW5kZXggPSBwYXRocy5sZW5ndGggLSAxO1xuICAgIGNvbnN0IGtleSA9IHBhdGhzW2luZGV4XTtcbiAgICBpZiAoY2hpbGRPYmplY3QpIHtcbiAgICAgICAgZGVsZXRlIGNoaWxkT2JqZWN0W2tleV07XG4gICAgfVxuICAgIGlmIChpbmRleCAhPT0gMCAmJlxuICAgICAgICAoKGlzT2JqZWN0KGNoaWxkT2JqZWN0KSAmJiBpc0VtcHR5T2JqZWN0KGNoaWxkT2JqZWN0KSkgfHxcbiAgICAgICAgICAgIChBcnJheS5pc0FycmF5KGNoaWxkT2JqZWN0KSAmJiBpc0VtcHR5QXJyYXkoY2hpbGRPYmplY3QpKSkpIHtcbiAgICAgICAgdW5zZXQob2JqZWN0LCBwYXRocy5zbGljZSgwLCAtMSkpO1xuICAgIH1cbiAgICByZXR1cm4gb2JqZWN0O1xufVxuXG52YXIgdXBkYXRlQXQgPSAoZmllbGRWYWx1ZXMsIGluZGV4LCB2YWx1ZSkgPT4ge1xuICAgIGZpZWxkVmFsdWVzW2luZGV4XSA9IHZhbHVlO1xuICAgIHJldHVybiBmaWVsZFZhbHVlcztcbn07XG5cbi8qKlxuICogQSBjdXN0b20gaG9vayB0aGF0IGV4cG9zZXMgY29udmVuaWVudCBtZXRob2RzIHRvIHBlcmZvcm0gb3BlcmF0aW9ucyB3aXRoIGEgbGlzdCBvZiBkeW5hbWljIGlucHV0cyB0aGF0IG5lZWQgdG8gYmUgYXBwZW5kZWQsIHVwZGF0ZWQsIHJlbW92ZWQgZXRjLiDigKIgW0RlbW9dKGh0dHBzOi8vY29kZXNhbmRib3guaW8vcy9yZWFjdC1ob29rLWZvcm0tdXNlZmllbGRhcnJheS1zc3Vnbikg4oCiIFtWaWRlb10oaHR0cHM6Ly95b3V0dS5iZS80TXJiZkdTRlkyQSlcbiAqXG4gKiBAcmVtYXJrc1xuICogW0FQSV0oaHR0cHM6Ly9yZWFjdC1ob29rLWZvcm0uY29tL2RvY3MvdXNlZmllbGRhcnJheSkg4oCiIFtEZW1vXShodHRwczovL2NvZGVzYW5kYm94LmlvL3MvcmVhY3QtaG9vay1mb3JtLXVzZWZpZWxkYXJyYXktc3N1Z24pXG4gKlxuICogQHBhcmFtIHByb3BzIC0gdXNlRmllbGRBcnJheSBwcm9wc1xuICpcbiAqIEByZXR1cm5zIG1ldGhvZHMgLSBmdW5jdGlvbnMgdG8gbWFuaXB1bGF0ZSB3aXRoIHRoZSBGaWVsZCBBcnJheXMgKGR5bmFtaWMgaW5wdXRzKSB7QGxpbmsgVXNlRmllbGRBcnJheVJldHVybn1cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHN4XG4gKiBmdW5jdGlvbiBBcHAoKSB7XG4gKiAgIGNvbnN0IHsgcmVnaXN0ZXIsIGNvbnRyb2wsIGhhbmRsZVN1Ym1pdCwgcmVzZXQsIHRyaWdnZXIsIHNldEVycm9yIH0gPSB1c2VGb3JtKHtcbiAqICAgICBkZWZhdWx0VmFsdWVzOiB7XG4gKiAgICAgICB0ZXN0OiBbXVxuICogICAgIH1cbiAqICAgfSk7XG4gKiAgIGNvbnN0IHsgZmllbGRzLCBhcHBlbmQgfSA9IHVzZUZpZWxkQXJyYXkoe1xuICogICAgIGNvbnRyb2wsXG4gKiAgICAgbmFtZTogXCJ0ZXN0XCJcbiAqICAgfSk7XG4gKlxuICogICByZXR1cm4gKFxuICogICAgIDxmb3JtIG9uU3VibWl0PXtoYW5kbGVTdWJtaXQoZGF0YSA9PiBjb25zb2xlLmxvZyhkYXRhKSl9PlxuICogICAgICAge2ZpZWxkcy5tYXAoKGl0ZW0sIGluZGV4KSA9PiAoXG4gKiAgICAgICAgICA8aW5wdXQga2V5PXtpdGVtLmlkfSB7Li4ucmVnaXN0ZXIoYHRlc3QuJHtpbmRleH0uZmlyc3ROYW1lYCl9ICAvPlxuICogICAgICAgKSl9XG4gKiAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBvbkNsaWNrPXsoKSA9PiBhcHBlbmQoeyBmaXJzdE5hbWU6IFwiYmlsbFwiIH0pfT5cbiAqICAgICAgICAgYXBwZW5kXG4gKiAgICAgICA8L2J1dHRvbj5cbiAqICAgICAgIDxpbnB1dCB0eXBlPVwic3VibWl0XCIgLz5cbiAqICAgICA8L2Zvcm0+XG4gKiAgICk7XG4gKiB9XG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gdXNlRmllbGRBcnJheShwcm9wcykge1xuICAgIGNvbnN0IG1ldGhvZHMgPSB1c2VGb3JtQ29udGV4dCgpO1xuICAgIGNvbnN0IHsgY29udHJvbCA9IG1ldGhvZHMuY29udHJvbCwgbmFtZSwga2V5TmFtZSA9ICdpZCcsIHNob3VsZFVucmVnaXN0ZXIsIH0gPSBwcm9wcztcbiAgICBjb25zdCBbZmllbGRzLCBzZXRGaWVsZHNdID0gUmVhY3QudXNlU3RhdGUoY29udHJvbC5fZ2V0RmllbGRBcnJheShuYW1lKSk7XG4gICAgY29uc3QgaWRzID0gUmVhY3QudXNlUmVmKGNvbnRyb2wuX2dldEZpZWxkQXJyYXkobmFtZSkubWFwKGdlbmVyYXRlSWQpKTtcbiAgICBjb25zdCBfZmllbGRJZHMgPSBSZWFjdC51c2VSZWYoZmllbGRzKTtcbiAgICBjb25zdCBfbmFtZSA9IFJlYWN0LnVzZVJlZihuYW1lKTtcbiAgICBjb25zdCBfYWN0aW9uZWQgPSBSZWFjdC51c2VSZWYoZmFsc2UpO1xuICAgIF9uYW1lLmN1cnJlbnQgPSBuYW1lO1xuICAgIF9maWVsZElkcy5jdXJyZW50ID0gZmllbGRzO1xuICAgIGNvbnRyb2wuX25hbWVzLmFycmF5LmFkZChuYW1lKTtcbiAgICBwcm9wcy5ydWxlcyAmJlxuICAgICAgICBjb250cm9sLnJlZ2lzdGVyKG5hbWUsIHByb3BzLnJ1bGVzKTtcbiAgICB1c2VTdWJzY3JpYmUoe1xuICAgICAgICBuZXh0OiAoeyB2YWx1ZXMsIG5hbWU6IGZpZWxkQXJyYXlOYW1lLCB9KSA9PiB7XG4gICAgICAgICAgICBpZiAoZmllbGRBcnJheU5hbWUgPT09IF9uYW1lLmN1cnJlbnQgfHwgIWZpZWxkQXJyYXlOYW1lKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmllbGRWYWx1ZXMgPSBnZXQodmFsdWVzLCBfbmFtZS5jdXJyZW50KTtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShmaWVsZFZhbHVlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0RmllbGRzKGZpZWxkVmFsdWVzKTtcbiAgICAgICAgICAgICAgICAgICAgaWRzLmN1cnJlbnQgPSBmaWVsZFZhbHVlcy5tYXAoZ2VuZXJhdGVJZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzdWJqZWN0OiBjb250cm9sLl9zdWJqZWN0cy5hcnJheSxcbiAgICB9KTtcbiAgICBjb25zdCB1cGRhdGVWYWx1ZXMgPSBSZWFjdC51c2VDYWxsYmFjaygodXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMpID0+IHtcbiAgICAgICAgX2FjdGlvbmVkLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICBjb250cm9sLl91cGRhdGVGaWVsZEFycmF5KG5hbWUsIHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzKTtcbiAgICB9LCBbY29udHJvbCwgbmFtZV0pO1xuICAgIGNvbnN0IGFwcGVuZCA9ICh2YWx1ZSwgb3B0aW9ucykgPT4ge1xuICAgICAgICBjb25zdCBhcHBlbmRWYWx1ZSA9IGNvbnZlcnRUb0FycmF5UGF5bG9hZChjbG9uZU9iamVjdCh2YWx1ZSkpO1xuICAgICAgICBjb25zdCB1cGRhdGVkRmllbGRBcnJheVZhbHVlcyA9IGFwcGVuZEF0KGNvbnRyb2wuX2dldEZpZWxkQXJyYXkobmFtZSksIGFwcGVuZFZhbHVlKTtcbiAgICAgICAgY29udHJvbC5fbmFtZXMuZm9jdXMgPSBnZXRGb2N1c0ZpZWxkTmFtZShuYW1lLCB1cGRhdGVkRmllbGRBcnJheVZhbHVlcy5sZW5ndGggLSAxLCBvcHRpb25zKTtcbiAgICAgICAgaWRzLmN1cnJlbnQgPSBhcHBlbmRBdChpZHMuY3VycmVudCwgYXBwZW5kVmFsdWUubWFwKGdlbmVyYXRlSWQpKTtcbiAgICAgICAgdXBkYXRlVmFsdWVzKHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzKTtcbiAgICAgICAgc2V0RmllbGRzKHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzKTtcbiAgICAgICAgY29udHJvbC5fdXBkYXRlRmllbGRBcnJheShuYW1lLCB1cGRhdGVkRmllbGRBcnJheVZhbHVlcywgYXBwZW5kQXQsIHtcbiAgICAgICAgICAgIGFyZ0E6IGZpbGxFbXB0eUFycmF5KHZhbHVlKSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBwcmVwZW5kID0gKHZhbHVlLCBvcHRpb25zKSA9PiB7XG4gICAgICAgIGNvbnN0IHByZXBlbmRWYWx1ZSA9IGNvbnZlcnRUb0FycmF5UGF5bG9hZChjbG9uZU9iamVjdCh2YWx1ZSkpO1xuICAgICAgICBjb25zdCB1cGRhdGVkRmllbGRBcnJheVZhbHVlcyA9IHByZXBlbmRBdChjb250cm9sLl9nZXRGaWVsZEFycmF5KG5hbWUpLCBwcmVwZW5kVmFsdWUpO1xuICAgICAgICBjb250cm9sLl9uYW1lcy5mb2N1cyA9IGdldEZvY3VzRmllbGROYW1lKG5hbWUsIDAsIG9wdGlvbnMpO1xuICAgICAgICBpZHMuY3VycmVudCA9IHByZXBlbmRBdChpZHMuY3VycmVudCwgcHJlcGVuZFZhbHVlLm1hcChnZW5lcmF0ZUlkKSk7XG4gICAgICAgIHVwZGF0ZVZhbHVlcyh1cGRhdGVkRmllbGRBcnJheVZhbHVlcyk7XG4gICAgICAgIHNldEZpZWxkcyh1cGRhdGVkRmllbGRBcnJheVZhbHVlcyk7XG4gICAgICAgIGNvbnRyb2wuX3VwZGF0ZUZpZWxkQXJyYXkobmFtZSwgdXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMsIHByZXBlbmRBdCwge1xuICAgICAgICAgICAgYXJnQTogZmlsbEVtcHR5QXJyYXkodmFsdWUpLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IHJlbW92ZSA9IChpbmRleCkgPT4ge1xuICAgICAgICBjb25zdCB1cGRhdGVkRmllbGRBcnJheVZhbHVlcyA9IHJlbW92ZUFycmF5QXQoY29udHJvbC5fZ2V0RmllbGRBcnJheShuYW1lKSwgaW5kZXgpO1xuICAgICAgICBpZHMuY3VycmVudCA9IHJlbW92ZUFycmF5QXQoaWRzLmN1cnJlbnQsIGluZGV4KTtcbiAgICAgICAgdXBkYXRlVmFsdWVzKHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzKTtcbiAgICAgICAgc2V0RmllbGRzKHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzKTtcbiAgICAgICAgY29udHJvbC5fdXBkYXRlRmllbGRBcnJheShuYW1lLCB1cGRhdGVkRmllbGRBcnJheVZhbHVlcywgcmVtb3ZlQXJyYXlBdCwge1xuICAgICAgICAgICAgYXJnQTogaW5kZXgsXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgaW5zZXJ0JDEgPSAoaW5kZXgsIHZhbHVlLCBvcHRpb25zKSA9PiB7XG4gICAgICAgIGNvbnN0IGluc2VydFZhbHVlID0gY29udmVydFRvQXJyYXlQYXlsb2FkKGNsb25lT2JqZWN0KHZhbHVlKSk7XG4gICAgICAgIGNvbnN0IHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzID0gaW5zZXJ0KGNvbnRyb2wuX2dldEZpZWxkQXJyYXkobmFtZSksIGluZGV4LCBpbnNlcnRWYWx1ZSk7XG4gICAgICAgIGNvbnRyb2wuX25hbWVzLmZvY3VzID0gZ2V0Rm9jdXNGaWVsZE5hbWUobmFtZSwgaW5kZXgsIG9wdGlvbnMpO1xuICAgICAgICBpZHMuY3VycmVudCA9IGluc2VydChpZHMuY3VycmVudCwgaW5kZXgsIGluc2VydFZhbHVlLm1hcChnZW5lcmF0ZUlkKSk7XG4gICAgICAgIHVwZGF0ZVZhbHVlcyh1cGRhdGVkRmllbGRBcnJheVZhbHVlcyk7XG4gICAgICAgIHNldEZpZWxkcyh1cGRhdGVkRmllbGRBcnJheVZhbHVlcyk7XG4gICAgICAgIGNvbnRyb2wuX3VwZGF0ZUZpZWxkQXJyYXkobmFtZSwgdXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMsIGluc2VydCwge1xuICAgICAgICAgICAgYXJnQTogaW5kZXgsXG4gICAgICAgICAgICBhcmdCOiBmaWxsRW1wdHlBcnJheSh2YWx1ZSksXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3Qgc3dhcCA9IChpbmRleEEsIGluZGV4QikgPT4ge1xuICAgICAgICBjb25zdCB1cGRhdGVkRmllbGRBcnJheVZhbHVlcyA9IGNvbnRyb2wuX2dldEZpZWxkQXJyYXkobmFtZSk7XG4gICAgICAgIHN3YXBBcnJheUF0KHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzLCBpbmRleEEsIGluZGV4Qik7XG4gICAgICAgIHN3YXBBcnJheUF0KGlkcy5jdXJyZW50LCBpbmRleEEsIGluZGV4Qik7XG4gICAgICAgIHVwZGF0ZVZhbHVlcyh1cGRhdGVkRmllbGRBcnJheVZhbHVlcyk7XG4gICAgICAgIHNldEZpZWxkcyh1cGRhdGVkRmllbGRBcnJheVZhbHVlcyk7XG4gICAgICAgIGNvbnRyb2wuX3VwZGF0ZUZpZWxkQXJyYXkobmFtZSwgdXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMsIHN3YXBBcnJheUF0LCB7XG4gICAgICAgICAgICBhcmdBOiBpbmRleEEsXG4gICAgICAgICAgICBhcmdCOiBpbmRleEIsXG4gICAgICAgIH0sIGZhbHNlKTtcbiAgICB9O1xuICAgIGNvbnN0IG1vdmUgPSAoZnJvbSwgdG8pID0+IHtcbiAgICAgICAgY29uc3QgdXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMgPSBjb250cm9sLl9nZXRGaWVsZEFycmF5KG5hbWUpO1xuICAgICAgICBtb3ZlQXJyYXlBdCh1cGRhdGVkRmllbGRBcnJheVZhbHVlcywgZnJvbSwgdG8pO1xuICAgICAgICBtb3ZlQXJyYXlBdChpZHMuY3VycmVudCwgZnJvbSwgdG8pO1xuICAgICAgICB1cGRhdGVWYWx1ZXModXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMpO1xuICAgICAgICBzZXRGaWVsZHModXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMpO1xuICAgICAgICBjb250cm9sLl91cGRhdGVGaWVsZEFycmF5KG5hbWUsIHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzLCBtb3ZlQXJyYXlBdCwge1xuICAgICAgICAgICAgYXJnQTogZnJvbSxcbiAgICAgICAgICAgIGFyZ0I6IHRvLFxuICAgICAgICB9LCBmYWxzZSk7XG4gICAgfTtcbiAgICBjb25zdCB1cGRhdGUgPSAoaW5kZXgsIHZhbHVlKSA9PiB7XG4gICAgICAgIGNvbnN0IHVwZGF0ZVZhbHVlID0gY2xvbmVPYmplY3QodmFsdWUpO1xuICAgICAgICBjb25zdCB1cGRhdGVkRmllbGRBcnJheVZhbHVlcyA9IHVwZGF0ZUF0KGNvbnRyb2wuX2dldEZpZWxkQXJyYXkobmFtZSksIGluZGV4LCB1cGRhdGVWYWx1ZSk7XG4gICAgICAgIGlkcy5jdXJyZW50ID0gWy4uLnVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzXS5tYXAoKGl0ZW0sIGkpID0+ICFpdGVtIHx8IGkgPT09IGluZGV4ID8gZ2VuZXJhdGVJZCgpIDogaWRzLmN1cnJlbnRbaV0pO1xuICAgICAgICB1cGRhdGVWYWx1ZXModXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMpO1xuICAgICAgICBzZXRGaWVsZHMoWy4uLnVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzXSk7XG4gICAgICAgIGNvbnRyb2wuX3VwZGF0ZUZpZWxkQXJyYXkobmFtZSwgdXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMsIHVwZGF0ZUF0LCB7XG4gICAgICAgICAgICBhcmdBOiBpbmRleCxcbiAgICAgICAgICAgIGFyZ0I6IHVwZGF0ZVZhbHVlLFxuICAgICAgICB9LCB0cnVlLCBmYWxzZSk7XG4gICAgfTtcbiAgICBjb25zdCByZXBsYWNlID0gKHZhbHVlKSA9PiB7XG4gICAgICAgIGNvbnN0IHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzID0gY29udmVydFRvQXJyYXlQYXlsb2FkKGNsb25lT2JqZWN0KHZhbHVlKSk7XG4gICAgICAgIGlkcy5jdXJyZW50ID0gdXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMubWFwKGdlbmVyYXRlSWQpO1xuICAgICAgICB1cGRhdGVWYWx1ZXMoWy4uLnVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzXSk7XG4gICAgICAgIHNldEZpZWxkcyhbLi4udXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXNdKTtcbiAgICAgICAgY29udHJvbC5fdXBkYXRlRmllbGRBcnJheShuYW1lLCBbLi4udXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXNdLCAoZGF0YSkgPT4gZGF0YSwge30sIHRydWUsIGZhbHNlKTtcbiAgICB9O1xuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNvbnRyb2wuX3N0YXRlLmFjdGlvbiA9IGZhbHNlO1xuICAgICAgICBpc1dhdGNoZWQobmFtZSwgY29udHJvbC5fbmFtZXMpICYmXG4gICAgICAgICAgICBjb250cm9sLl9zdWJqZWN0cy5zdGF0ZS5uZXh0KHtcbiAgICAgICAgICAgICAgICAuLi5jb250cm9sLl9mb3JtU3RhdGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgaWYgKF9hY3Rpb25lZC5jdXJyZW50ICYmXG4gICAgICAgICAgICAoIWdldFZhbGlkYXRpb25Nb2Rlcyhjb250cm9sLl9vcHRpb25zLm1vZGUpLmlzT25TdWJtaXQgfHxcbiAgICAgICAgICAgICAgICBjb250cm9sLl9mb3JtU3RhdGUuaXNTdWJtaXR0ZWQpKSB7XG4gICAgICAgICAgICBpZiAoY29udHJvbC5fb3B0aW9ucy5yZXNvbHZlcikge1xuICAgICAgICAgICAgICAgIGNvbnRyb2wuX2V4ZWN1dGVTY2hlbWEoW25hbWVdKS50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBnZXQocmVzdWx0LmVycm9ycywgbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nRXJyb3IgPSBnZXQoY29udHJvbC5fZm9ybVN0YXRlLmVycm9ycywgbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChleGlzdGluZ0Vycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICA/ICghZXJyb3IgJiYgZXhpc3RpbmdFcnJvci50eXBlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChlcnJvciAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZXhpc3RpbmdFcnJvci50eXBlICE9PSBlcnJvci50eXBlIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZ0Vycm9yLm1lc3NhZ2UgIT09IGVycm9yLm1lc3NhZ2UpKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBlcnJvciAmJiBlcnJvci50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gc2V0KGNvbnRyb2wuX2Zvcm1TdGF0ZS5lcnJvcnMsIG5hbWUsIGVycm9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdW5zZXQoY29udHJvbC5fZm9ybVN0YXRlLmVycm9ycywgbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sLl9zdWJqZWN0cy5zdGF0ZS5uZXh0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnM6IGNvbnRyb2wuX2Zvcm1TdGF0ZS5lcnJvcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmllbGQgPSBnZXQoY29udHJvbC5fZmllbGRzLCBuYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoZmllbGQgJiZcbiAgICAgICAgICAgICAgICAgICAgZmllbGQuX2YgJiZcbiAgICAgICAgICAgICAgICAgICAgIShnZXRWYWxpZGF0aW9uTW9kZXMoY29udHJvbC5fb3B0aW9ucy5yZVZhbGlkYXRlTW9kZSkuaXNPblN1Ym1pdCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0VmFsaWRhdGlvbk1vZGVzKGNvbnRyb2wuX29wdGlvbnMubW9kZSkuaXNPblN1Ym1pdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVGaWVsZChmaWVsZCwgY29udHJvbC5fZm9ybVZhbHVlcywgY29udHJvbC5fb3B0aW9ucy5jcml0ZXJpYU1vZGUgPT09IFZBTElEQVRJT05fTU9ERS5hbGwsIGNvbnRyb2wuX29wdGlvbnMuc2hvdWxkVXNlTmF0aXZlVmFsaWRhdGlvbiwgdHJ1ZSkudGhlbigoZXJyb3IpID0+ICFpc0VtcHR5T2JqZWN0KGVycm9yKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbC5fc3ViamVjdHMuc3RhdGUubmV4dCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3JzOiB1cGRhdGVGaWVsZEFycmF5Um9vdEVycm9yKGNvbnRyb2wuX2Zvcm1TdGF0ZS5lcnJvcnMsIGVycm9yLCBuYW1lKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29udHJvbC5fc3ViamVjdHMudmFsdWVzLm5leHQoe1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIHZhbHVlczogeyAuLi5jb250cm9sLl9mb3JtVmFsdWVzIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBjb250cm9sLl9uYW1lcy5mb2N1cyAmJlxuICAgICAgICAgICAgaXRlcmF0ZUZpZWxkc0J5QWN0aW9uKGNvbnRyb2wuX2ZpZWxkcywgKHJlZiwga2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRyb2wuX25hbWVzLmZvY3VzICYmXG4gICAgICAgICAgICAgICAgICAgIGtleS5zdGFydHNXaXRoKGNvbnRyb2wuX25hbWVzLmZvY3VzKSAmJlxuICAgICAgICAgICAgICAgICAgICByZWYuZm9jdXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVmLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgY29udHJvbC5fbmFtZXMuZm9jdXMgPSAnJztcbiAgICAgICAgY29udHJvbC5fdXBkYXRlVmFsaWQoKTtcbiAgICAgICAgX2FjdGlvbmVkLmN1cnJlbnQgPSBmYWxzZTtcbiAgICB9LCBbZmllbGRzLCBuYW1lLCBjb250cm9sXSk7XG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgIWdldChjb250cm9sLl9mb3JtVmFsdWVzLCBuYW1lKSAmJiBjb250cm9sLl91cGRhdGVGaWVsZEFycmF5KG5hbWUpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgKGNvbnRyb2wuX29wdGlvbnMuc2hvdWxkVW5yZWdpc3RlciB8fCBzaG91bGRVbnJlZ2lzdGVyKSAmJlxuICAgICAgICAgICAgICAgIGNvbnRyb2wudW5yZWdpc3RlcihuYW1lKTtcbiAgICAgICAgfTtcbiAgICB9LCBbbmFtZSwgY29udHJvbCwga2V5TmFtZSwgc2hvdWxkVW5yZWdpc3Rlcl0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIHN3YXA6IFJlYWN0LnVzZUNhbGxiYWNrKHN3YXAsIFt1cGRhdGVWYWx1ZXMsIG5hbWUsIGNvbnRyb2xdKSxcbiAgICAgICAgbW92ZTogUmVhY3QudXNlQ2FsbGJhY2sobW92ZSwgW3VwZGF0ZVZhbHVlcywgbmFtZSwgY29udHJvbF0pLFxuICAgICAgICBwcmVwZW5kOiBSZWFjdC51c2VDYWxsYmFjayhwcmVwZW5kLCBbdXBkYXRlVmFsdWVzLCBuYW1lLCBjb250cm9sXSksXG4gICAgICAgIGFwcGVuZDogUmVhY3QudXNlQ2FsbGJhY2soYXBwZW5kLCBbdXBkYXRlVmFsdWVzLCBuYW1lLCBjb250cm9sXSksXG4gICAgICAgIHJlbW92ZTogUmVhY3QudXNlQ2FsbGJhY2socmVtb3ZlLCBbdXBkYXRlVmFsdWVzLCBuYW1lLCBjb250cm9sXSksXG4gICAgICAgIGluc2VydDogUmVhY3QudXNlQ2FsbGJhY2soaW5zZXJ0JDEsIFt1cGRhdGVWYWx1ZXMsIG5hbWUsIGNvbnRyb2xdKSxcbiAgICAgICAgdXBkYXRlOiBSZWFjdC51c2VDYWxsYmFjayh1cGRhdGUsIFt1cGRhdGVWYWx1ZXMsIG5hbWUsIGNvbnRyb2xdKSxcbiAgICAgICAgcmVwbGFjZTogUmVhY3QudXNlQ2FsbGJhY2socmVwbGFjZSwgW3VwZGF0ZVZhbHVlcywgbmFtZSwgY29udHJvbF0pLFxuICAgICAgICBmaWVsZHM6IFJlYWN0LnVzZU1lbW8oKCkgPT4gZmllbGRzLm1hcCgoZmllbGQsIGluZGV4KSA9PiAoe1xuICAgICAgICAgICAgLi4uZmllbGQsXG4gICAgICAgICAgICBba2V5TmFtZV06IGlkcy5jdXJyZW50W2luZGV4XSB8fCBnZW5lcmF0ZUlkKCksXG4gICAgICAgIH0pKSwgW2ZpZWxkcywga2V5TmFtZV0pLFxuICAgIH07XG59XG5cbnZhciBjcmVhdGVTdWJqZWN0ID0gKCkgPT4ge1xuICAgIGxldCBfb2JzZXJ2ZXJzID0gW107XG4gICAgY29uc3QgbmV4dCA9ICh2YWx1ZSkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IG9ic2VydmVyIG9mIF9vYnNlcnZlcnMpIHtcbiAgICAgICAgICAgIG9ic2VydmVyLm5leHQgJiYgb2JzZXJ2ZXIubmV4dCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHN1YnNjcmliZSA9IChvYnNlcnZlcikgPT4ge1xuICAgICAgICBfb2JzZXJ2ZXJzLnB1c2gob2JzZXJ2ZXIpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdW5zdWJzY3JpYmU6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBfb2JzZXJ2ZXJzID0gX29ic2VydmVycy5maWx0ZXIoKG8pID0+IG8gIT09IG9ic2VydmVyKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBjb25zdCB1bnN1YnNjcmliZSA9ICgpID0+IHtcbiAgICAgICAgX29ic2VydmVycyA9IFtdO1xuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZ2V0IG9ic2VydmVycygpIHtcbiAgICAgICAgICAgIHJldHVybiBfb2JzZXJ2ZXJzO1xuICAgICAgICB9LFxuICAgICAgICBuZXh0LFxuICAgICAgICBzdWJzY3JpYmUsXG4gICAgICAgIHVuc3Vic2NyaWJlLFxuICAgIH07XG59O1xuXG52YXIgaXNQcmltaXRpdmUgPSAodmFsdWUpID0+IGlzTnVsbE9yVW5kZWZpbmVkKHZhbHVlKSB8fCAhaXNPYmplY3RUeXBlKHZhbHVlKTtcblxuZnVuY3Rpb24gZGVlcEVxdWFsKG9iamVjdDEsIG9iamVjdDIpIHtcbiAgICBpZiAoaXNQcmltaXRpdmUob2JqZWN0MSkgfHwgaXNQcmltaXRpdmUob2JqZWN0MikpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdDEgPT09IG9iamVjdDI7XG4gICAgfVxuICAgIGlmIChpc0RhdGVPYmplY3Qob2JqZWN0MSkgJiYgaXNEYXRlT2JqZWN0KG9iamVjdDIpKSB7XG4gICAgICAgIHJldHVybiBvYmplY3QxLmdldFRpbWUoKSA9PT0gb2JqZWN0Mi5nZXRUaW1lKCk7XG4gICAgfVxuICAgIGNvbnN0IGtleXMxID0gT2JqZWN0LmtleXMob2JqZWN0MSk7XG4gICAgY29uc3Qga2V5czIgPSBPYmplY3Qua2V5cyhvYmplY3QyKTtcbiAgICBpZiAoa2V5czEubGVuZ3RoICE9PSBrZXlzMi5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzMSkge1xuICAgICAgICBjb25zdCB2YWwxID0gb2JqZWN0MVtrZXldO1xuICAgICAgICBpZiAoIWtleXMyLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoa2V5ICE9PSAncmVmJykge1xuICAgICAgICAgICAgY29uc3QgdmFsMiA9IG9iamVjdDJba2V5XTtcbiAgICAgICAgICAgIGlmICgoaXNEYXRlT2JqZWN0KHZhbDEpICYmIGlzRGF0ZU9iamVjdCh2YWwyKSkgfHxcbiAgICAgICAgICAgICAgICAoaXNPYmplY3QodmFsMSkgJiYgaXNPYmplY3QodmFsMikpIHx8XG4gICAgICAgICAgICAgICAgKEFycmF5LmlzQXJyYXkodmFsMSkgJiYgQXJyYXkuaXNBcnJheSh2YWwyKSlcbiAgICAgICAgICAgICAgICA/ICFkZWVwRXF1YWwodmFsMSwgdmFsMilcbiAgICAgICAgICAgICAgICA6IHZhbDEgIT09IHZhbDIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbnZhciBpc011bHRpcGxlU2VsZWN0ID0gKGVsZW1lbnQpID0+IGVsZW1lbnQudHlwZSA9PT0gYHNlbGVjdC1tdWx0aXBsZWA7XG5cbnZhciBpc1JhZGlvT3JDaGVja2JveCA9IChyZWYpID0+IGlzUmFkaW9JbnB1dChyZWYpIHx8IGlzQ2hlY2tCb3hJbnB1dChyZWYpO1xuXG52YXIgbGl2ZSA9IChyZWYpID0+IGlzSFRNTEVsZW1lbnQocmVmKSAmJiByZWYuaXNDb25uZWN0ZWQ7XG5cbnZhciBvYmplY3RIYXNGdW5jdGlvbiA9IChkYXRhKSA9PiB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gZGF0YSkge1xuICAgICAgICBpZiAoaXNGdW5jdGlvbihkYXRhW2tleV0pKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5mdW5jdGlvbiBtYXJrRmllbGRzRGlydHkoZGF0YSwgZmllbGRzID0ge30pIHtcbiAgICBjb25zdCBpc1BhcmVudE5vZGVBcnJheSA9IEFycmF5LmlzQXJyYXkoZGF0YSk7XG4gICAgaWYgKGlzT2JqZWN0KGRhdGEpIHx8IGlzUGFyZW50Tm9kZUFycmF5KSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGRhdGEpIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGFba2V5XSkgfHxcbiAgICAgICAgICAgICAgICAoaXNPYmplY3QoZGF0YVtrZXldKSAmJiAhb2JqZWN0SGFzRnVuY3Rpb24oZGF0YVtrZXldKSkpIHtcbiAgICAgICAgICAgICAgICBmaWVsZHNba2V5XSA9IEFycmF5LmlzQXJyYXkoZGF0YVtrZXldKSA/IFtdIDoge307XG4gICAgICAgICAgICAgICAgbWFya0ZpZWxkc0RpcnR5KGRhdGFba2V5XSwgZmllbGRzW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKGRhdGFba2V5XSkpIHtcbiAgICAgICAgICAgICAgICBmaWVsZHNba2V5XSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZpZWxkcztcbn1cbmZ1bmN0aW9uIGdldERpcnR5RmllbGRzRnJvbURlZmF1bHRWYWx1ZXMoZGF0YSwgZm9ybVZhbHVlcywgZGlydHlGaWVsZHNGcm9tVmFsdWVzKSB7XG4gICAgY29uc3QgaXNQYXJlbnROb2RlQXJyYXkgPSBBcnJheS5pc0FycmF5KGRhdGEpO1xuICAgIGlmIChpc09iamVjdChkYXRhKSB8fCBpc1BhcmVudE5vZGVBcnJheSkge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBkYXRhKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhW2tleV0pIHx8XG4gICAgICAgICAgICAgICAgKGlzT2JqZWN0KGRhdGFba2V5XSkgJiYgIW9iamVjdEhhc0Z1bmN0aW9uKGRhdGFba2V5XSkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKGZvcm1WYWx1ZXMpIHx8XG4gICAgICAgICAgICAgICAgICAgIGlzUHJpbWl0aXZlKGRpcnR5RmllbGRzRnJvbVZhbHVlc1trZXldKSkge1xuICAgICAgICAgICAgICAgICAgICBkaXJ0eUZpZWxkc0Zyb21WYWx1ZXNba2V5XSA9IEFycmF5LmlzQXJyYXkoZGF0YVtrZXldKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBtYXJrRmllbGRzRGlydHkoZGF0YVtrZXldLCBbXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogeyAuLi5tYXJrRmllbGRzRGlydHkoZGF0YVtrZXldKSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0RGlydHlGaWVsZHNGcm9tRGVmYXVsdFZhbHVlcyhkYXRhW2tleV0sIGlzTnVsbE9yVW5kZWZpbmVkKGZvcm1WYWx1ZXMpID8ge30gOiBmb3JtVmFsdWVzW2tleV0sIGRpcnR5RmllbGRzRnJvbVZhbHVlc1trZXldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkaXJ0eUZpZWxkc0Zyb21WYWx1ZXNba2V5XSA9ICFkZWVwRXF1YWwoZGF0YVtrZXldLCBmb3JtVmFsdWVzW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkaXJ0eUZpZWxkc0Zyb21WYWx1ZXM7XG59XG52YXIgZ2V0RGlydHlGaWVsZHMgPSAoZGVmYXVsdFZhbHVlcywgZm9ybVZhbHVlcykgPT4gZ2V0RGlydHlGaWVsZHNGcm9tRGVmYXVsdFZhbHVlcyhkZWZhdWx0VmFsdWVzLCBmb3JtVmFsdWVzLCBtYXJrRmllbGRzRGlydHkoZm9ybVZhbHVlcykpO1xuXG52YXIgZ2V0RmllbGRWYWx1ZUFzID0gKHZhbHVlLCB7IHZhbHVlQXNOdW1iZXIsIHZhbHVlQXNEYXRlLCBzZXRWYWx1ZUFzIH0pID0+IGlzVW5kZWZpbmVkKHZhbHVlKVxuICAgID8gdmFsdWVcbiAgICA6IHZhbHVlQXNOdW1iZXJcbiAgICAgICAgPyB2YWx1ZSA9PT0gJydcbiAgICAgICAgICAgID8gTmFOXG4gICAgICAgICAgICA6IHZhbHVlXG4gICAgICAgICAgICAgICAgPyArdmFsdWVcbiAgICAgICAgICAgICAgICA6IHZhbHVlXG4gICAgICAgIDogdmFsdWVBc0RhdGUgJiYgaXNTdHJpbmcodmFsdWUpXG4gICAgICAgICAgICA/IG5ldyBEYXRlKHZhbHVlKVxuICAgICAgICAgICAgOiBzZXRWYWx1ZUFzXG4gICAgICAgICAgICAgICAgPyBzZXRWYWx1ZUFzKHZhbHVlKVxuICAgICAgICAgICAgICAgIDogdmFsdWU7XG5cbmZ1bmN0aW9uIGdldEZpZWxkVmFsdWUoX2YpIHtcbiAgICBjb25zdCByZWYgPSBfZi5yZWY7XG4gICAgaWYgKF9mLnJlZnMgPyBfZi5yZWZzLmV2ZXJ5KChyZWYpID0+IHJlZi5kaXNhYmxlZCkgOiByZWYuZGlzYWJsZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaXNGaWxlSW5wdXQocmVmKSkge1xuICAgICAgICByZXR1cm4gcmVmLmZpbGVzO1xuICAgIH1cbiAgICBpZiAoaXNSYWRpb0lucHV0KHJlZikpIHtcbiAgICAgICAgcmV0dXJuIGdldFJhZGlvVmFsdWUoX2YucmVmcykudmFsdWU7XG4gICAgfVxuICAgIGlmIChpc011bHRpcGxlU2VsZWN0KHJlZikpIHtcbiAgICAgICAgcmV0dXJuIFsuLi5yZWYuc2VsZWN0ZWRPcHRpb25zXS5tYXAoKHsgdmFsdWUgfSkgPT4gdmFsdWUpO1xuICAgIH1cbiAgICBpZiAoaXNDaGVja0JveElucHV0KHJlZikpIHtcbiAgICAgICAgcmV0dXJuIGdldENoZWNrYm94VmFsdWUoX2YucmVmcykudmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBnZXRGaWVsZFZhbHVlQXMoaXNVbmRlZmluZWQocmVmLnZhbHVlKSA/IF9mLnJlZi52YWx1ZSA6IHJlZi52YWx1ZSwgX2YpO1xufVxuXG52YXIgZ2V0UmVzb2x2ZXJPcHRpb25zID0gKGZpZWxkc05hbWVzLCBfZmllbGRzLCBjcml0ZXJpYU1vZGUsIHNob3VsZFVzZU5hdGl2ZVZhbGlkYXRpb24pID0+IHtcbiAgICBjb25zdCBmaWVsZHMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IG5hbWUgb2YgZmllbGRzTmFtZXMpIHtcbiAgICAgICAgY29uc3QgZmllbGQgPSBnZXQoX2ZpZWxkcywgbmFtZSk7XG4gICAgICAgIGZpZWxkICYmIHNldChmaWVsZHMsIG5hbWUsIGZpZWxkLl9mKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY3JpdGVyaWFNb2RlLFxuICAgICAgICBuYW1lczogWy4uLmZpZWxkc05hbWVzXSxcbiAgICAgICAgZmllbGRzLFxuICAgICAgICBzaG91bGRVc2VOYXRpdmVWYWxpZGF0aW9uLFxuICAgIH07XG59O1xuXG52YXIgZ2V0UnVsZVZhbHVlID0gKHJ1bGUpID0+IGlzVW5kZWZpbmVkKHJ1bGUpXG4gICAgPyBydWxlXG4gICAgOiBpc1JlZ2V4KHJ1bGUpXG4gICAgICAgID8gcnVsZS5zb3VyY2VcbiAgICAgICAgOiBpc09iamVjdChydWxlKVxuICAgICAgICAgICAgPyBpc1JlZ2V4KHJ1bGUudmFsdWUpXG4gICAgICAgICAgICAgICAgPyBydWxlLnZhbHVlLnNvdXJjZVxuICAgICAgICAgICAgICAgIDogcnVsZS52YWx1ZVxuICAgICAgICAgICAgOiBydWxlO1xuXG5jb25zdCBBU1lOQ19GVU5DVElPTiA9ICdBc3luY0Z1bmN0aW9uJztcbnZhciBoYXNQcm9taXNlVmFsaWRhdGlvbiA9IChmaWVsZFJlZmVyZW5jZSkgPT4gKCFmaWVsZFJlZmVyZW5jZSB8fCAhZmllbGRSZWZlcmVuY2UudmFsaWRhdGUpICYmXG4gICAgISEoKGlzRnVuY3Rpb24oZmllbGRSZWZlcmVuY2UudmFsaWRhdGUpICYmXG4gICAgICAgIGZpZWxkUmVmZXJlbmNlLnZhbGlkYXRlLmNvbnN0cnVjdG9yLm5hbWUgPT09IEFTWU5DX0ZVTkNUSU9OKSB8fFxuICAgICAgICAoaXNPYmplY3QoZmllbGRSZWZlcmVuY2UudmFsaWRhdGUpICYmXG4gICAgICAgICAgICBPYmplY3QudmFsdWVzKGZpZWxkUmVmZXJlbmNlLnZhbGlkYXRlKS5maW5kKCh2YWxpZGF0ZUZ1bmN0aW9uKSA9PiB2YWxpZGF0ZUZ1bmN0aW9uLmNvbnN0cnVjdG9yLm5hbWUgPT09IEFTWU5DX0ZVTkNUSU9OKSkpO1xuXG52YXIgaGFzVmFsaWRhdGlvbiA9IChvcHRpb25zKSA9PiBvcHRpb25zLm1vdW50ICYmXG4gICAgKG9wdGlvbnMucmVxdWlyZWQgfHxcbiAgICAgICAgb3B0aW9ucy5taW4gfHxcbiAgICAgICAgb3B0aW9ucy5tYXggfHxcbiAgICAgICAgb3B0aW9ucy5tYXhMZW5ndGggfHxcbiAgICAgICAgb3B0aW9ucy5taW5MZW5ndGggfHxcbiAgICAgICAgb3B0aW9ucy5wYXR0ZXJuIHx8XG4gICAgICAgIG9wdGlvbnMudmFsaWRhdGUpO1xuXG5mdW5jdGlvbiBzY2hlbWFFcnJvckxvb2t1cChlcnJvcnMsIF9maWVsZHMsIG5hbWUpIHtcbiAgICBjb25zdCBlcnJvciA9IGdldChlcnJvcnMsIG5hbWUpO1xuICAgIGlmIChlcnJvciB8fCBpc0tleShuYW1lKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBuYW1lcyA9IG5hbWUuc3BsaXQoJy4nKTtcbiAgICB3aGlsZSAobmFtZXMubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkTmFtZSA9IG5hbWVzLmpvaW4oJy4nKTtcbiAgICAgICAgY29uc3QgZmllbGQgPSBnZXQoX2ZpZWxkcywgZmllbGROYW1lKTtcbiAgICAgICAgY29uc3QgZm91bmRFcnJvciA9IGdldChlcnJvcnMsIGZpZWxkTmFtZSk7XG4gICAgICAgIGlmIChmaWVsZCAmJiAhQXJyYXkuaXNBcnJheShmaWVsZCkgJiYgbmFtZSAhPT0gZmllbGROYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4geyBuYW1lIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvdW5kRXJyb3IgJiYgZm91bmRFcnJvci50eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG5hbWU6IGZpZWxkTmFtZSxcbiAgICAgICAgICAgICAgICBlcnJvcjogZm91bmRFcnJvcixcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgbmFtZXMucG9wKCk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIG5hbWUsXG4gICAgfTtcbn1cblxudmFyIHNraXBWYWxpZGF0aW9uID0gKGlzQmx1ckV2ZW50LCBpc1RvdWNoZWQsIGlzU3VibWl0dGVkLCByZVZhbGlkYXRlTW9kZSwgbW9kZSkgPT4ge1xuICAgIGlmIChtb2RlLmlzT25BbGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBlbHNlIGlmICghaXNTdWJtaXR0ZWQgJiYgbW9kZS5pc09uVG91Y2gpIHtcbiAgICAgICAgcmV0dXJuICEoaXNUb3VjaGVkIHx8IGlzQmx1ckV2ZW50KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNTdWJtaXR0ZWQgPyByZVZhbGlkYXRlTW9kZS5pc09uQmx1ciA6IG1vZGUuaXNPbkJsdXIpIHtcbiAgICAgICAgcmV0dXJuICFpc0JsdXJFdmVudDtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNTdWJtaXR0ZWQgPyByZVZhbGlkYXRlTW9kZS5pc09uQ2hhbmdlIDogbW9kZS5pc09uQ2hhbmdlKSB7XG4gICAgICAgIHJldHVybiBpc0JsdXJFdmVudDtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG52YXIgdW5zZXRFbXB0eUFycmF5ID0gKHJlZiwgbmFtZSkgPT4gIWNvbXBhY3QoZ2V0KHJlZiwgbmFtZSkpLmxlbmd0aCAmJiB1bnNldChyZWYsIG5hbWUpO1xuXG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICBtb2RlOiBWQUxJREFUSU9OX01PREUub25TdWJtaXQsXG4gICAgcmVWYWxpZGF0ZU1vZGU6IFZBTElEQVRJT05fTU9ERS5vbkNoYW5nZSxcbiAgICBzaG91bGRGb2N1c0Vycm9yOiB0cnVlLFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUZvcm1Db250cm9sKHByb3BzID0ge30pIHtcbiAgICBsZXQgX29wdGlvbnMgPSB7XG4gICAgICAgIC4uLmRlZmF1bHRPcHRpb25zLFxuICAgICAgICAuLi5wcm9wcyxcbiAgICB9O1xuICAgIGxldCBfZm9ybVN0YXRlID0ge1xuICAgICAgICBzdWJtaXRDb3VudDogMCxcbiAgICAgICAgaXNEaXJ0eTogZmFsc2UsXG4gICAgICAgIGlzTG9hZGluZzogaXNGdW5jdGlvbihfb3B0aW9ucy5kZWZhdWx0VmFsdWVzKSxcbiAgICAgICAgaXNWYWxpZGF0aW5nOiBmYWxzZSxcbiAgICAgICAgaXNTdWJtaXR0ZWQ6IGZhbHNlLFxuICAgICAgICBpc1N1Ym1pdHRpbmc6IGZhbHNlLFxuICAgICAgICBpc1N1Ym1pdFN1Y2Nlc3NmdWw6IGZhbHNlLFxuICAgICAgICBpc1ZhbGlkOiBmYWxzZSxcbiAgICAgICAgdG91Y2hlZEZpZWxkczoge30sXG4gICAgICAgIGRpcnR5RmllbGRzOiB7fSxcbiAgICAgICAgdmFsaWRhdGluZ0ZpZWxkczoge30sXG4gICAgICAgIGVycm9yczogX29wdGlvbnMuZXJyb3JzIHx8IHt9LFxuICAgICAgICBkaXNhYmxlZDogX29wdGlvbnMuZGlzYWJsZWQgfHwgZmFsc2UsXG4gICAgfTtcbiAgICBsZXQgX2ZpZWxkcyA9IHt9O1xuICAgIGxldCBfZGVmYXVsdFZhbHVlcyA9IGlzT2JqZWN0KF9vcHRpb25zLmRlZmF1bHRWYWx1ZXMpIHx8IGlzT2JqZWN0KF9vcHRpb25zLnZhbHVlcylcbiAgICAgICAgPyBjbG9uZU9iamVjdChfb3B0aW9ucy5kZWZhdWx0VmFsdWVzIHx8IF9vcHRpb25zLnZhbHVlcykgfHwge31cbiAgICAgICAgOiB7fTtcbiAgICBsZXQgX2Zvcm1WYWx1ZXMgPSBfb3B0aW9ucy5zaG91bGRVbnJlZ2lzdGVyXG4gICAgICAgID8ge31cbiAgICAgICAgOiBjbG9uZU9iamVjdChfZGVmYXVsdFZhbHVlcyk7XG4gICAgbGV0IF9zdGF0ZSA9IHtcbiAgICAgICAgYWN0aW9uOiBmYWxzZSxcbiAgICAgICAgbW91bnQ6IGZhbHNlLFxuICAgICAgICB3YXRjaDogZmFsc2UsXG4gICAgfTtcbiAgICBsZXQgX25hbWVzID0ge1xuICAgICAgICBtb3VudDogbmV3IFNldCgpLFxuICAgICAgICB1bk1vdW50OiBuZXcgU2V0KCksXG4gICAgICAgIGFycmF5OiBuZXcgU2V0KCksXG4gICAgICAgIHdhdGNoOiBuZXcgU2V0KCksXG4gICAgfTtcbiAgICBsZXQgZGVsYXlFcnJvckNhbGxiYWNrO1xuICAgIGxldCB0aW1lciA9IDA7XG4gICAgY29uc3QgX3Byb3h5Rm9ybVN0YXRlID0ge1xuICAgICAgICBpc0RpcnR5OiBmYWxzZSxcbiAgICAgICAgZGlydHlGaWVsZHM6IGZhbHNlLFxuICAgICAgICB2YWxpZGF0aW5nRmllbGRzOiBmYWxzZSxcbiAgICAgICAgdG91Y2hlZEZpZWxkczogZmFsc2UsXG4gICAgICAgIGlzVmFsaWRhdGluZzogZmFsc2UsXG4gICAgICAgIGlzVmFsaWQ6IGZhbHNlLFxuICAgICAgICBlcnJvcnM6IGZhbHNlLFxuICAgIH07XG4gICAgY29uc3QgX3N1YmplY3RzID0ge1xuICAgICAgICB2YWx1ZXM6IGNyZWF0ZVN1YmplY3QoKSxcbiAgICAgICAgYXJyYXk6IGNyZWF0ZVN1YmplY3QoKSxcbiAgICAgICAgc3RhdGU6IGNyZWF0ZVN1YmplY3QoKSxcbiAgICB9O1xuICAgIGNvbnN0IHZhbGlkYXRpb25Nb2RlQmVmb3JlU3VibWl0ID0gZ2V0VmFsaWRhdGlvbk1vZGVzKF9vcHRpb25zLm1vZGUpO1xuICAgIGNvbnN0IHZhbGlkYXRpb25Nb2RlQWZ0ZXJTdWJtaXQgPSBnZXRWYWxpZGF0aW9uTW9kZXMoX29wdGlvbnMucmVWYWxpZGF0ZU1vZGUpO1xuICAgIGNvbnN0IHNob3VsZERpc3BsYXlBbGxBc3NvY2lhdGVkRXJyb3JzID0gX29wdGlvbnMuY3JpdGVyaWFNb2RlID09PSBWQUxJREFUSU9OX01PREUuYWxsO1xuICAgIGNvbnN0IGRlYm91bmNlID0gKGNhbGxiYWNrKSA9PiAod2FpdCkgPT4ge1xuICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQoY2FsbGJhY2ssIHdhaXQpO1xuICAgIH07XG4gICAgY29uc3QgX3VwZGF0ZVZhbGlkID0gYXN5bmMgKHNob3VsZFVwZGF0ZVZhbGlkKSA9PiB7XG4gICAgICAgIGlmICghX29wdGlvbnMuZGlzYWJsZWQgJiYgKF9wcm94eUZvcm1TdGF0ZS5pc1ZhbGlkIHx8IHNob3VsZFVwZGF0ZVZhbGlkKSkge1xuICAgICAgICAgICAgY29uc3QgaXNWYWxpZCA9IF9vcHRpb25zLnJlc29sdmVyXG4gICAgICAgICAgICAgICAgPyBpc0VtcHR5T2JqZWN0KChhd2FpdCBfZXhlY3V0ZVNjaGVtYSgpKS5lcnJvcnMpXG4gICAgICAgICAgICAgICAgOiBhd2FpdCBleGVjdXRlQnVpbHRJblZhbGlkYXRpb24oX2ZpZWxkcywgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoaXNWYWxpZCAhPT0gX2Zvcm1TdGF0ZS5pc1ZhbGlkKSB7XG4gICAgICAgICAgICAgICAgX3N1YmplY3RzLnN0YXRlLm5leHQoe1xuICAgICAgICAgICAgICAgICAgICBpc1ZhbGlkLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBfdXBkYXRlSXNWYWxpZGF0aW5nID0gKG5hbWVzLCBpc1ZhbGlkYXRpbmcpID0+IHtcbiAgICAgICAgaWYgKCFfb3B0aW9ucy5kaXNhYmxlZCAmJlxuICAgICAgICAgICAgKF9wcm94eUZvcm1TdGF0ZS5pc1ZhbGlkYXRpbmcgfHwgX3Byb3h5Rm9ybVN0YXRlLnZhbGlkYXRpbmdGaWVsZHMpKSB7XG4gICAgICAgICAgICAobmFtZXMgfHwgQXJyYXkuZnJvbShfbmFtZXMubW91bnQpKS5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNWYWxpZGF0aW5nXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHNldChfZm9ybVN0YXRlLnZhbGlkYXRpbmdGaWVsZHMsIG5hbWUsIGlzVmFsaWRhdGluZylcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdW5zZXQoX2Zvcm1TdGF0ZS52YWxpZGF0aW5nRmllbGRzLCBuYW1lKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIF9zdWJqZWN0cy5zdGF0ZS5uZXh0KHtcbiAgICAgICAgICAgICAgICB2YWxpZGF0aW5nRmllbGRzOiBfZm9ybVN0YXRlLnZhbGlkYXRpbmdGaWVsZHMsXG4gICAgICAgICAgICAgICAgaXNWYWxpZGF0aW5nOiAhaXNFbXB0eU9iamVjdChfZm9ybVN0YXRlLnZhbGlkYXRpbmdGaWVsZHMpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IF91cGRhdGVGaWVsZEFycmF5ID0gKG5hbWUsIHZhbHVlcyA9IFtdLCBtZXRob2QsIGFyZ3MsIHNob3VsZFNldFZhbHVlcyA9IHRydWUsIHNob3VsZFVwZGF0ZUZpZWxkc0FuZFN0YXRlID0gdHJ1ZSkgPT4ge1xuICAgICAgICBpZiAoYXJncyAmJiBtZXRob2QgJiYgIV9vcHRpb25zLmRpc2FibGVkKSB7XG4gICAgICAgICAgICBfc3RhdGUuYWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChzaG91bGRVcGRhdGVGaWVsZHNBbmRTdGF0ZSAmJiBBcnJheS5pc0FycmF5KGdldChfZmllbGRzLCBuYW1lKSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWVsZFZhbHVlcyA9IG1ldGhvZChnZXQoX2ZpZWxkcywgbmFtZSksIGFyZ3MuYXJnQSwgYXJncy5hcmdCKTtcbiAgICAgICAgICAgICAgICBzaG91bGRTZXRWYWx1ZXMgJiYgc2V0KF9maWVsZHMsIG5hbWUsIGZpZWxkVmFsdWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzaG91bGRVcGRhdGVGaWVsZHNBbmRTdGF0ZSAmJlxuICAgICAgICAgICAgICAgIEFycmF5LmlzQXJyYXkoZ2V0KF9mb3JtU3RhdGUuZXJyb3JzLCBuYW1lKSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvcnMgPSBtZXRob2QoZ2V0KF9mb3JtU3RhdGUuZXJyb3JzLCBuYW1lKSwgYXJncy5hcmdBLCBhcmdzLmFyZ0IpO1xuICAgICAgICAgICAgICAgIHNob3VsZFNldFZhbHVlcyAmJiBzZXQoX2Zvcm1TdGF0ZS5lcnJvcnMsIG5hbWUsIGVycm9ycyk7XG4gICAgICAgICAgICAgICAgdW5zZXRFbXB0eUFycmF5KF9mb3JtU3RhdGUuZXJyb3JzLCBuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfcHJveHlGb3JtU3RhdGUudG91Y2hlZEZpZWxkcyAmJlxuICAgICAgICAgICAgICAgIHNob3VsZFVwZGF0ZUZpZWxkc0FuZFN0YXRlICYmXG4gICAgICAgICAgICAgICAgQXJyYXkuaXNBcnJheShnZXQoX2Zvcm1TdGF0ZS50b3VjaGVkRmllbGRzLCBuYW1lKSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b3VjaGVkRmllbGRzID0gbWV0aG9kKGdldChfZm9ybVN0YXRlLnRvdWNoZWRGaWVsZHMsIG5hbWUpLCBhcmdzLmFyZ0EsIGFyZ3MuYXJnQik7XG4gICAgICAgICAgICAgICAgc2hvdWxkU2V0VmFsdWVzICYmIHNldChfZm9ybVN0YXRlLnRvdWNoZWRGaWVsZHMsIG5hbWUsIHRvdWNoZWRGaWVsZHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKF9wcm94eUZvcm1TdGF0ZS5kaXJ0eUZpZWxkcykge1xuICAgICAgICAgICAgICAgIF9mb3JtU3RhdGUuZGlydHlGaWVsZHMgPSBnZXREaXJ0eUZpZWxkcyhfZGVmYXVsdFZhbHVlcywgX2Zvcm1WYWx1ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3N1YmplY3RzLnN0YXRlLm5leHQoe1xuICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgaXNEaXJ0eTogX2dldERpcnR5KG5hbWUsIHZhbHVlcyksXG4gICAgICAgICAgICAgICAgZGlydHlGaWVsZHM6IF9mb3JtU3RhdGUuZGlydHlGaWVsZHMsXG4gICAgICAgICAgICAgICAgZXJyb3JzOiBfZm9ybVN0YXRlLmVycm9ycyxcbiAgICAgICAgICAgICAgICBpc1ZhbGlkOiBfZm9ybVN0YXRlLmlzVmFsaWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNldChfZm9ybVZhbHVlcywgbmFtZSwgdmFsdWVzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgdXBkYXRlRXJyb3JzID0gKG5hbWUsIGVycm9yKSA9PiB7XG4gICAgICAgIHNldChfZm9ybVN0YXRlLmVycm9ycywgbmFtZSwgZXJyb3IpO1xuICAgICAgICBfc3ViamVjdHMuc3RhdGUubmV4dCh7XG4gICAgICAgICAgICBlcnJvcnM6IF9mb3JtU3RhdGUuZXJyb3JzLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IF9zZXRFcnJvcnMgPSAoZXJyb3JzKSA9PiB7XG4gICAgICAgIF9mb3JtU3RhdGUuZXJyb3JzID0gZXJyb3JzO1xuICAgICAgICBfc3ViamVjdHMuc3RhdGUubmV4dCh7XG4gICAgICAgICAgICBlcnJvcnM6IF9mb3JtU3RhdGUuZXJyb3JzLFxuICAgICAgICAgICAgaXNWYWxpZDogZmFsc2UsXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgdXBkYXRlVmFsaWRBbmRWYWx1ZSA9IChuYW1lLCBzaG91bGRTa2lwU2V0VmFsdWVBcywgdmFsdWUsIHJlZikgPT4ge1xuICAgICAgICBjb25zdCBmaWVsZCA9IGdldChfZmllbGRzLCBuYW1lKTtcbiAgICAgICAgaWYgKGZpZWxkKSB7XG4gICAgICAgICAgICBjb25zdCBkZWZhdWx0VmFsdWUgPSBnZXQoX2Zvcm1WYWx1ZXMsIG5hbWUsIGlzVW5kZWZpbmVkKHZhbHVlKSA/IGdldChfZGVmYXVsdFZhbHVlcywgbmFtZSkgOiB2YWx1ZSk7XG4gICAgICAgICAgICBpc1VuZGVmaW5lZChkZWZhdWx0VmFsdWUpIHx8XG4gICAgICAgICAgICAgICAgKHJlZiAmJiByZWYuZGVmYXVsdENoZWNrZWQpIHx8XG4gICAgICAgICAgICAgICAgc2hvdWxkU2tpcFNldFZhbHVlQXNcbiAgICAgICAgICAgICAgICA/IHNldChfZm9ybVZhbHVlcywgbmFtZSwgc2hvdWxkU2tpcFNldFZhbHVlQXMgPyBkZWZhdWx0VmFsdWUgOiBnZXRGaWVsZFZhbHVlKGZpZWxkLl9mKSlcbiAgICAgICAgICAgICAgICA6IHNldEZpZWxkVmFsdWUobmFtZSwgZGVmYXVsdFZhbHVlKTtcbiAgICAgICAgICAgIF9zdGF0ZS5tb3VudCAmJiBfdXBkYXRlVmFsaWQoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgdXBkYXRlVG91Y2hBbmREaXJ0eSA9IChuYW1lLCBmaWVsZFZhbHVlLCBpc0JsdXJFdmVudCwgc2hvdWxkRGlydHksIHNob3VsZFJlbmRlcikgPT4ge1xuICAgICAgICBsZXQgc2hvdWxkVXBkYXRlRmllbGQgPSBmYWxzZTtcbiAgICAgICAgbGV0IGlzUHJldmlvdXNEaXJ0eSA9IGZhbHNlO1xuICAgICAgICBjb25zdCBvdXRwdXQgPSB7XG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICB9O1xuICAgICAgICBpZiAoIV9vcHRpb25zLmRpc2FibGVkKSB7XG4gICAgICAgICAgICBjb25zdCBkaXNhYmxlZEZpZWxkID0gISEoZ2V0KF9maWVsZHMsIG5hbWUpICYmXG4gICAgICAgICAgICAgICAgZ2V0KF9maWVsZHMsIG5hbWUpLl9mICYmXG4gICAgICAgICAgICAgICAgZ2V0KF9maWVsZHMsIG5hbWUpLl9mLmRpc2FibGVkKTtcbiAgICAgICAgICAgIGlmICghaXNCbHVyRXZlbnQgfHwgc2hvdWxkRGlydHkpIHtcbiAgICAgICAgICAgICAgICBpZiAoX3Byb3h5Rm9ybVN0YXRlLmlzRGlydHkpIHtcbiAgICAgICAgICAgICAgICAgICAgaXNQcmV2aW91c0RpcnR5ID0gX2Zvcm1TdGF0ZS5pc0RpcnR5O1xuICAgICAgICAgICAgICAgICAgICBfZm9ybVN0YXRlLmlzRGlydHkgPSBvdXRwdXQuaXNEaXJ0eSA9IF9nZXREaXJ0eSgpO1xuICAgICAgICAgICAgICAgICAgICBzaG91bGRVcGRhdGVGaWVsZCA9IGlzUHJldmlvdXNEaXJ0eSAhPT0gb3V0cHV0LmlzRGlydHk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGlzQ3VycmVudEZpZWxkUHJpc3RpbmUgPSBkaXNhYmxlZEZpZWxkIHx8IGRlZXBFcXVhbChnZXQoX2RlZmF1bHRWYWx1ZXMsIG5hbWUpLCBmaWVsZFZhbHVlKTtcbiAgICAgICAgICAgICAgICBpc1ByZXZpb3VzRGlydHkgPSAhISghZGlzYWJsZWRGaWVsZCAmJiBnZXQoX2Zvcm1TdGF0ZS5kaXJ0eUZpZWxkcywgbmFtZSkpO1xuICAgICAgICAgICAgICAgIGlzQ3VycmVudEZpZWxkUHJpc3RpbmUgfHwgZGlzYWJsZWRGaWVsZFxuICAgICAgICAgICAgICAgICAgICA/IHVuc2V0KF9mb3JtU3RhdGUuZGlydHlGaWVsZHMsIG5hbWUpXG4gICAgICAgICAgICAgICAgICAgIDogc2V0KF9mb3JtU3RhdGUuZGlydHlGaWVsZHMsIG5hbWUsIHRydWUpO1xuICAgICAgICAgICAgICAgIG91dHB1dC5kaXJ0eUZpZWxkcyA9IF9mb3JtU3RhdGUuZGlydHlGaWVsZHM7XG4gICAgICAgICAgICAgICAgc2hvdWxkVXBkYXRlRmllbGQgPVxuICAgICAgICAgICAgICAgICAgICBzaG91bGRVcGRhdGVGaWVsZCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKF9wcm94eUZvcm1TdGF0ZS5kaXJ0eUZpZWxkcyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzUHJldmlvdXNEaXJ0eSAhPT0gIWlzQ3VycmVudEZpZWxkUHJpc3RpbmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzQmx1ckV2ZW50KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNQcmV2aW91c0ZpZWxkVG91Y2hlZCA9IGdldChfZm9ybVN0YXRlLnRvdWNoZWRGaWVsZHMsIG5hbWUpO1xuICAgICAgICAgICAgICAgIGlmICghaXNQcmV2aW91c0ZpZWxkVG91Y2hlZCkge1xuICAgICAgICAgICAgICAgICAgICBzZXQoX2Zvcm1TdGF0ZS50b3VjaGVkRmllbGRzLCBuYW1lLCBpc0JsdXJFdmVudCk7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC50b3VjaGVkRmllbGRzID0gX2Zvcm1TdGF0ZS50b3VjaGVkRmllbGRzO1xuICAgICAgICAgICAgICAgICAgICBzaG91bGRVcGRhdGVGaWVsZCA9XG4gICAgICAgICAgICAgICAgICAgICAgICBzaG91bGRVcGRhdGVGaWVsZCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChfcHJveHlGb3JtU3RhdGUudG91Y2hlZEZpZWxkcyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1ByZXZpb3VzRmllbGRUb3VjaGVkICE9PSBpc0JsdXJFdmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2hvdWxkVXBkYXRlRmllbGQgJiYgc2hvdWxkUmVuZGVyICYmIF9zdWJqZWN0cy5zdGF0ZS5uZXh0KG91dHB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNob3VsZFVwZGF0ZUZpZWxkID8gb3V0cHV0IDoge307XG4gICAgfTtcbiAgICBjb25zdCBzaG91bGRSZW5kZXJCeUVycm9yID0gKG5hbWUsIGlzVmFsaWQsIGVycm9yLCBmaWVsZFN0YXRlKSA9PiB7XG4gICAgICAgIGNvbnN0IHByZXZpb3VzRmllbGRFcnJvciA9IGdldChfZm9ybVN0YXRlLmVycm9ycywgbmFtZSk7XG4gICAgICAgIGNvbnN0IHNob3VsZFVwZGF0ZVZhbGlkID0gX3Byb3h5Rm9ybVN0YXRlLmlzVmFsaWQgJiZcbiAgICAgICAgICAgIGlzQm9vbGVhbihpc1ZhbGlkKSAmJlxuICAgICAgICAgICAgX2Zvcm1TdGF0ZS5pc1ZhbGlkICE9PSBpc1ZhbGlkO1xuICAgICAgICBpZiAocHJvcHMuZGVsYXlFcnJvciAmJiBlcnJvcikge1xuICAgICAgICAgICAgZGVsYXlFcnJvckNhbGxiYWNrID0gZGVib3VuY2UoKCkgPT4gdXBkYXRlRXJyb3JzKG5hbWUsIGVycm9yKSk7XG4gICAgICAgICAgICBkZWxheUVycm9yQ2FsbGJhY2socHJvcHMuZGVsYXlFcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICAgICAgZGVsYXlFcnJvckNhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgICAgIGVycm9yXG4gICAgICAgICAgICAgICAgPyBzZXQoX2Zvcm1TdGF0ZS5lcnJvcnMsIG5hbWUsIGVycm9yKVxuICAgICAgICAgICAgICAgIDogdW5zZXQoX2Zvcm1TdGF0ZS5lcnJvcnMsIG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoZXJyb3IgPyAhZGVlcEVxdWFsKHByZXZpb3VzRmllbGRFcnJvciwgZXJyb3IpIDogcHJldmlvdXNGaWVsZEVycm9yKSB8fFxuICAgICAgICAgICAgIWlzRW1wdHlPYmplY3QoZmllbGRTdGF0ZSkgfHxcbiAgICAgICAgICAgIHNob3VsZFVwZGF0ZVZhbGlkKSB7XG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkRm9ybVN0YXRlID0ge1xuICAgICAgICAgICAgICAgIC4uLmZpZWxkU3RhdGUsXG4gICAgICAgICAgICAgICAgLi4uKHNob3VsZFVwZGF0ZVZhbGlkICYmIGlzQm9vbGVhbihpc1ZhbGlkKSA/IHsgaXNWYWxpZCB9IDoge30pLFxuICAgICAgICAgICAgICAgIGVycm9yczogX2Zvcm1TdGF0ZS5lcnJvcnMsXG4gICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBfZm9ybVN0YXRlID0ge1xuICAgICAgICAgICAgICAgIC4uLl9mb3JtU3RhdGUsXG4gICAgICAgICAgICAgICAgLi4udXBkYXRlZEZvcm1TdGF0ZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBfc3ViamVjdHMuc3RhdGUubmV4dCh1cGRhdGVkRm9ybVN0YXRlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgX2V4ZWN1dGVTY2hlbWEgPSBhc3luYyAobmFtZSkgPT4ge1xuICAgICAgICBfdXBkYXRlSXNWYWxpZGF0aW5nKG5hbWUsIHRydWUpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBfb3B0aW9ucy5yZXNvbHZlcihfZm9ybVZhbHVlcywgX29wdGlvbnMuY29udGV4dCwgZ2V0UmVzb2x2ZXJPcHRpb25zKG5hbWUgfHwgX25hbWVzLm1vdW50LCBfZmllbGRzLCBfb3B0aW9ucy5jcml0ZXJpYU1vZGUsIF9vcHRpb25zLnNob3VsZFVzZU5hdGl2ZVZhbGlkYXRpb24pKTtcbiAgICAgICAgX3VwZGF0ZUlzVmFsaWRhdGluZyhuYW1lKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIGNvbnN0IGV4ZWN1dGVTY2hlbWFBbmRVcGRhdGVTdGF0ZSA9IGFzeW5jIChuYW1lcykgPT4ge1xuICAgICAgICBjb25zdCB7IGVycm9ycyB9ID0gYXdhaXQgX2V4ZWN1dGVTY2hlbWEobmFtZXMpO1xuICAgICAgICBpZiAobmFtZXMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBuYW1lcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gZ2V0KGVycm9ycywgbmFtZSk7XG4gICAgICAgICAgICAgICAgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgPyBzZXQoX2Zvcm1TdGF0ZS5lcnJvcnMsIG5hbWUsIGVycm9yKVxuICAgICAgICAgICAgICAgICAgICA6IHVuc2V0KF9mb3JtU3RhdGUuZXJyb3JzLCBuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIF9mb3JtU3RhdGUuZXJyb3JzID0gZXJyb3JzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlcnJvcnM7XG4gICAgfTtcbiAgICBjb25zdCBleGVjdXRlQnVpbHRJblZhbGlkYXRpb24gPSBhc3luYyAoZmllbGRzLCBzaG91bGRPbmx5Q2hlY2tWYWxpZCwgY29udGV4dCA9IHtcbiAgICAgICAgdmFsaWQ6IHRydWUsXG4gICAgfSkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gZmllbGRzKSB7XG4gICAgICAgICAgICBjb25zdCBmaWVsZCA9IGZpZWxkc1tuYW1lXTtcbiAgICAgICAgICAgIGlmIChmaWVsZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgX2YsIC4uLmZpZWxkVmFsdWUgfSA9IGZpZWxkO1xuICAgICAgICAgICAgICAgIGlmIChfZikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpc0ZpZWxkQXJyYXlSb290ID0gX25hbWVzLmFycmF5LmhhcyhfZi5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNQcm9taXNlRnVuY3Rpb24gPSBmaWVsZC5fZiAmJiBoYXNQcm9taXNlVmFsaWRhdGlvbihmaWVsZC5fZik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1Byb21pc2VGdW5jdGlvbiAmJiBfcHJveHlGb3JtU3RhdGUudmFsaWRhdGluZ0ZpZWxkcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3VwZGF0ZUlzVmFsaWRhdGluZyhbbmFtZV0sIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkRXJyb3IgPSBhd2FpdCB2YWxpZGF0ZUZpZWxkKGZpZWxkLCBfZm9ybVZhbHVlcywgc2hvdWxkRGlzcGxheUFsbEFzc29jaWF0ZWRFcnJvcnMsIF9vcHRpb25zLnNob3VsZFVzZU5hdGl2ZVZhbGlkYXRpb24gJiYgIXNob3VsZE9ubHlDaGVja1ZhbGlkLCBpc0ZpZWxkQXJyYXlSb290KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzUHJvbWlzZUZ1bmN0aW9uICYmIF9wcm94eUZvcm1TdGF0ZS52YWxpZGF0aW5nRmllbGRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdXBkYXRlSXNWYWxpZGF0aW5nKFtuYW1lXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGZpZWxkRXJyb3JbX2YubmFtZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQudmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaG91bGRPbmx5Q2hlY2tWYWxpZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICFzaG91bGRPbmx5Q2hlY2tWYWxpZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKGdldChmaWVsZEVycm9yLCBfZi5uYW1lKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gaXNGaWVsZEFycmF5Um9vdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHVwZGF0ZUZpZWxkQXJyYXlSb290RXJyb3IoX2Zvcm1TdGF0ZS5lcnJvcnMsIGZpZWxkRXJyb3IsIF9mLm5hbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogc2V0KF9mb3JtU3RhdGUuZXJyb3JzLCBfZi5uYW1lLCBmaWVsZEVycm9yW19mLm5hbWVdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdW5zZXQoX2Zvcm1TdGF0ZS5lcnJvcnMsIF9mLm5hbWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgIWlzRW1wdHlPYmplY3QoZmllbGRWYWx1ZSkgJiZcbiAgICAgICAgICAgICAgICAgICAgKGF3YWl0IGV4ZWN1dGVCdWlsdEluVmFsaWRhdGlvbihmaWVsZFZhbHVlLCBzaG91bGRPbmx5Q2hlY2tWYWxpZCwgY29udGV4dCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb250ZXh0LnZhbGlkO1xuICAgIH07XG4gICAgY29uc3QgX3JlbW92ZVVubW91bnRlZCA9ICgpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIG9mIF9uYW1lcy51bk1vdW50KSB7XG4gICAgICAgICAgICBjb25zdCBmaWVsZCA9IGdldChfZmllbGRzLCBuYW1lKTtcbiAgICAgICAgICAgIGZpZWxkICYmXG4gICAgICAgICAgICAgICAgKGZpZWxkLl9mLnJlZnNcbiAgICAgICAgICAgICAgICAgICAgPyBmaWVsZC5fZi5yZWZzLmV2ZXJ5KChyZWYpID0+ICFsaXZlKHJlZikpXG4gICAgICAgICAgICAgICAgICAgIDogIWxpdmUoZmllbGQuX2YucmVmKSkgJiZcbiAgICAgICAgICAgICAgICB1bnJlZ2lzdGVyKG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIF9uYW1lcy51bk1vdW50ID0gbmV3IFNldCgpO1xuICAgIH07XG4gICAgY29uc3QgX2dldERpcnR5ID0gKG5hbWUsIGRhdGEpID0+ICFfb3B0aW9ucy5kaXNhYmxlZCAmJlxuICAgICAgICAobmFtZSAmJiBkYXRhICYmIHNldChfZm9ybVZhbHVlcywgbmFtZSwgZGF0YSksXG4gICAgICAgICAgICAhZGVlcEVxdWFsKGdldFZhbHVlcygpLCBfZGVmYXVsdFZhbHVlcykpO1xuICAgIGNvbnN0IF9nZXRXYXRjaCA9IChuYW1lcywgZGVmYXVsdFZhbHVlLCBpc0dsb2JhbCkgPT4gZ2VuZXJhdGVXYXRjaE91dHB1dChuYW1lcywgX25hbWVzLCB7XG4gICAgICAgIC4uLihfc3RhdGUubW91bnRcbiAgICAgICAgICAgID8gX2Zvcm1WYWx1ZXNcbiAgICAgICAgICAgIDogaXNVbmRlZmluZWQoZGVmYXVsdFZhbHVlKVxuICAgICAgICAgICAgICAgID8gX2RlZmF1bHRWYWx1ZXNcbiAgICAgICAgICAgICAgICA6IGlzU3RyaW5nKG5hbWVzKVxuICAgICAgICAgICAgICAgICAgICA/IHsgW25hbWVzXTogZGVmYXVsdFZhbHVlIH1cbiAgICAgICAgICAgICAgICAgICAgOiBkZWZhdWx0VmFsdWUpLFxuICAgIH0sIGlzR2xvYmFsLCBkZWZhdWx0VmFsdWUpO1xuICAgIGNvbnN0IF9nZXRGaWVsZEFycmF5ID0gKG5hbWUpID0+IGNvbXBhY3QoZ2V0KF9zdGF0ZS5tb3VudCA/IF9mb3JtVmFsdWVzIDogX2RlZmF1bHRWYWx1ZXMsIG5hbWUsIHByb3BzLnNob3VsZFVucmVnaXN0ZXIgPyBnZXQoX2RlZmF1bHRWYWx1ZXMsIG5hbWUsIFtdKSA6IFtdKSk7XG4gICAgY29uc3Qgc2V0RmllbGRWYWx1ZSA9IChuYW1lLCB2YWx1ZSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgIGNvbnN0IGZpZWxkID0gZ2V0KF9maWVsZHMsIG5hbWUpO1xuICAgICAgICBsZXQgZmllbGRWYWx1ZSA9IHZhbHVlO1xuICAgICAgICBpZiAoZmllbGQpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkUmVmZXJlbmNlID0gZmllbGQuX2Y7XG4gICAgICAgICAgICBpZiAoZmllbGRSZWZlcmVuY2UpIHtcbiAgICAgICAgICAgICAgICAhZmllbGRSZWZlcmVuY2UuZGlzYWJsZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgc2V0KF9mb3JtVmFsdWVzLCBuYW1lLCBnZXRGaWVsZFZhbHVlQXModmFsdWUsIGZpZWxkUmVmZXJlbmNlKSk7XG4gICAgICAgICAgICAgICAgZmllbGRWYWx1ZSA9XG4gICAgICAgICAgICAgICAgICAgIGlzSFRNTEVsZW1lbnQoZmllbGRSZWZlcmVuY2UucmVmKSAmJiBpc051bGxPclVuZGVmaW5lZCh2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgID8gJydcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKGlzTXVsdGlwbGVTZWxlY3QoZmllbGRSZWZlcmVuY2UucmVmKSkge1xuICAgICAgICAgICAgICAgICAgICBbLi4uZmllbGRSZWZlcmVuY2UucmVmLm9wdGlvbnNdLmZvckVhY2goKG9wdGlvblJlZikgPT4gKG9wdGlvblJlZi5zZWxlY3RlZCA9IGZpZWxkVmFsdWUuaW5jbHVkZXMob3B0aW9uUmVmLnZhbHVlKSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmaWVsZFJlZmVyZW5jZS5yZWZzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc0NoZWNrQm94SW5wdXQoZmllbGRSZWZlcmVuY2UucmVmKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmllbGRSZWZlcmVuY2UucmVmcy5sZW5ndGggPiAxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBmaWVsZFJlZmVyZW5jZS5yZWZzLmZvckVhY2goKGNoZWNrYm94UmVmKSA9PiAoIWNoZWNrYm94UmVmLmRlZmF1bHRDaGVja2VkIHx8ICFjaGVja2JveFJlZi5kaXNhYmxlZCkgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGNoZWNrYm94UmVmLmNoZWNrZWQgPSBBcnJheS5pc0FycmF5KGZpZWxkVmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/ICEhZmllbGRWYWx1ZS5maW5kKChkYXRhKSA9PiBkYXRhID09PSBjaGVja2JveFJlZi52YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogZmllbGRWYWx1ZSA9PT0gY2hlY2tib3hSZWYudmFsdWUpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogZmllbGRSZWZlcmVuY2UucmVmc1swXSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZmllbGRSZWZlcmVuY2UucmVmc1swXS5jaGVja2VkID0gISFmaWVsZFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkUmVmZXJlbmNlLnJlZnMuZm9yRWFjaCgocmFkaW9SZWYpID0+IChyYWRpb1JlZi5jaGVja2VkID0gcmFkaW9SZWYudmFsdWUgPT09IGZpZWxkVmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChpc0ZpbGVJbnB1dChmaWVsZFJlZmVyZW5jZS5yZWYpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkUmVmZXJlbmNlLnJlZi52YWx1ZSA9ICcnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGRSZWZlcmVuY2UucmVmLnZhbHVlID0gZmllbGRWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmaWVsZFJlZmVyZW5jZS5yZWYudHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3N1YmplY3RzLnZhbHVlcy5uZXh0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlczogeyAuLi5fZm9ybVZhbHVlcyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgKG9wdGlvbnMuc2hvdWxkRGlydHkgfHwgb3B0aW9ucy5zaG91bGRUb3VjaCkgJiZcbiAgICAgICAgICAgIHVwZGF0ZVRvdWNoQW5kRGlydHkobmFtZSwgZmllbGRWYWx1ZSwgb3B0aW9ucy5zaG91bGRUb3VjaCwgb3B0aW9ucy5zaG91bGREaXJ0eSwgdHJ1ZSk7XG4gICAgICAgIG9wdGlvbnMuc2hvdWxkVmFsaWRhdGUgJiYgdHJpZ2dlcihuYW1lKTtcbiAgICB9O1xuICAgIGNvbnN0IHNldFZhbHVlcyA9IChuYW1lLCB2YWx1ZSwgb3B0aW9ucykgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IGZpZWxkS2V5IGluIHZhbHVlKSB7XG4gICAgICAgICAgICBjb25zdCBmaWVsZFZhbHVlID0gdmFsdWVbZmllbGRLZXldO1xuICAgICAgICAgICAgY29uc3QgZmllbGROYW1lID0gYCR7bmFtZX0uJHtmaWVsZEtleX1gO1xuICAgICAgICAgICAgY29uc3QgZmllbGQgPSBnZXQoX2ZpZWxkcywgZmllbGROYW1lKTtcbiAgICAgICAgICAgIChfbmFtZXMuYXJyYXkuaGFzKG5hbWUpIHx8XG4gICAgICAgICAgICAgICAgaXNPYmplY3QoZmllbGRWYWx1ZSkgfHxcbiAgICAgICAgICAgICAgICAoZmllbGQgJiYgIWZpZWxkLl9mKSkgJiZcbiAgICAgICAgICAgICAgICAhaXNEYXRlT2JqZWN0KGZpZWxkVmFsdWUpXG4gICAgICAgICAgICAgICAgPyBzZXRWYWx1ZXMoZmllbGROYW1lLCBmaWVsZFZhbHVlLCBvcHRpb25zKVxuICAgICAgICAgICAgICAgIDogc2V0RmllbGRWYWx1ZShmaWVsZE5hbWUsIGZpZWxkVmFsdWUsIG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBzZXRWYWx1ZSA9IChuYW1lLCB2YWx1ZSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgIGNvbnN0IGZpZWxkID0gZ2V0KF9maWVsZHMsIG5hbWUpO1xuICAgICAgICBjb25zdCBpc0ZpZWxkQXJyYXkgPSBfbmFtZXMuYXJyYXkuaGFzKG5hbWUpO1xuICAgICAgICBjb25zdCBjbG9uZVZhbHVlID0gY2xvbmVPYmplY3QodmFsdWUpO1xuICAgICAgICBzZXQoX2Zvcm1WYWx1ZXMsIG5hbWUsIGNsb25lVmFsdWUpO1xuICAgICAgICBpZiAoaXNGaWVsZEFycmF5KSB7XG4gICAgICAgICAgICBfc3ViamVjdHMuYXJyYXkubmV4dCh7XG4gICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICB2YWx1ZXM6IHsgLi4uX2Zvcm1WYWx1ZXMgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKChfcHJveHlGb3JtU3RhdGUuaXNEaXJ0eSB8fCBfcHJveHlGb3JtU3RhdGUuZGlydHlGaWVsZHMpICYmXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5zaG91bGREaXJ0eSkge1xuICAgICAgICAgICAgICAgIF9zdWJqZWN0cy5zdGF0ZS5uZXh0KHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZGlydHlGaWVsZHM6IGdldERpcnR5RmllbGRzKF9kZWZhdWx0VmFsdWVzLCBfZm9ybVZhbHVlcyksXG4gICAgICAgICAgICAgICAgICAgIGlzRGlydHk6IF9nZXREaXJ0eShuYW1lLCBjbG9uZVZhbHVlKSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZpZWxkICYmICFmaWVsZC5fZiAmJiAhaXNOdWxsT3JVbmRlZmluZWQoY2xvbmVWYWx1ZSlcbiAgICAgICAgICAgICAgICA/IHNldFZhbHVlcyhuYW1lLCBjbG9uZVZhbHVlLCBvcHRpb25zKVxuICAgICAgICAgICAgICAgIDogc2V0RmllbGRWYWx1ZShuYW1lLCBjbG9uZVZhbHVlLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBpc1dhdGNoZWQobmFtZSwgX25hbWVzKSAmJiBfc3ViamVjdHMuc3RhdGUubmV4dCh7IC4uLl9mb3JtU3RhdGUgfSk7XG4gICAgICAgIF9zdWJqZWN0cy52YWx1ZXMubmV4dCh7XG4gICAgICAgICAgICBuYW1lOiBfc3RhdGUubW91bnQgPyBuYW1lIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgdmFsdWVzOiB7IC4uLl9mb3JtVmFsdWVzIH0sXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3Qgb25DaGFuZ2UgPSBhc3luYyAoZXZlbnQpID0+IHtcbiAgICAgICAgX3N0YXRlLm1vdW50ID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0O1xuICAgICAgICBsZXQgbmFtZSA9IHRhcmdldC5uYW1lO1xuICAgICAgICBsZXQgaXNGaWVsZFZhbHVlVXBkYXRlZCA9IHRydWU7XG4gICAgICAgIGNvbnN0IGZpZWxkID0gZ2V0KF9maWVsZHMsIG5hbWUpO1xuICAgICAgICBjb25zdCBnZXRDdXJyZW50RmllbGRWYWx1ZSA9ICgpID0+IHRhcmdldC50eXBlID8gZ2V0RmllbGRWYWx1ZShmaWVsZC5fZikgOiBnZXRFdmVudFZhbHVlKGV2ZW50KTtcbiAgICAgICAgY29uc3QgX3VwZGF0ZUlzRmllbGRWYWx1ZVVwZGF0ZWQgPSAoZmllbGRWYWx1ZSkgPT4ge1xuICAgICAgICAgICAgaXNGaWVsZFZhbHVlVXBkYXRlZCA9XG4gICAgICAgICAgICAgICAgTnVtYmVyLmlzTmFOKGZpZWxkVmFsdWUpIHx8XG4gICAgICAgICAgICAgICAgICAgIChpc0RhdGVPYmplY3QoZmllbGRWYWx1ZSkgJiYgaXNOYU4oZmllbGRWYWx1ZS5nZXRUaW1lKCkpKSB8fFxuICAgICAgICAgICAgICAgICAgICBkZWVwRXF1YWwoZmllbGRWYWx1ZSwgZ2V0KF9mb3JtVmFsdWVzLCBuYW1lLCBmaWVsZFZhbHVlKSk7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChmaWVsZCkge1xuICAgICAgICAgICAgbGV0IGVycm9yO1xuICAgICAgICAgICAgbGV0IGlzVmFsaWQ7XG4gICAgICAgICAgICBjb25zdCBmaWVsZFZhbHVlID0gZ2V0Q3VycmVudEZpZWxkVmFsdWUoKTtcbiAgICAgICAgICAgIGNvbnN0IGlzQmx1ckV2ZW50ID0gZXZlbnQudHlwZSA9PT0gRVZFTlRTLkJMVVIgfHwgZXZlbnQudHlwZSA9PT0gRVZFTlRTLkZPQ1VTX09VVDtcbiAgICAgICAgICAgIGNvbnN0IHNob3VsZFNraXBWYWxpZGF0aW9uID0gKCFoYXNWYWxpZGF0aW9uKGZpZWxkLl9mKSAmJlxuICAgICAgICAgICAgICAgICFfb3B0aW9ucy5yZXNvbHZlciAmJlxuICAgICAgICAgICAgICAgICFnZXQoX2Zvcm1TdGF0ZS5lcnJvcnMsIG5hbWUpICYmXG4gICAgICAgICAgICAgICAgIWZpZWxkLl9mLmRlcHMpIHx8XG4gICAgICAgICAgICAgICAgc2tpcFZhbGlkYXRpb24oaXNCbHVyRXZlbnQsIGdldChfZm9ybVN0YXRlLnRvdWNoZWRGaWVsZHMsIG5hbWUpLCBfZm9ybVN0YXRlLmlzU3VibWl0dGVkLCB2YWxpZGF0aW9uTW9kZUFmdGVyU3VibWl0LCB2YWxpZGF0aW9uTW9kZUJlZm9yZVN1Ym1pdCk7XG4gICAgICAgICAgICBjb25zdCB3YXRjaGVkID0gaXNXYXRjaGVkKG5hbWUsIF9uYW1lcywgaXNCbHVyRXZlbnQpO1xuICAgICAgICAgICAgc2V0KF9mb3JtVmFsdWVzLCBuYW1lLCBmaWVsZFZhbHVlKTtcbiAgICAgICAgICAgIGlmIChpc0JsdXJFdmVudCkge1xuICAgICAgICAgICAgICAgIGZpZWxkLl9mLm9uQmx1ciAmJiBmaWVsZC5fZi5vbkJsdXIoZXZlbnQpO1xuICAgICAgICAgICAgICAgIGRlbGF5RXJyb3JDYWxsYmFjayAmJiBkZWxheUVycm9yQ2FsbGJhY2soMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChmaWVsZC5fZi5vbkNoYW5nZSkge1xuICAgICAgICAgICAgICAgIGZpZWxkLl9mLm9uQ2hhbmdlKGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGZpZWxkU3RhdGUgPSB1cGRhdGVUb3VjaEFuZERpcnR5KG5hbWUsIGZpZWxkVmFsdWUsIGlzQmx1ckV2ZW50LCBmYWxzZSk7XG4gICAgICAgICAgICBjb25zdCBzaG91bGRSZW5kZXIgPSAhaXNFbXB0eU9iamVjdChmaWVsZFN0YXRlKSB8fCB3YXRjaGVkO1xuICAgICAgICAgICAgIWlzQmx1ckV2ZW50ICYmXG4gICAgICAgICAgICAgICAgX3N1YmplY3RzLnZhbHVlcy5uZXh0KHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogZXZlbnQudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzOiB7IC4uLl9mb3JtVmFsdWVzIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoc2hvdWxkU2tpcFZhbGlkYXRpb24pIHtcbiAgICAgICAgICAgICAgICBpZiAoX3Byb3h5Rm9ybVN0YXRlLmlzVmFsaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BzLm1vZGUgPT09ICdvbkJsdXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNCbHVyRXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdXBkYXRlVmFsaWQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF91cGRhdGVWYWxpZCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAoc2hvdWxkUmVuZGVyICYmXG4gICAgICAgICAgICAgICAgICAgIF9zdWJqZWN0cy5zdGF0ZS5uZXh0KHsgbmFtZSwgLi4uKHdhdGNoZWQgPyB7fSA6IGZpZWxkU3RhdGUpIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICFpc0JsdXJFdmVudCAmJiB3YXRjaGVkICYmIF9zdWJqZWN0cy5zdGF0ZS5uZXh0KHsgLi4uX2Zvcm1TdGF0ZSB9KTtcbiAgICAgICAgICAgIGlmIChfb3B0aW9ucy5yZXNvbHZlcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZXJyb3JzIH0gPSBhd2FpdCBfZXhlY3V0ZVNjaGVtYShbbmFtZV0pO1xuICAgICAgICAgICAgICAgIF91cGRhdGVJc0ZpZWxkVmFsdWVVcGRhdGVkKGZpZWxkVmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChpc0ZpZWxkVmFsdWVVcGRhdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzRXJyb3JMb29rdXBSZXN1bHQgPSBzY2hlbWFFcnJvckxvb2t1cChfZm9ybVN0YXRlLmVycm9ycywgX2ZpZWxkcywgbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yTG9va3VwUmVzdWx0ID0gc2NoZW1hRXJyb3JMb29rdXAoZXJyb3JzLCBfZmllbGRzLCBwcmV2aW91c0Vycm9yTG9va3VwUmVzdWx0Lm5hbWUgfHwgbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yID0gZXJyb3JMb29rdXBSZXN1bHQuZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSBlcnJvckxvb2t1cFJlc3VsdC5uYW1lO1xuICAgICAgICAgICAgICAgICAgICBpc1ZhbGlkID0gaXNFbXB0eU9iamVjdChlcnJvcnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIF91cGRhdGVJc1ZhbGlkYXRpbmcoW25hbWVdLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBlcnJvciA9IChhd2FpdCB2YWxpZGF0ZUZpZWxkKGZpZWxkLCBfZm9ybVZhbHVlcywgc2hvdWxkRGlzcGxheUFsbEFzc29jaWF0ZWRFcnJvcnMsIF9vcHRpb25zLnNob3VsZFVzZU5hdGl2ZVZhbGlkYXRpb24pKVtuYW1lXTtcbiAgICAgICAgICAgICAgICBfdXBkYXRlSXNWYWxpZGF0aW5nKFtuYW1lXSk7XG4gICAgICAgICAgICAgICAgX3VwZGF0ZUlzRmllbGRWYWx1ZVVwZGF0ZWQoZmllbGRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKGlzRmllbGRWYWx1ZVVwZGF0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc1ZhbGlkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoX3Byb3h5Rm9ybVN0YXRlLmlzVmFsaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzVmFsaWQgPSBhd2FpdCBleGVjdXRlQnVpbHRJblZhbGlkYXRpb24oX2ZpZWxkcywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNGaWVsZFZhbHVlVXBkYXRlZCkge1xuICAgICAgICAgICAgICAgIGZpZWxkLl9mLmRlcHMgJiZcbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlcihmaWVsZC5fZi5kZXBzKTtcbiAgICAgICAgICAgICAgICBzaG91bGRSZW5kZXJCeUVycm9yKG5hbWUsIGlzVmFsaWQsIGVycm9yLCBmaWVsZFN0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgX2ZvY3VzSW5wdXQgPSAocmVmLCBrZXkpID0+IHtcbiAgICAgICAgaWYgKGdldChfZm9ybVN0YXRlLmVycm9ycywga2V5KSAmJiByZWYuZm9jdXMpIHtcbiAgICAgICAgICAgIHJlZi5mb2N1cygpO1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH07XG4gICAgY29uc3QgdHJpZ2dlciA9IGFzeW5jIChuYW1lLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgbGV0IGlzVmFsaWQ7XG4gICAgICAgIGxldCB2YWxpZGF0aW9uUmVzdWx0O1xuICAgICAgICBjb25zdCBmaWVsZE5hbWVzID0gY29udmVydFRvQXJyYXlQYXlsb2FkKG5hbWUpO1xuICAgICAgICBpZiAoX29wdGlvbnMucmVzb2x2ZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9ycyA9IGF3YWl0IGV4ZWN1dGVTY2hlbWFBbmRVcGRhdGVTdGF0ZShpc1VuZGVmaW5lZChuYW1lKSA/IG5hbWUgOiBmaWVsZE5hbWVzKTtcbiAgICAgICAgICAgIGlzVmFsaWQgPSBpc0VtcHR5T2JqZWN0KGVycm9ycyk7XG4gICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0ID0gbmFtZVxuICAgICAgICAgICAgICAgID8gIWZpZWxkTmFtZXMuc29tZSgobmFtZSkgPT4gZ2V0KGVycm9ycywgbmFtZSkpXG4gICAgICAgICAgICAgICAgOiBpc1ZhbGlkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5hbWUpIHtcbiAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQgPSAoYXdhaXQgUHJvbWlzZS5hbGwoZmllbGROYW1lcy5tYXAoYXN5bmMgKGZpZWxkTmFtZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkID0gZ2V0KF9maWVsZHMsIGZpZWxkTmFtZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGV4ZWN1dGVCdWlsdEluVmFsaWRhdGlvbihmaWVsZCAmJiBmaWVsZC5fZiA/IHsgW2ZpZWxkTmFtZV06IGZpZWxkIH0gOiBmaWVsZCk7XG4gICAgICAgICAgICB9KSkpLmV2ZXJ5KEJvb2xlYW4pO1xuICAgICAgICAgICAgISghdmFsaWRhdGlvblJlc3VsdCAmJiAhX2Zvcm1TdGF0ZS5pc1ZhbGlkKSAmJiBfdXBkYXRlVmFsaWQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQgPSBpc1ZhbGlkID0gYXdhaXQgZXhlY3V0ZUJ1aWx0SW5WYWxpZGF0aW9uKF9maWVsZHMpO1xuICAgICAgICB9XG4gICAgICAgIF9zdWJqZWN0cy5zdGF0ZS5uZXh0KHtcbiAgICAgICAgICAgIC4uLighaXNTdHJpbmcobmFtZSkgfHxcbiAgICAgICAgICAgICAgICAoX3Byb3h5Rm9ybVN0YXRlLmlzVmFsaWQgJiYgaXNWYWxpZCAhPT0gX2Zvcm1TdGF0ZS5pc1ZhbGlkKVxuICAgICAgICAgICAgICAgID8ge31cbiAgICAgICAgICAgICAgICA6IHsgbmFtZSB9KSxcbiAgICAgICAgICAgIC4uLihfb3B0aW9ucy5yZXNvbHZlciB8fCAhbmFtZSA/IHsgaXNWYWxpZCB9IDoge30pLFxuICAgICAgICAgICAgZXJyb3JzOiBfZm9ybVN0YXRlLmVycm9ycyxcbiAgICAgICAgfSk7XG4gICAgICAgIG9wdGlvbnMuc2hvdWxkRm9jdXMgJiZcbiAgICAgICAgICAgICF2YWxpZGF0aW9uUmVzdWx0ICYmXG4gICAgICAgICAgICBpdGVyYXRlRmllbGRzQnlBY3Rpb24oX2ZpZWxkcywgX2ZvY3VzSW5wdXQsIG5hbWUgPyBmaWVsZE5hbWVzIDogX25hbWVzLm1vdW50KTtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRpb25SZXN1bHQ7XG4gICAgfTtcbiAgICBjb25zdCBnZXRWYWx1ZXMgPSAoZmllbGROYW1lcykgPT4ge1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSB7XG4gICAgICAgICAgICAuLi4oX3N0YXRlLm1vdW50ID8gX2Zvcm1WYWx1ZXMgOiBfZGVmYXVsdFZhbHVlcyksXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBpc1VuZGVmaW5lZChmaWVsZE5hbWVzKVxuICAgICAgICAgICAgPyB2YWx1ZXNcbiAgICAgICAgICAgIDogaXNTdHJpbmcoZmllbGROYW1lcylcbiAgICAgICAgICAgICAgICA/IGdldCh2YWx1ZXMsIGZpZWxkTmFtZXMpXG4gICAgICAgICAgICAgICAgOiBmaWVsZE5hbWVzLm1hcCgobmFtZSkgPT4gZ2V0KHZhbHVlcywgbmFtZSkpO1xuICAgIH07XG4gICAgY29uc3QgZ2V0RmllbGRTdGF0ZSA9IChuYW1lLCBmb3JtU3RhdGUpID0+ICh7XG4gICAgICAgIGludmFsaWQ6ICEhZ2V0KChmb3JtU3RhdGUgfHwgX2Zvcm1TdGF0ZSkuZXJyb3JzLCBuYW1lKSxcbiAgICAgICAgaXNEaXJ0eTogISFnZXQoKGZvcm1TdGF0ZSB8fCBfZm9ybVN0YXRlKS5kaXJ0eUZpZWxkcywgbmFtZSksXG4gICAgICAgIGVycm9yOiBnZXQoKGZvcm1TdGF0ZSB8fCBfZm9ybVN0YXRlKS5lcnJvcnMsIG5hbWUpLFxuICAgICAgICBpc1ZhbGlkYXRpbmc6ICEhZ2V0KF9mb3JtU3RhdGUudmFsaWRhdGluZ0ZpZWxkcywgbmFtZSksXG4gICAgICAgIGlzVG91Y2hlZDogISFnZXQoKGZvcm1TdGF0ZSB8fCBfZm9ybVN0YXRlKS50b3VjaGVkRmllbGRzLCBuYW1lKSxcbiAgICB9KTtcbiAgICBjb25zdCBjbGVhckVycm9ycyA9IChuYW1lKSA9PiB7XG4gICAgICAgIG5hbWUgJiZcbiAgICAgICAgICAgIGNvbnZlcnRUb0FycmF5UGF5bG9hZChuYW1lKS5mb3JFYWNoKChpbnB1dE5hbWUpID0+IHVuc2V0KF9mb3JtU3RhdGUuZXJyb3JzLCBpbnB1dE5hbWUpKTtcbiAgICAgICAgX3N1YmplY3RzLnN0YXRlLm5leHQoe1xuICAgICAgICAgICAgZXJyb3JzOiBuYW1lID8gX2Zvcm1TdGF0ZS5lcnJvcnMgOiB7fSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBzZXRFcnJvciA9IChuYW1lLCBlcnJvciwgb3B0aW9ucykgPT4ge1xuICAgICAgICBjb25zdCByZWYgPSAoZ2V0KF9maWVsZHMsIG5hbWUsIHsgX2Y6IHt9IH0pLl9mIHx8IHt9KS5yZWY7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRFcnJvciA9IGdldChfZm9ybVN0YXRlLmVycm9ycywgbmFtZSkgfHwge307XG4gICAgICAgIC8vIERvbid0IG92ZXJyaWRlIGV4aXN0aW5nIGVycm9yIG1lc3NhZ2VzIGVsc2V3aGVyZSBpbiB0aGUgb2JqZWN0IHRyZWUuXG4gICAgICAgIGNvbnN0IHsgcmVmOiBjdXJyZW50UmVmLCBtZXNzYWdlLCB0eXBlLCAuLi5yZXN0T2ZFcnJvclRyZWUgfSA9IGN1cnJlbnRFcnJvcjtcbiAgICAgICAgc2V0KF9mb3JtU3RhdGUuZXJyb3JzLCBuYW1lLCB7XG4gICAgICAgICAgICAuLi5yZXN0T2ZFcnJvclRyZWUsXG4gICAgICAgICAgICAuLi5lcnJvcixcbiAgICAgICAgICAgIHJlZixcbiAgICAgICAgfSk7XG4gICAgICAgIF9zdWJqZWN0cy5zdGF0ZS5uZXh0KHtcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICBlcnJvcnM6IF9mb3JtU3RhdGUuZXJyb3JzLFxuICAgICAgICAgICAgaXNWYWxpZDogZmFsc2UsXG4gICAgICAgIH0pO1xuICAgICAgICBvcHRpb25zICYmIG9wdGlvbnMuc2hvdWxkRm9jdXMgJiYgcmVmICYmIHJlZi5mb2N1cyAmJiByZWYuZm9jdXMoKTtcbiAgICB9O1xuICAgIGNvbnN0IHdhdGNoID0gKG5hbWUsIGRlZmF1bHRWYWx1ZSkgPT4gaXNGdW5jdGlvbihuYW1lKVxuICAgICAgICA/IF9zdWJqZWN0cy52YWx1ZXMuc3Vic2NyaWJlKHtcbiAgICAgICAgICAgIG5leHQ6IChwYXlsb2FkKSA9PiBuYW1lKF9nZXRXYXRjaCh1bmRlZmluZWQsIGRlZmF1bHRWYWx1ZSksIHBheWxvYWQpLFxuICAgICAgICB9KVxuICAgICAgICA6IF9nZXRXYXRjaChuYW1lLCBkZWZhdWx0VmFsdWUsIHRydWUpO1xuICAgIGNvbnN0IHVucmVnaXN0ZXIgPSAobmFtZSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgZmllbGROYW1lIG9mIG5hbWUgPyBjb252ZXJ0VG9BcnJheVBheWxvYWQobmFtZSkgOiBfbmFtZXMubW91bnQpIHtcbiAgICAgICAgICAgIF9uYW1lcy5tb3VudC5kZWxldGUoZmllbGROYW1lKTtcbiAgICAgICAgICAgIF9uYW1lcy5hcnJheS5kZWxldGUoZmllbGROYW1lKTtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5rZWVwVmFsdWUpIHtcbiAgICAgICAgICAgICAgICB1bnNldChfZmllbGRzLCBmaWVsZE5hbWUpO1xuICAgICAgICAgICAgICAgIHVuc2V0KF9mb3JtVmFsdWVzLCBmaWVsZE5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgIW9wdGlvbnMua2VlcEVycm9yICYmIHVuc2V0KF9mb3JtU3RhdGUuZXJyb3JzLCBmaWVsZE5hbWUpO1xuICAgICAgICAgICAgIW9wdGlvbnMua2VlcERpcnR5ICYmIHVuc2V0KF9mb3JtU3RhdGUuZGlydHlGaWVsZHMsIGZpZWxkTmFtZSk7XG4gICAgICAgICAgICAhb3B0aW9ucy5rZWVwVG91Y2hlZCAmJiB1bnNldChfZm9ybVN0YXRlLnRvdWNoZWRGaWVsZHMsIGZpZWxkTmFtZSk7XG4gICAgICAgICAgICAhb3B0aW9ucy5rZWVwSXNWYWxpZGF0aW5nICYmXG4gICAgICAgICAgICAgICAgdW5zZXQoX2Zvcm1TdGF0ZS52YWxpZGF0aW5nRmllbGRzLCBmaWVsZE5hbWUpO1xuICAgICAgICAgICAgIV9vcHRpb25zLnNob3VsZFVucmVnaXN0ZXIgJiZcbiAgICAgICAgICAgICAgICAhb3B0aW9ucy5rZWVwRGVmYXVsdFZhbHVlICYmXG4gICAgICAgICAgICAgICAgdW5zZXQoX2RlZmF1bHRWYWx1ZXMsIGZpZWxkTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgX3N1YmplY3RzLnZhbHVlcy5uZXh0KHtcbiAgICAgICAgICAgIHZhbHVlczogeyAuLi5fZm9ybVZhbHVlcyB9LFxuICAgICAgICB9KTtcbiAgICAgICAgX3N1YmplY3RzLnN0YXRlLm5leHQoe1xuICAgICAgICAgICAgLi4uX2Zvcm1TdGF0ZSxcbiAgICAgICAgICAgIC4uLighb3B0aW9ucy5rZWVwRGlydHkgPyB7fSA6IHsgaXNEaXJ0eTogX2dldERpcnR5KCkgfSksXG4gICAgICAgIH0pO1xuICAgICAgICAhb3B0aW9ucy5rZWVwSXNWYWxpZCAmJiBfdXBkYXRlVmFsaWQoKTtcbiAgICB9O1xuICAgIGNvbnN0IF91cGRhdGVEaXNhYmxlZEZpZWxkID0gKHsgZGlzYWJsZWQsIG5hbWUsIGZpZWxkLCBmaWVsZHMsIHZhbHVlLCB9KSA9PiB7XG4gICAgICAgIGlmICgoaXNCb29sZWFuKGRpc2FibGVkKSAmJiBfc3RhdGUubW91bnQpIHx8ICEhZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGlucHV0VmFsdWUgPSBkaXNhYmxlZFxuICAgICAgICAgICAgICAgID8gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgOiBpc1VuZGVmaW5lZCh2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgPyBnZXRGaWVsZFZhbHVlKGZpZWxkID8gZmllbGQuX2YgOiBnZXQoZmllbGRzLCBuYW1lKS5fZilcbiAgICAgICAgICAgICAgICAgICAgOiB2YWx1ZTtcbiAgICAgICAgICAgIHNldChfZm9ybVZhbHVlcywgbmFtZSwgaW5wdXRWYWx1ZSk7XG4gICAgICAgICAgICB1cGRhdGVUb3VjaEFuZERpcnR5KG5hbWUsIGlucHV0VmFsdWUsIGZhbHNlLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHJlZ2lzdGVyID0gKG5hbWUsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICBsZXQgZmllbGQgPSBnZXQoX2ZpZWxkcywgbmFtZSk7XG4gICAgICAgIGNvbnN0IGRpc2FibGVkSXNEZWZpbmVkID0gaXNCb29sZWFuKG9wdGlvbnMuZGlzYWJsZWQpIHx8IGlzQm9vbGVhbihfb3B0aW9ucy5kaXNhYmxlZCk7XG4gICAgICAgIHNldChfZmllbGRzLCBuYW1lLCB7XG4gICAgICAgICAgICAuLi4oZmllbGQgfHwge30pLFxuICAgICAgICAgICAgX2Y6IHtcbiAgICAgICAgICAgICAgICAuLi4oZmllbGQgJiYgZmllbGQuX2YgPyBmaWVsZC5fZiA6IHsgcmVmOiB7IG5hbWUgfSB9KSxcbiAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgIG1vdW50OiB0cnVlLFxuICAgICAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgX25hbWVzLm1vdW50LmFkZChuYW1lKTtcbiAgICAgICAgaWYgKGZpZWxkKSB7XG4gICAgICAgICAgICBfdXBkYXRlRGlzYWJsZWRGaWVsZCh7XG4gICAgICAgICAgICAgICAgZmllbGQsXG4gICAgICAgICAgICAgICAgZGlzYWJsZWQ6IGlzQm9vbGVhbihvcHRpb25zLmRpc2FibGVkKVxuICAgICAgICAgICAgICAgICAgICA/IG9wdGlvbnMuZGlzYWJsZWRcbiAgICAgICAgICAgICAgICAgICAgOiBfb3B0aW9ucy5kaXNhYmxlZCxcbiAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBvcHRpb25zLnZhbHVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB1cGRhdGVWYWxpZEFuZFZhbHVlKG5hbWUsIHRydWUsIG9wdGlvbnMudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi4oZGlzYWJsZWRJc0RlZmluZWRcbiAgICAgICAgICAgICAgICA/IHsgZGlzYWJsZWQ6IG9wdGlvbnMuZGlzYWJsZWQgfHwgX29wdGlvbnMuZGlzYWJsZWQgfVxuICAgICAgICAgICAgICAgIDoge30pLFxuICAgICAgICAgICAgLi4uKF9vcHRpb25zLnByb2dyZXNzaXZlXG4gICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVpcmVkOiAhIW9wdGlvbnMucmVxdWlyZWQsXG4gICAgICAgICAgICAgICAgICAgIG1pbjogZ2V0UnVsZVZhbHVlKG9wdGlvbnMubWluKSxcbiAgICAgICAgICAgICAgICAgICAgbWF4OiBnZXRSdWxlVmFsdWUob3B0aW9ucy5tYXgpLFxuICAgICAgICAgICAgICAgICAgICBtaW5MZW5ndGg6IGdldFJ1bGVWYWx1ZShvcHRpb25zLm1pbkxlbmd0aCksXG4gICAgICAgICAgICAgICAgICAgIG1heExlbmd0aDogZ2V0UnVsZVZhbHVlKG9wdGlvbnMubWF4TGVuZ3RoKSxcbiAgICAgICAgICAgICAgICAgICAgcGF0dGVybjogZ2V0UnVsZVZhbHVlKG9wdGlvbnMucGF0dGVybiksXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDoge30pLFxuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIG9uQ2hhbmdlLFxuICAgICAgICAgICAgb25CbHVyOiBvbkNoYW5nZSxcbiAgICAgICAgICAgIHJlZjogKHJlZikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChyZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVnaXN0ZXIobmFtZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkID0gZ2V0KF9maWVsZHMsIG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmaWVsZFJlZiA9IGlzVW5kZWZpbmVkKHJlZi52YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgID8gcmVmLnF1ZXJ5U2VsZWN0b3JBbGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHJlZi5xdWVyeVNlbGVjdG9yQWxsKCdpbnB1dCxzZWxlY3QsdGV4dGFyZWEnKVswXSB8fCByZWZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHJlZlxuICAgICAgICAgICAgICAgICAgICAgICAgOiByZWY7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJhZGlvT3JDaGVja2JveCA9IGlzUmFkaW9PckNoZWNrYm94KGZpZWxkUmVmKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVmcyA9IGZpZWxkLl9mLnJlZnMgfHwgW107XG4gICAgICAgICAgICAgICAgICAgIGlmIChyYWRpb09yQ2hlY2tib3hcbiAgICAgICAgICAgICAgICAgICAgICAgID8gcmVmcy5maW5kKChvcHRpb24pID0+IG9wdGlvbiA9PT0gZmllbGRSZWYpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IGZpZWxkUmVmID09PSBmaWVsZC5fZi5yZWYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZXQoX2ZpZWxkcywgbmFtZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2Y6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi5maWVsZC5fZixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAuLi4ocmFkaW9PckNoZWNrYm94XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVmczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLnJlZnMuZmlsdGVyKGxpdmUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkUmVmLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLihBcnJheS5pc0FycmF5KGdldChfZGVmYXVsdFZhbHVlcywgbmFtZSkpID8gW3t9XSA6IFtdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWY6IHsgdHlwZTogZmllbGRSZWYudHlwZSwgbmFtZSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogeyByZWY6IGZpZWxkUmVmIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZVZhbGlkQW5kVmFsdWUobmFtZSwgZmFsc2UsIHVuZGVmaW5lZCwgZmllbGRSZWYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZmllbGQgPSBnZXQoX2ZpZWxkcywgbmFtZSwge30pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmllbGQuX2YpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpZWxkLl9mLm1vdW50ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgKF9vcHRpb25zLnNob3VsZFVucmVnaXN0ZXIgfHwgb3B0aW9ucy5zaG91bGRVbnJlZ2lzdGVyKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgIShpc05hbWVJbkZpZWxkQXJyYXkoX25hbWVzLmFycmF5LCBuYW1lKSAmJiBfc3RhdGUuYWN0aW9uKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgX25hbWVzLnVuTW91bnQuYWRkKG5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBjb25zdCBfZm9jdXNFcnJvciA9ICgpID0+IF9vcHRpb25zLnNob3VsZEZvY3VzRXJyb3IgJiZcbiAgICAgICAgaXRlcmF0ZUZpZWxkc0J5QWN0aW9uKF9maWVsZHMsIF9mb2N1c0lucHV0LCBfbmFtZXMubW91bnQpO1xuICAgIGNvbnN0IF9kaXNhYmxlRm9ybSA9IChkaXNhYmxlZCkgPT4ge1xuICAgICAgICBpZiAoaXNCb29sZWFuKGRpc2FibGVkKSkge1xuICAgICAgICAgICAgX3N1YmplY3RzLnN0YXRlLm5leHQoeyBkaXNhYmxlZCB9KTtcbiAgICAgICAgICAgIGl0ZXJhdGVGaWVsZHNCeUFjdGlvbihfZmllbGRzLCAocmVmLCBuYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudEZpZWxkID0gZ2V0KF9maWVsZHMsIG5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50RmllbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVmLmRpc2FibGVkID0gY3VycmVudEZpZWxkLl9mLmRpc2FibGVkIHx8IGRpc2FibGVkO1xuICAgICAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjdXJyZW50RmllbGQuX2YucmVmcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRGaWVsZC5fZi5yZWZzLmZvckVhY2goKGlucHV0UmVmKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXRSZWYuZGlzYWJsZWQgPSBjdXJyZW50RmllbGQuX2YuZGlzYWJsZWQgfHwgZGlzYWJsZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIDAsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgaGFuZGxlU3VibWl0ID0gKG9uVmFsaWQsIG9uSW52YWxpZCkgPT4gYXN5bmMgKGUpID0+IHtcbiAgICAgICAgbGV0IG9uVmFsaWRFcnJvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKGUpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQgJiYgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZS5wZXJzaXN0ICYmIGUucGVyc2lzdCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChfb3B0aW9ucy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgaWYgKG9uSW52YWxpZCkge1xuICAgICAgICAgICAgICAgIGF3YWl0IG9uSW52YWxpZCh7IC4uLl9mb3JtU3RhdGUuZXJyb3JzIH0sIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBmaWVsZFZhbHVlcyA9IGNsb25lT2JqZWN0KF9mb3JtVmFsdWVzKTtcbiAgICAgICAgX3N1YmplY3RzLnN0YXRlLm5leHQoe1xuICAgICAgICAgICAgaXNTdWJtaXR0aW5nOiB0cnVlLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKF9vcHRpb25zLnJlc29sdmVyKSB7XG4gICAgICAgICAgICBjb25zdCB7IGVycm9ycywgdmFsdWVzIH0gPSBhd2FpdCBfZXhlY3V0ZVNjaGVtYSgpO1xuICAgICAgICAgICAgX2Zvcm1TdGF0ZS5lcnJvcnMgPSBlcnJvcnM7XG4gICAgICAgICAgICBmaWVsZFZhbHVlcyA9IHZhbHVlcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGF3YWl0IGV4ZWN1dGVCdWlsdEluVmFsaWRhdGlvbihfZmllbGRzKTtcbiAgICAgICAgfVxuICAgICAgICB1bnNldChfZm9ybVN0YXRlLmVycm9ycywgJ3Jvb3QnKTtcbiAgICAgICAgaWYgKGlzRW1wdHlPYmplY3QoX2Zvcm1TdGF0ZS5lcnJvcnMpKSB7XG4gICAgICAgICAgICBfc3ViamVjdHMuc3RhdGUubmV4dCh7XG4gICAgICAgICAgICAgICAgZXJyb3JzOiB7fSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBhd2FpdCBvblZhbGlkKGZpZWxkVmFsdWVzLCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIG9uVmFsaWRFcnJvciA9IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKG9uSW52YWxpZCkge1xuICAgICAgICAgICAgICAgIGF3YWl0IG9uSW52YWxpZCh7IC4uLl9mb3JtU3RhdGUuZXJyb3JzIH0sIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX2ZvY3VzRXJyb3IoKTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoX2ZvY3VzRXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIF9zdWJqZWN0cy5zdGF0ZS5uZXh0KHtcbiAgICAgICAgICAgIGlzU3VibWl0dGVkOiB0cnVlLFxuICAgICAgICAgICAgaXNTdWJtaXR0aW5nOiBmYWxzZSxcbiAgICAgICAgICAgIGlzU3VibWl0U3VjY2Vzc2Z1bDogaXNFbXB0eU9iamVjdChfZm9ybVN0YXRlLmVycm9ycykgJiYgIW9uVmFsaWRFcnJvcixcbiAgICAgICAgICAgIHN1Ym1pdENvdW50OiBfZm9ybVN0YXRlLnN1Ym1pdENvdW50ICsgMSxcbiAgICAgICAgICAgIGVycm9yczogX2Zvcm1TdGF0ZS5lcnJvcnMsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAob25WYWxpZEVycm9yKSB7XG4gICAgICAgICAgICB0aHJvdyBvblZhbGlkRXJyb3I7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHJlc2V0RmllbGQgPSAobmFtZSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgIGlmIChnZXQoX2ZpZWxkcywgbmFtZSkpIHtcbiAgICAgICAgICAgIGlmIChpc1VuZGVmaW5lZChvcHRpb25zLmRlZmF1bHRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBzZXRWYWx1ZShuYW1lLCBjbG9uZU9iamVjdChnZXQoX2RlZmF1bHRWYWx1ZXMsIG5hbWUpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZXRWYWx1ZShuYW1lLCBvcHRpb25zLmRlZmF1bHRWYWx1ZSk7XG4gICAgICAgICAgICAgICAgc2V0KF9kZWZhdWx0VmFsdWVzLCBuYW1lLCBjbG9uZU9iamVjdChvcHRpb25zLmRlZmF1bHRWYWx1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFvcHRpb25zLmtlZXBUb3VjaGVkKSB7XG4gICAgICAgICAgICAgICAgdW5zZXQoX2Zvcm1TdGF0ZS50b3VjaGVkRmllbGRzLCBuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5rZWVwRGlydHkpIHtcbiAgICAgICAgICAgICAgICB1bnNldChfZm9ybVN0YXRlLmRpcnR5RmllbGRzLCBuYW1lKTtcbiAgICAgICAgICAgICAgICBfZm9ybVN0YXRlLmlzRGlydHkgPSBvcHRpb25zLmRlZmF1bHRWYWx1ZVxuICAgICAgICAgICAgICAgICAgICA/IF9nZXREaXJ0eShuYW1lLCBjbG9uZU9iamVjdChnZXQoX2RlZmF1bHRWYWx1ZXMsIG5hbWUpKSlcbiAgICAgICAgICAgICAgICAgICAgOiBfZ2V0RGlydHkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5rZWVwRXJyb3IpIHtcbiAgICAgICAgICAgICAgICB1bnNldChfZm9ybVN0YXRlLmVycm9ycywgbmFtZSk7XG4gICAgICAgICAgICAgICAgX3Byb3h5Rm9ybVN0YXRlLmlzVmFsaWQgJiYgX3VwZGF0ZVZhbGlkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfc3ViamVjdHMuc3RhdGUubmV4dCh7IC4uLl9mb3JtU3RhdGUgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IF9yZXNldCA9IChmb3JtVmFsdWVzLCBrZWVwU3RhdGVPcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgY29uc3QgdXBkYXRlZFZhbHVlcyA9IGZvcm1WYWx1ZXMgPyBjbG9uZU9iamVjdChmb3JtVmFsdWVzKSA6IF9kZWZhdWx0VmFsdWVzO1xuICAgICAgICBjb25zdCBjbG9uZVVwZGF0ZWRWYWx1ZXMgPSBjbG9uZU9iamVjdCh1cGRhdGVkVmFsdWVzKTtcbiAgICAgICAgY29uc3QgaXNFbXB0eVJlc2V0VmFsdWVzID0gaXNFbXB0eU9iamVjdChmb3JtVmFsdWVzKTtcbiAgICAgICAgY29uc3QgdmFsdWVzID0gaXNFbXB0eVJlc2V0VmFsdWVzID8gX2RlZmF1bHRWYWx1ZXMgOiBjbG9uZVVwZGF0ZWRWYWx1ZXM7XG4gICAgICAgIGlmICgha2VlcFN0YXRlT3B0aW9ucy5rZWVwRGVmYXVsdFZhbHVlcykge1xuICAgICAgICAgICAgX2RlZmF1bHRWYWx1ZXMgPSB1cGRhdGVkVmFsdWVzO1xuICAgICAgICB9XG4gICAgICAgIGlmICgha2VlcFN0YXRlT3B0aW9ucy5rZWVwVmFsdWVzKSB7XG4gICAgICAgICAgICBpZiAoa2VlcFN0YXRlT3B0aW9ucy5rZWVwRGlydHlWYWx1ZXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWVsZHNUb0NoZWNrID0gbmV3IFNldChbXG4gICAgICAgICAgICAgICAgICAgIC4uLl9uYW1lcy5tb3VudCxcbiAgICAgICAgICAgICAgICAgICAgLi4uT2JqZWN0LmtleXMoZ2V0RGlydHlGaWVsZHMoX2RlZmF1bHRWYWx1ZXMsIF9mb3JtVmFsdWVzKSksXG4gICAgICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBmaWVsZE5hbWUgb2YgQXJyYXkuZnJvbShmaWVsZHNUb0NoZWNrKSkge1xuICAgICAgICAgICAgICAgICAgICBnZXQoX2Zvcm1TdGF0ZS5kaXJ0eUZpZWxkcywgZmllbGROYW1lKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBzZXQodmFsdWVzLCBmaWVsZE5hbWUsIGdldChfZm9ybVZhbHVlcywgZmllbGROYW1lKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogc2V0VmFsdWUoZmllbGROYW1lLCBnZXQodmFsdWVzLCBmaWVsZE5hbWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNXZWIgJiYgaXNVbmRlZmluZWQoZm9ybVZhbHVlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBuYW1lIG9mIF9uYW1lcy5tb3VudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZmllbGQgPSBnZXQoX2ZpZWxkcywgbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmllbGQgJiYgZmllbGQuX2YpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmaWVsZFJlZmVyZW5jZSA9IEFycmF5LmlzQXJyYXkoZmllbGQuX2YucmVmcylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBmaWVsZC5fZi5yZWZzWzBdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogZmllbGQuX2YucmVmO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0hUTUxFbGVtZW50KGZpZWxkUmVmZXJlbmNlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmb3JtID0gZmllbGRSZWZlcmVuY2UuY2xvc2VzdCgnZm9ybScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZm9ybSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9ybS5yZXNldCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX2ZpZWxkcyA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX2Zvcm1WYWx1ZXMgPSBwcm9wcy5zaG91bGRVbnJlZ2lzdGVyXG4gICAgICAgICAgICAgICAgPyBrZWVwU3RhdGVPcHRpb25zLmtlZXBEZWZhdWx0VmFsdWVzXG4gICAgICAgICAgICAgICAgICAgID8gY2xvbmVPYmplY3QoX2RlZmF1bHRWYWx1ZXMpXG4gICAgICAgICAgICAgICAgICAgIDoge31cbiAgICAgICAgICAgICAgICA6IGNsb25lT2JqZWN0KHZhbHVlcyk7XG4gICAgICAgICAgICBfc3ViamVjdHMuYXJyYXkubmV4dCh7XG4gICAgICAgICAgICAgICAgdmFsdWVzOiB7IC4uLnZhbHVlcyB9LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBfc3ViamVjdHMudmFsdWVzLm5leHQoe1xuICAgICAgICAgICAgICAgIHZhbHVlczogeyAuLi52YWx1ZXMgfSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIF9uYW1lcyA9IHtcbiAgICAgICAgICAgIG1vdW50OiBrZWVwU3RhdGVPcHRpb25zLmtlZXBEaXJ0eVZhbHVlcyA/IF9uYW1lcy5tb3VudCA6IG5ldyBTZXQoKSxcbiAgICAgICAgICAgIHVuTW91bnQ6IG5ldyBTZXQoKSxcbiAgICAgICAgICAgIGFycmF5OiBuZXcgU2V0KCksXG4gICAgICAgICAgICB3YXRjaDogbmV3IFNldCgpLFxuICAgICAgICAgICAgd2F0Y2hBbGw6IGZhbHNlLFxuICAgICAgICAgICAgZm9jdXM6ICcnLFxuICAgICAgICB9O1xuICAgICAgICBfc3RhdGUubW91bnQgPVxuICAgICAgICAgICAgIV9wcm94eUZvcm1TdGF0ZS5pc1ZhbGlkIHx8XG4gICAgICAgICAgICAgICAgISFrZWVwU3RhdGVPcHRpb25zLmtlZXBJc1ZhbGlkIHx8XG4gICAgICAgICAgICAgICAgISFrZWVwU3RhdGVPcHRpb25zLmtlZXBEaXJ0eVZhbHVlcztcbiAgICAgICAgX3N0YXRlLndhdGNoID0gISFwcm9wcy5zaG91bGRVbnJlZ2lzdGVyO1xuICAgICAgICBfc3ViamVjdHMuc3RhdGUubmV4dCh7XG4gICAgICAgICAgICBzdWJtaXRDb3VudDoga2VlcFN0YXRlT3B0aW9ucy5rZWVwU3VibWl0Q291bnRcbiAgICAgICAgICAgICAgICA/IF9mb3JtU3RhdGUuc3VibWl0Q291bnRcbiAgICAgICAgICAgICAgICA6IDAsXG4gICAgICAgICAgICBpc0RpcnR5OiBpc0VtcHR5UmVzZXRWYWx1ZXNcbiAgICAgICAgICAgICAgICA/IGZhbHNlXG4gICAgICAgICAgICAgICAgOiBrZWVwU3RhdGVPcHRpb25zLmtlZXBEaXJ0eVxuICAgICAgICAgICAgICAgICAgICA/IF9mb3JtU3RhdGUuaXNEaXJ0eVxuICAgICAgICAgICAgICAgICAgICA6ICEhKGtlZXBTdGF0ZU9wdGlvbnMua2VlcERlZmF1bHRWYWx1ZXMgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICFkZWVwRXF1YWwoZm9ybVZhbHVlcywgX2RlZmF1bHRWYWx1ZXMpKSxcbiAgICAgICAgICAgIGlzU3VibWl0dGVkOiBrZWVwU3RhdGVPcHRpb25zLmtlZXBJc1N1Ym1pdHRlZFxuICAgICAgICAgICAgICAgID8gX2Zvcm1TdGF0ZS5pc1N1Ym1pdHRlZFxuICAgICAgICAgICAgICAgIDogZmFsc2UsXG4gICAgICAgICAgICBkaXJ0eUZpZWxkczogaXNFbXB0eVJlc2V0VmFsdWVzXG4gICAgICAgICAgICAgICAgPyB7fVxuICAgICAgICAgICAgICAgIDoga2VlcFN0YXRlT3B0aW9ucy5rZWVwRGlydHlWYWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgPyBrZWVwU3RhdGVPcHRpb25zLmtlZXBEZWZhdWx0VmFsdWVzICYmIF9mb3JtVmFsdWVzXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGdldERpcnR5RmllbGRzKF9kZWZhdWx0VmFsdWVzLCBfZm9ybVZhbHVlcylcbiAgICAgICAgICAgICAgICAgICAgICAgIDogX2Zvcm1TdGF0ZS5kaXJ0eUZpZWxkc1xuICAgICAgICAgICAgICAgICAgICA6IGtlZXBTdGF0ZU9wdGlvbnMua2VlcERlZmF1bHRWYWx1ZXMgJiYgZm9ybVZhbHVlc1xuICAgICAgICAgICAgICAgICAgICAgICAgPyBnZXREaXJ0eUZpZWxkcyhfZGVmYXVsdFZhbHVlcywgZm9ybVZhbHVlcylcbiAgICAgICAgICAgICAgICAgICAgICAgIDoga2VlcFN0YXRlT3B0aW9ucy5rZWVwRGlydHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IF9mb3JtU3RhdGUuZGlydHlGaWVsZHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHt9LFxuICAgICAgICAgICAgdG91Y2hlZEZpZWxkczoga2VlcFN0YXRlT3B0aW9ucy5rZWVwVG91Y2hlZFxuICAgICAgICAgICAgICAgID8gX2Zvcm1TdGF0ZS50b3VjaGVkRmllbGRzXG4gICAgICAgICAgICAgICAgOiB7fSxcbiAgICAgICAgICAgIGVycm9yczoga2VlcFN0YXRlT3B0aW9ucy5rZWVwRXJyb3JzID8gX2Zvcm1TdGF0ZS5lcnJvcnMgOiB7fSxcbiAgICAgICAgICAgIGlzU3VibWl0U3VjY2Vzc2Z1bDoga2VlcFN0YXRlT3B0aW9ucy5rZWVwSXNTdWJtaXRTdWNjZXNzZnVsXG4gICAgICAgICAgICAgICAgPyBfZm9ybVN0YXRlLmlzU3VibWl0U3VjY2Vzc2Z1bFxuICAgICAgICAgICAgICAgIDogZmFsc2UsXG4gICAgICAgICAgICBpc1N1Ym1pdHRpbmc6IGZhbHNlLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IHJlc2V0ID0gKGZvcm1WYWx1ZXMsIGtlZXBTdGF0ZU9wdGlvbnMpID0+IF9yZXNldChpc0Z1bmN0aW9uKGZvcm1WYWx1ZXMpXG4gICAgICAgID8gZm9ybVZhbHVlcyhfZm9ybVZhbHVlcylcbiAgICAgICAgOiBmb3JtVmFsdWVzLCBrZWVwU3RhdGVPcHRpb25zKTtcbiAgICBjb25zdCBzZXRGb2N1cyA9IChuYW1lLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgY29uc3QgZmllbGQgPSBnZXQoX2ZpZWxkcywgbmFtZSk7XG4gICAgICAgIGNvbnN0IGZpZWxkUmVmZXJlbmNlID0gZmllbGQgJiYgZmllbGQuX2Y7XG4gICAgICAgIGlmIChmaWVsZFJlZmVyZW5jZSkge1xuICAgICAgICAgICAgY29uc3QgZmllbGRSZWYgPSBmaWVsZFJlZmVyZW5jZS5yZWZzXG4gICAgICAgICAgICAgICAgPyBmaWVsZFJlZmVyZW5jZS5yZWZzWzBdXG4gICAgICAgICAgICAgICAgOiBmaWVsZFJlZmVyZW5jZS5yZWY7XG4gICAgICAgICAgICBpZiAoZmllbGRSZWYuZm9jdXMpIHtcbiAgICAgICAgICAgICAgICBmaWVsZFJlZi5mb2N1cygpO1xuICAgICAgICAgICAgICAgIG9wdGlvbnMuc2hvdWxkU2VsZWN0ICYmXG4gICAgICAgICAgICAgICAgICAgIGlzRnVuY3Rpb24oZmllbGRSZWYuc2VsZWN0KSAmJlxuICAgICAgICAgICAgICAgICAgICBmaWVsZFJlZi5zZWxlY3QoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgX3VwZGF0ZUZvcm1TdGF0ZSA9ICh1cGRhdGVkRm9ybVN0YXRlKSA9PiB7XG4gICAgICAgIF9mb3JtU3RhdGUgPSB7XG4gICAgICAgICAgICAuLi5fZm9ybVN0YXRlLFxuICAgICAgICAgICAgLi4udXBkYXRlZEZvcm1TdGF0ZSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IF9yZXNldERlZmF1bHRWYWx1ZXMgPSAoKSA9PiBpc0Z1bmN0aW9uKF9vcHRpb25zLmRlZmF1bHRWYWx1ZXMpICYmXG4gICAgICAgIF9vcHRpb25zLmRlZmF1bHRWYWx1ZXMoKS50aGVuKCh2YWx1ZXMpID0+IHtcbiAgICAgICAgICAgIHJlc2V0KHZhbHVlcywgX29wdGlvbnMucmVzZXRPcHRpb25zKTtcbiAgICAgICAgICAgIF9zdWJqZWN0cy5zdGF0ZS5uZXh0KHtcbiAgICAgICAgICAgICAgICBpc0xvYWRpbmc6IGZhbHNlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIGNvbnRyb2w6IHtcbiAgICAgICAgICAgIHJlZ2lzdGVyLFxuICAgICAgICAgICAgdW5yZWdpc3RlcixcbiAgICAgICAgICAgIGdldEZpZWxkU3RhdGUsXG4gICAgICAgICAgICBoYW5kbGVTdWJtaXQsXG4gICAgICAgICAgICBzZXRFcnJvcixcbiAgICAgICAgICAgIF9leGVjdXRlU2NoZW1hLFxuICAgICAgICAgICAgX2dldFdhdGNoLFxuICAgICAgICAgICAgX2dldERpcnR5LFxuICAgICAgICAgICAgX3VwZGF0ZVZhbGlkLFxuICAgICAgICAgICAgX3JlbW92ZVVubW91bnRlZCxcbiAgICAgICAgICAgIF91cGRhdGVGaWVsZEFycmF5LFxuICAgICAgICAgICAgX3VwZGF0ZURpc2FibGVkRmllbGQsXG4gICAgICAgICAgICBfZ2V0RmllbGRBcnJheSxcbiAgICAgICAgICAgIF9yZXNldCxcbiAgICAgICAgICAgIF9yZXNldERlZmF1bHRWYWx1ZXMsXG4gICAgICAgICAgICBfdXBkYXRlRm9ybVN0YXRlLFxuICAgICAgICAgICAgX2Rpc2FibGVGb3JtLFxuICAgICAgICAgICAgX3N1YmplY3RzLFxuICAgICAgICAgICAgX3Byb3h5Rm9ybVN0YXRlLFxuICAgICAgICAgICAgX3NldEVycm9ycyxcbiAgICAgICAgICAgIGdldCBfZmllbGRzKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfZmllbGRzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldCBfZm9ybVZhbHVlcygpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2Zvcm1WYWx1ZXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0IF9zdGF0ZSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3N0YXRlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldCBfc3RhdGUodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBfc3RhdGUgPSB2YWx1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQgX2RlZmF1bHRWYWx1ZXMoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9kZWZhdWx0VmFsdWVzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldCBfbmFtZXMoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9uYW1lcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQgX25hbWVzKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgX25hbWVzID0gdmFsdWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0IF9mb3JtU3RhdGUoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9mb3JtU3RhdGU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0IF9mb3JtU3RhdGUodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBfZm9ybVN0YXRlID0gdmFsdWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0IF9vcHRpb25zKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfb3B0aW9ucztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQgX29wdGlvbnModmFsdWUpIHtcbiAgICAgICAgICAgICAgICBfb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICAgICAgLi4uX29wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIC4uLnZhbHVlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICB0cmlnZ2VyLFxuICAgICAgICByZWdpc3RlcixcbiAgICAgICAgaGFuZGxlU3VibWl0LFxuICAgICAgICB3YXRjaCxcbiAgICAgICAgc2V0VmFsdWUsXG4gICAgICAgIGdldFZhbHVlcyxcbiAgICAgICAgcmVzZXQsXG4gICAgICAgIHJlc2V0RmllbGQsXG4gICAgICAgIGNsZWFyRXJyb3JzLFxuICAgICAgICB1bnJlZ2lzdGVyLFxuICAgICAgICBzZXRFcnJvcixcbiAgICAgICAgc2V0Rm9jdXMsXG4gICAgICAgIGdldEZpZWxkU3RhdGUsXG4gICAgfTtcbn1cblxuLyoqXG4gKiBDdXN0b20gaG9vayB0byBtYW5hZ2UgdGhlIGVudGlyZSBmb3JtLlxuICpcbiAqIEByZW1hcmtzXG4gKiBbQVBJXShodHRwczovL3JlYWN0LWhvb2stZm9ybS5jb20vZG9jcy91c2Vmb3JtKSDigKIgW0RlbW9dKGh0dHBzOi8vY29kZXNhbmRib3guaW8vcy9yZWFjdC1ob29rLWZvcm0tZ2V0LXN0YXJ0ZWQtdHMtNWtzbW0pIOKAoiBbVmlkZW9dKGh0dHBzOi8vd3d3LnlvdXR1YmUuY29tL3dhdGNoP3Y9UmtYdjRBWFhDXzQpXG4gKlxuICogQHBhcmFtIHByb3BzIC0gZm9ybSBjb25maWd1cmF0aW9uIGFuZCB2YWxpZGF0aW9uIHBhcmFtZXRlcnMuXG4gKlxuICogQHJldHVybnMgbWV0aG9kcyAtIGluZGl2aWR1YWwgZnVuY3Rpb25zIHRvIG1hbmFnZSB0aGUgZm9ybSBzdGF0ZS4ge0BsaW5rIFVzZUZvcm1SZXR1cm59XG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzeFxuICogZnVuY3Rpb24gQXBwKCkge1xuICogICBjb25zdCB7IHJlZ2lzdGVyLCBoYW5kbGVTdWJtaXQsIHdhdGNoLCBmb3JtU3RhdGU6IHsgZXJyb3JzIH0gfSA9IHVzZUZvcm0oKTtcbiAqICAgY29uc3Qgb25TdWJtaXQgPSBkYXRhID0+IGNvbnNvbGUubG9nKGRhdGEpO1xuICpcbiAqICAgY29uc29sZS5sb2cod2F0Y2goXCJleGFtcGxlXCIpKTtcbiAqXG4gKiAgIHJldHVybiAoXG4gKiAgICAgPGZvcm0gb25TdWJtaXQ9e2hhbmRsZVN1Ym1pdChvblN1Ym1pdCl9PlxuICogICAgICAgPGlucHV0IGRlZmF1bHRWYWx1ZT1cInRlc3RcIiB7Li4ucmVnaXN0ZXIoXCJleGFtcGxlXCIpfSAvPlxuICogICAgICAgPGlucHV0IHsuLi5yZWdpc3RlcihcImV4YW1wbGVSZXF1aXJlZFwiLCB7IHJlcXVpcmVkOiB0cnVlIH0pfSAvPlxuICogICAgICAge2Vycm9ycy5leGFtcGxlUmVxdWlyZWQgJiYgPHNwYW4+VGhpcyBmaWVsZCBpcyByZXF1aXJlZDwvc3Bhbj59XG4gKiAgICAgICA8YnV0dG9uPlN1Ym1pdDwvYnV0dG9uPlxuICogICAgIDwvZm9ybT5cbiAqICAgKTtcbiAqIH1cbiAqIGBgYFxuICovXG5mdW5jdGlvbiB1c2VGb3JtKHByb3BzID0ge30pIHtcbiAgICBjb25zdCBfZm9ybUNvbnRyb2wgPSBSZWFjdC51c2VSZWYoKTtcbiAgICBjb25zdCBfdmFsdWVzID0gUmVhY3QudXNlUmVmKCk7XG4gICAgY29uc3QgW2Zvcm1TdGF0ZSwgdXBkYXRlRm9ybVN0YXRlXSA9IFJlYWN0LnVzZVN0YXRlKHtcbiAgICAgICAgaXNEaXJ0eTogZmFsc2UsXG4gICAgICAgIGlzVmFsaWRhdGluZzogZmFsc2UsXG4gICAgICAgIGlzTG9hZGluZzogaXNGdW5jdGlvbihwcm9wcy5kZWZhdWx0VmFsdWVzKSxcbiAgICAgICAgaXNTdWJtaXR0ZWQ6IGZhbHNlLFxuICAgICAgICBpc1N1Ym1pdHRpbmc6IGZhbHNlLFxuICAgICAgICBpc1N1Ym1pdFN1Y2Nlc3NmdWw6IGZhbHNlLFxuICAgICAgICBpc1ZhbGlkOiBmYWxzZSxcbiAgICAgICAgc3VibWl0Q291bnQ6IDAsXG4gICAgICAgIGRpcnR5RmllbGRzOiB7fSxcbiAgICAgICAgdG91Y2hlZEZpZWxkczoge30sXG4gICAgICAgIHZhbGlkYXRpbmdGaWVsZHM6IHt9LFxuICAgICAgICBlcnJvcnM6IHByb3BzLmVycm9ycyB8fCB7fSxcbiAgICAgICAgZGlzYWJsZWQ6IHByb3BzLmRpc2FibGVkIHx8IGZhbHNlLFxuICAgICAgICBkZWZhdWx0VmFsdWVzOiBpc0Z1bmN0aW9uKHByb3BzLmRlZmF1bHRWYWx1ZXMpXG4gICAgICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICAgICAgOiBwcm9wcy5kZWZhdWx0VmFsdWVzLFxuICAgIH0pO1xuICAgIGlmICghX2Zvcm1Db250cm9sLmN1cnJlbnQpIHtcbiAgICAgICAgX2Zvcm1Db250cm9sLmN1cnJlbnQgPSB7XG4gICAgICAgICAgICAuLi5jcmVhdGVGb3JtQ29udHJvbChwcm9wcyksXG4gICAgICAgICAgICBmb3JtU3RhdGUsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGNvbnRyb2wgPSBfZm9ybUNvbnRyb2wuY3VycmVudC5jb250cm9sO1xuICAgIGNvbnRyb2wuX29wdGlvbnMgPSBwcm9wcztcbiAgICB1c2VTdWJzY3JpYmUoe1xuICAgICAgICBzdWJqZWN0OiBjb250cm9sLl9zdWJqZWN0cy5zdGF0ZSxcbiAgICAgICAgbmV4dDogKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBpZiAoc2hvdWxkUmVuZGVyRm9ybVN0YXRlKHZhbHVlLCBjb250cm9sLl9wcm94eUZvcm1TdGF0ZSwgY29udHJvbC5fdXBkYXRlRm9ybVN0YXRlLCB0cnVlKSkge1xuICAgICAgICAgICAgICAgIHVwZGF0ZUZvcm1TdGF0ZSh7IC4uLmNvbnRyb2wuX2Zvcm1TdGF0ZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9KTtcbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4gY29udHJvbC5fZGlzYWJsZUZvcm0ocHJvcHMuZGlzYWJsZWQpLCBbY29udHJvbCwgcHJvcHMuZGlzYWJsZWRdKTtcbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoY29udHJvbC5fcHJveHlGb3JtU3RhdGUuaXNEaXJ0eSkge1xuICAgICAgICAgICAgY29uc3QgaXNEaXJ0eSA9IGNvbnRyb2wuX2dldERpcnR5KCk7XG4gICAgICAgICAgICBpZiAoaXNEaXJ0eSAhPT0gZm9ybVN0YXRlLmlzRGlydHkpIHtcbiAgICAgICAgICAgICAgICBjb250cm9sLl9zdWJqZWN0cy5zdGF0ZS5uZXh0KHtcbiAgICAgICAgICAgICAgICAgICAgaXNEaXJ0eSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFtjb250cm9sLCBmb3JtU3RhdGUuaXNEaXJ0eV0pO1xuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChwcm9wcy52YWx1ZXMgJiYgIWRlZXBFcXVhbChwcm9wcy52YWx1ZXMsIF92YWx1ZXMuY3VycmVudCkpIHtcbiAgICAgICAgICAgIGNvbnRyb2wuX3Jlc2V0KHByb3BzLnZhbHVlcywgY29udHJvbC5fb3B0aW9ucy5yZXNldE9wdGlvbnMpO1xuICAgICAgICAgICAgX3ZhbHVlcy5jdXJyZW50ID0gcHJvcHMudmFsdWVzO1xuICAgICAgICAgICAgdXBkYXRlRm9ybVN0YXRlKChzdGF0ZSkgPT4gKHsgLi4uc3RhdGUgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29udHJvbC5fcmVzZXREZWZhdWx0VmFsdWVzKCk7XG4gICAgICAgIH1cbiAgICB9LCBbcHJvcHMudmFsdWVzLCBjb250cm9sXSk7XG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKHByb3BzLmVycm9ycykge1xuICAgICAgICAgICAgY29udHJvbC5fc2V0RXJyb3JzKHByb3BzLmVycm9ycyk7XG4gICAgICAgIH1cbiAgICB9LCBbcHJvcHMuZXJyb3JzLCBjb250cm9sXSk7XG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFjb250cm9sLl9zdGF0ZS5tb3VudCkge1xuICAgICAgICAgICAgY29udHJvbC5fdXBkYXRlVmFsaWQoKTtcbiAgICAgICAgICAgIGNvbnRyb2wuX3N0YXRlLm1vdW50ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udHJvbC5fc3RhdGUud2F0Y2gpIHtcbiAgICAgICAgICAgIGNvbnRyb2wuX3N0YXRlLndhdGNoID0gZmFsc2U7XG4gICAgICAgICAgICBjb250cm9sLl9zdWJqZWN0cy5zdGF0ZS5uZXh0KHsgLi4uY29udHJvbC5fZm9ybVN0YXRlIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRyb2wuX3JlbW92ZVVubW91bnRlZCgpO1xuICAgIH0pO1xuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHByb3BzLnNob3VsZFVucmVnaXN0ZXIgJiZcbiAgICAgICAgICAgIGNvbnRyb2wuX3N1YmplY3RzLnZhbHVlcy5uZXh0KHtcbiAgICAgICAgICAgICAgICB2YWx1ZXM6IGNvbnRyb2wuX2dldFdhdGNoKCksXG4gICAgICAgICAgICB9KTtcbiAgICB9LCBbcHJvcHMuc2hvdWxkVW5yZWdpc3RlciwgY29udHJvbF0pO1xuICAgIF9mb3JtQ29udHJvbC5jdXJyZW50LmZvcm1TdGF0ZSA9IGdldFByb3h5Rm9ybVN0YXRlKGZvcm1TdGF0ZSwgY29udHJvbCk7XG4gICAgcmV0dXJuIF9mb3JtQ29udHJvbC5jdXJyZW50O1xufVxuXG5leHBvcnQgeyBDb250cm9sbGVyLCBGb3JtLCBGb3JtUHJvdmlkZXIsIGFwcGVuZEVycm9ycywgZ2V0LCBzZXQsIHVzZUNvbnRyb2xsZXIsIHVzZUZpZWxkQXJyYXksIHVzZUZvcm0sIHVzZUZvcm1Db250ZXh0LCB1c2VGb3JtU3RhdGUsIHVzZVdhdGNoIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5lc20ubWpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///9785\n")}}]);